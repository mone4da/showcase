{"ast":null,"code":"import _slicedToArray from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _get from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _createClass from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _inherits from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Mesh, PlaneGeometry, MeshBasicMaterial, CanvasTexture, sRGBEncoding, LinearFilter, Color } from 'three';\nvar HTMLMesh = /*#__PURE__*/function (_Mesh) {\n  _inherits(HTMLMesh, _Mesh);\n  var _super = _createSuper(HTMLMesh);\n  function HTMLMesh(dom) {\n    var _this;\n    _classCallCheck(this, HTMLMesh);\n    var texture = new HTMLTexture(dom);\n    var geometry = new PlaneGeometry(texture.image.width * 0.001, texture.image.height * 0.001);\n    var material = new MeshBasicMaterial({\n      map: texture,\n      toneMapped: false,\n      transparent: true\n    });\n    _this = _super.call(this, geometry, material);\n    function onEvent(event) {\n      material.map.dispatchDOMEvent(event);\n    }\n    _this.addEventListener('mousedown', onEvent);\n    _this.addEventListener('mousemove', onEvent);\n    _this.addEventListener('mouseup', onEvent);\n    _this.addEventListener('click', onEvent);\n    _this.dispose = function () {\n      geometry.dispose();\n      material.dispose();\n      material.map.dispose();\n      canvases.delete(dom);\n      this.removeEventListener('mousedown', onEvent);\n      this.removeEventListener('mousemove', onEvent);\n      this.removeEventListener('mouseup', onEvent);\n      this.removeEventListener('click', onEvent);\n    };\n    return _this;\n  }\n  return _createClass(HTMLMesh);\n}(Mesh);\nvar HTMLTexture = /*#__PURE__*/function (_CanvasTexture) {\n  _inherits(HTMLTexture, _CanvasTexture);\n  var _super2 = _createSuper(HTMLTexture);\n  function HTMLTexture(dom) {\n    var _this2;\n    _classCallCheck(this, HTMLTexture);\n    _this2 = _super2.call(this, html2canvas(dom));\n    _this2.dom = dom;\n    _this2.anisotropy = 16;\n    _this2.encoding = sRGBEncoding;\n    _this2.minFilter = LinearFilter;\n    _this2.magFilter = LinearFilter; // Create an observer on the DOM, and run html2canvas update in the next loop\n\n    var observer = new MutationObserver(function () {\n      if (!_this2.scheduleUpdate) {\n        // ideally should use xr.requestAnimationFrame, here setTimeout to avoid passing the renderer\n        _this2.scheduleUpdate = setTimeout(function () {\n          return _this2.update();\n        }, 16);\n      }\n    });\n    var config = {\n      attributes: true,\n      childList: true,\n      subtree: true,\n      characterData: true\n    };\n    observer.observe(dom, config);\n    _this2.observer = observer;\n    return _this2;\n  }\n  _createClass(HTMLTexture, [{\n    key: \"dispatchDOMEvent\",\n    value: function dispatchDOMEvent(event) {\n      if (event.data) {\n        htmlevent(this.dom, event.type, event.data.x, event.data.y);\n      }\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      this.image = html2canvas(this.dom);\n      this.needsUpdate = true;\n      this.scheduleUpdate = null;\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      if (this.observer) {\n        this.observer.disconnect();\n      }\n      this.scheduleUpdate = clearTimeout(this.scheduleUpdate);\n      _get(_getPrototypeOf(HTMLTexture.prototype), \"dispose\", this).call(this);\n    }\n  }]);\n  return HTMLTexture;\n}(CanvasTexture); //\nvar canvases = new WeakMap();\nfunction html2canvas(element) {\n  var range = document.createRange();\n  var color = new Color();\n  function Clipper(context) {\n    var clips = [];\n    var isClipping = false;\n    function doClip() {\n      if (isClipping) {\n        isClipping = false;\n        context.restore();\n      }\n      if (clips.length === 0) return;\n      var minX = -Infinity,\n        minY = -Infinity;\n      var maxX = Infinity,\n        maxY = Infinity;\n      for (var i = 0; i < clips.length; i++) {\n        var clip = clips[i];\n        minX = Math.max(minX, clip.x);\n        minY = Math.max(minY, clip.y);\n        maxX = Math.min(maxX, clip.x + clip.width);\n        maxY = Math.min(maxY, clip.y + clip.height);\n      }\n      context.save();\n      context.beginPath();\n      context.rect(minX, minY, maxX - minX, maxY - minY);\n      context.clip();\n      isClipping = true;\n    }\n    return {\n      add: function add(clip) {\n        clips.push(clip);\n        doClip();\n      },\n      remove: function remove() {\n        clips.pop();\n        doClip();\n      }\n    };\n  }\n  function drawText(style, x, y, string) {\n    if (string !== '') {\n      if (style.textTransform === 'uppercase') {\n        string = string.toUpperCase();\n      }\n      context.font = style.fontWeight + ' ' + style.fontSize + ' ' + style.fontFamily;\n      context.textBaseline = 'top';\n      context.fillStyle = style.color;\n      context.fillText(string, x, y + parseFloat(style.fontSize) * 0.1);\n    }\n  }\n  function buildRectPath(x, y, w, h, r) {\n    if (w < 2 * r) r = w / 2;\n    if (h < 2 * r) r = h / 2;\n    context.beginPath();\n    context.moveTo(x + r, y);\n    context.arcTo(x + w, y, x + w, y + h, r);\n    context.arcTo(x + w, y + h, x, y + h, r);\n    context.arcTo(x, y + h, x, y, r);\n    context.arcTo(x, y, x + w, y, r);\n    context.closePath();\n  }\n  function drawBorder(style, which, x, y, width, height) {\n    var borderWidth = style[which + 'Width'];\n    var borderStyle = style[which + 'Style'];\n    var borderColor = style[which + 'Color'];\n    if (borderWidth !== '0px' && borderStyle !== 'none' && borderColor !== 'transparent' && borderColor !== 'rgba(0, 0, 0, 0)') {\n      context.strokeStyle = borderColor;\n      context.lineWidth = parseFloat(borderWidth);\n      context.beginPath();\n      context.moveTo(x, y);\n      context.lineTo(x + width, y + height);\n      context.stroke();\n    }\n  }\n  function drawElement(element, style) {\n    var x = 0,\n      y = 0,\n      width = 0,\n      height = 0;\n    if (element.nodeType === Node.TEXT_NODE) {\n      // text\n      range.selectNode(element);\n      var rect = range.getBoundingClientRect();\n      x = rect.left - offset.left - 0.5;\n      y = rect.top - offset.top - 0.5;\n      width = rect.width;\n      height = rect.height;\n      drawText(style, x, y, element.nodeValue.trim());\n    } else if (element.nodeType === Node.COMMENT_NODE) {\n      return;\n    } else if (element instanceof HTMLCanvasElement) {\n      // Canvas element\n      if (element.style.display === 'none') return;\n      context.save();\n      var dpr = window.devicePixelRatio;\n      context.scale(1 / dpr, 1 / dpr);\n      context.drawImage(element, 0, 0);\n      context.restore();\n    } else {\n      if (element.style.display === 'none') return;\n      var _rect = element.getBoundingClientRect();\n      x = _rect.left - offset.left - 0.5;\n      y = _rect.top - offset.top - 0.5;\n      width = _rect.width;\n      height = _rect.height;\n      style = window.getComputedStyle(element); // Get the border of the element used for fill and border\n\n      buildRectPath(x, y, width, height, parseFloat(style.borderRadius));\n      var backgroundColor = style.backgroundColor;\n      if (backgroundColor !== 'transparent' && backgroundColor !== 'rgba(0, 0, 0, 0)') {\n        context.fillStyle = backgroundColor;\n        context.fill();\n      } // If all the borders match then stroke the round rectangle\n\n      var borders = ['borderTop', 'borderLeft', 'borderBottom', 'borderRight'];\n      var match = true;\n      var prevBorder = null;\n      for (var _i = 0, _borders = borders; _i < _borders.length; _i++) {\n        var border = _borders[_i];\n        if (prevBorder !== null) {\n          match = style[border + 'Width'] === style[prevBorder + 'Width'] && style[border + 'Color'] === style[prevBorder + 'Color'] && style[border + 'Style'] === style[prevBorder + 'Style'];\n        }\n        if (match === false) break;\n        prevBorder = border;\n      }\n      if (match === true) {\n        // They all match so stroke the rectangle from before allows for border-radius\n        var _width = parseFloat(style.borderTopWidth);\n        if (style.borderTopWidth !== '0px' && style.borderTopStyle !== 'none' && style.borderTopColor !== 'transparent' && style.borderTopColor !== 'rgba(0, 0, 0, 0)') {\n          context.strokeStyle = style.borderTopColor;\n          context.lineWidth = _width;\n          context.stroke();\n        }\n      } else {\n        // Otherwise draw individual borders\n        drawBorder(style, 'borderTop', x, y, width, 0);\n        drawBorder(style, 'borderLeft', x, y, 0, height);\n        drawBorder(style, 'borderBottom', x, y + height, width, 0);\n        drawBorder(style, 'borderRight', x + width, y, 0, height);\n      }\n      if (element instanceof HTMLInputElement) {\n        var accentColor = style.accentColor;\n        if (accentColor === undefined || accentColor === 'auto') accentColor = style.color;\n        color.set(accentColor);\n        var luminance = Math.sqrt(0.299 * Math.pow(color.r, 2) + 0.587 * Math.pow(color.g, 2) + 0.114 * Math.pow(color.b, 2));\n        var accentTextColor = luminance < 0.5 ? 'white' : '#111111';\n        if (element.type === 'radio') {\n          buildRectPath(x, y, width, height, height);\n          context.fillStyle = 'white';\n          context.strokeStyle = accentColor;\n          context.lineWidth = 1;\n          context.fill();\n          context.stroke();\n          if (element.checked) {\n            buildRectPath(x + 2, y + 2, width - 4, height - 4, height);\n            context.fillStyle = accentColor;\n            context.strokeStyle = accentTextColor;\n            context.lineWidth = 2;\n            context.fill();\n            context.stroke();\n          }\n        }\n        if (element.type === 'checkbox') {\n          buildRectPath(x, y, width, height, 2);\n          context.fillStyle = element.checked ? accentColor : 'white';\n          context.strokeStyle = element.checked ? accentTextColor : accentColor;\n          context.lineWidth = 1;\n          context.stroke();\n          context.fill();\n          if (element.checked) {\n            var currentTextAlign = context.textAlign;\n            context.textAlign = 'center';\n            var properties = {\n              color: accentTextColor,\n              fontFamily: style.fontFamily,\n              fontSize: height + 'px',\n              fontWeight: 'bold'\n            };\n            drawText(properties, x + width / 2, y, '✔');\n            context.textAlign = currentTextAlign;\n          }\n        }\n        if (element.type === 'range') {\n          var _map = ['min', 'max', 'value'].map(function (property) {\n              return parseFloat(element[property]);\n            }),\n            _map2 = _slicedToArray(_map, 3),\n            min = _map2[0],\n            max = _map2[1],\n            value = _map2[2];\n          var position = (value - min) / (max - min) * (width - height);\n          buildRectPath(x, y + height / 4, width, height / 2, height / 4);\n          context.fillStyle = accentTextColor;\n          context.strokeStyle = accentColor;\n          context.lineWidth = 1;\n          context.fill();\n          context.stroke();\n          buildRectPath(x, y + height / 4, position + height / 2, height / 2, height / 4);\n          context.fillStyle = accentColor;\n          context.fill();\n          buildRectPath(x + position, y, height, height, height / 2);\n          context.fillStyle = accentColor;\n          context.fill();\n        }\n        if (element.type === 'color' || element.type === 'text' || element.type === 'number') {\n          clipper.add({\n            x: x,\n            y: y,\n            width: width,\n            height: height\n          });\n          drawText(style, x + parseInt(style.paddingLeft), y + parseInt(style.paddingTop), element.value);\n          clipper.remove();\n        }\n      }\n    }\n    /*\n    // debug\n    context.strokeStyle = '#' + Math.random().toString( 16 ).slice( - 3 );\n    context.strokeRect( x - 0.5, y - 0.5, width + 1, height + 1 );\n    */\n\n    var isClipping = style.overflow === 'auto' || style.overflow === 'hidden';\n    if (isClipping) clipper.add({\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    });\n    for (var i = 0; i < element.childNodes.length; i++) {\n      drawElement(element.childNodes[i], style);\n    }\n    if (isClipping) clipper.remove();\n  }\n  var offset = element.getBoundingClientRect();\n  var canvas = canvases.get(element);\n  if (canvas === undefined) {\n    canvas = document.createElement('canvas');\n    canvas.width = offset.width;\n    canvas.height = offset.height;\n    canvases.set(element, canvas);\n  }\n  var context = canvas.getContext('2d'\n  /*, { alpha: false }*/);\n\n  var clipper = new Clipper(context); // console.time( 'drawElement' );\n\n  drawElement(element); // console.timeEnd( 'drawElement' );\n\n  return canvas;\n}\nfunction htmlevent(element, event, x, y) {\n  var mouseEventInit = {\n    clientX: x * element.offsetWidth + element.offsetLeft,\n    clientY: y * element.offsetHeight + element.offsetTop,\n    view: element.ownerDocument.defaultView\n  };\n  window.dispatchEvent(new MouseEvent(event, mouseEventInit));\n  var rect = element.getBoundingClientRect();\n  x = x * rect.width + rect.left;\n  y = y * rect.height + rect.top;\n  function traverse(element) {\n    if (element.nodeType !== Node.TEXT_NODE && element.nodeType !== Node.COMMENT_NODE) {\n      var _rect2 = element.getBoundingClientRect();\n      if (x > _rect2.left && x < _rect2.right && y > _rect2.top && y < _rect2.bottom) {\n        element.dispatchEvent(new MouseEvent(event, mouseEventInit));\n        if (element instanceof HTMLInputElement && element.type === 'range' && (event === 'mousedown' || event === 'click')) {\n          var _map3 = ['min', 'max'].map(function (property) {\n              return parseFloat(element[property]);\n            }),\n            _map4 = _slicedToArray(_map3, 2),\n            min = _map4[0],\n            max = _map4[1];\n          var width = _rect2.width;\n          var offsetX = x - _rect2.x;\n          var proportion = offsetX / width;\n          element.value = min + (max - min) * proportion;\n          element.dispatchEvent(new InputEvent('input', {\n            bubbles: true\n          }));\n        }\n      }\n      for (var i = 0; i < element.childNodes.length; i++) {\n        traverse(element.childNodes[i]);\n      }\n    }\n  }\n  traverse(element);\n}\nexport { HTMLMesh };","map":{"version":3,"names":["Mesh","PlaneGeometry","MeshBasicMaterial","CanvasTexture","sRGBEncoding","LinearFilter","Color","HTMLMesh","_Mesh","_inherits","_super","_createSuper","dom","_this","_classCallCheck","texture","HTMLTexture","geometry","image","width","height","material","map","toneMapped","transparent","call","onEvent","event","dispatchDOMEvent","addEventListener","dispose","canvases","delete","removeEventListener","_createClass","_CanvasTexture","_super2","_this2","html2canvas","anisotropy","encoding","minFilter","magFilter","observer","MutationObserver","scheduleUpdate","setTimeout","update","config","attributes","childList","subtree","characterData","observe","key","value","data","htmlevent","type","x","y","needsUpdate","disconnect","clearTimeout","_get","_getPrototypeOf","prototype","WeakMap","element","range","document","createRange","color","Clipper","context","clips","isClipping","doClip","restore","length","minX","Infinity","minY","maxX","maxY","i","clip","Math","max","min","save","beginPath","rect","add","push","remove","pop","drawText","style","string","textTransform","toUpperCase","font","fontWeight","fontSize","fontFamily","textBaseline","fillStyle","fillText","parseFloat","buildRectPath","w","h","r","moveTo","arcTo","closePath","drawBorder","which","borderWidth","borderStyle","borderColor","strokeStyle","lineWidth","lineTo","stroke","drawElement","nodeType","Node","TEXT_NODE","selectNode","getBoundingClientRect","left","offset","top","nodeValue","trim","COMMENT_NODE","HTMLCanvasElement","display","dpr","window","devicePixelRatio","scale","drawImage","getComputedStyle","borderRadius","backgroundColor","fill","borders","match","prevBorder","_i","_borders","border","borderTopWidth","borderTopStyle","borderTopColor","HTMLInputElement","accentColor","undefined","set","luminance","sqrt","pow","g","b","accentTextColor","checked","currentTextAlign","textAlign","properties","_map","property","_map2","_slicedToArray","position","clipper","parseInt","paddingLeft","paddingTop","overflow","childNodes","canvas","get","createElement","getContext","mouseEventInit","clientX","offsetWidth","offsetLeft","clientY","offsetHeight","offsetTop","view","ownerDocument","defaultView","dispatchEvent","MouseEvent","traverse","right","bottom","_map3","_map4","offsetX","proportion","InputEvent","bubbles"],"sources":["/home/samuel/experiment/3d/farm/frontend/node_modules/three-stdlib/interactive/HTMLMesh.js"],"sourcesContent":["import { Mesh, PlaneGeometry, MeshBasicMaterial, CanvasTexture, sRGBEncoding, LinearFilter, Color } from 'three';\n\nclass HTMLMesh extends Mesh {\n  constructor(dom) {\n    const texture = new HTMLTexture(dom);\n    const geometry = new PlaneGeometry(texture.image.width * 0.001, texture.image.height * 0.001);\n    const material = new MeshBasicMaterial({\n      map: texture,\n      toneMapped: false,\n      transparent: true\n    });\n    super(geometry, material);\n\n    function onEvent(event) {\n      material.map.dispatchDOMEvent(event);\n    }\n\n    this.addEventListener('mousedown', onEvent);\n    this.addEventListener('mousemove', onEvent);\n    this.addEventListener('mouseup', onEvent);\n    this.addEventListener('click', onEvent);\n\n    this.dispose = function () {\n      geometry.dispose();\n      material.dispose();\n      material.map.dispose();\n      canvases.delete(dom);\n      this.removeEventListener('mousedown', onEvent);\n      this.removeEventListener('mousemove', onEvent);\n      this.removeEventListener('mouseup', onEvent);\n      this.removeEventListener('click', onEvent);\n    };\n  }\n\n}\n\nclass HTMLTexture extends CanvasTexture {\n  constructor(dom) {\n    super(html2canvas(dom));\n    this.dom = dom;\n    this.anisotropy = 16;\n    this.encoding = sRGBEncoding;\n    this.minFilter = LinearFilter;\n    this.magFilter = LinearFilter; // Create an observer on the DOM, and run html2canvas update in the next loop\n\n    const observer = new MutationObserver(() => {\n      if (!this.scheduleUpdate) {\n        // ideally should use xr.requestAnimationFrame, here setTimeout to avoid passing the renderer\n        this.scheduleUpdate = setTimeout(() => this.update(), 16);\n      }\n    });\n    const config = {\n      attributes: true,\n      childList: true,\n      subtree: true,\n      characterData: true\n    };\n    observer.observe(dom, config);\n    this.observer = observer;\n  }\n\n  dispatchDOMEvent(event) {\n    if (event.data) {\n      htmlevent(this.dom, event.type, event.data.x, event.data.y);\n    }\n  }\n\n  update() {\n    this.image = html2canvas(this.dom);\n    this.needsUpdate = true;\n    this.scheduleUpdate = null;\n  }\n\n  dispose() {\n    if (this.observer) {\n      this.observer.disconnect();\n    }\n\n    this.scheduleUpdate = clearTimeout(this.scheduleUpdate);\n    super.dispose();\n  }\n\n} //\n\n\nconst canvases = new WeakMap();\n\nfunction html2canvas(element) {\n  const range = document.createRange();\n  const color = new Color();\n\n  function Clipper(context) {\n    const clips = [];\n    let isClipping = false;\n\n    function doClip() {\n      if (isClipping) {\n        isClipping = false;\n        context.restore();\n      }\n\n      if (clips.length === 0) return;\n      let minX = -Infinity,\n          minY = -Infinity;\n      let maxX = Infinity,\n          maxY = Infinity;\n\n      for (let i = 0; i < clips.length; i++) {\n        const clip = clips[i];\n        minX = Math.max(minX, clip.x);\n        minY = Math.max(minY, clip.y);\n        maxX = Math.min(maxX, clip.x + clip.width);\n        maxY = Math.min(maxY, clip.y + clip.height);\n      }\n\n      context.save();\n      context.beginPath();\n      context.rect(minX, minY, maxX - minX, maxY - minY);\n      context.clip();\n      isClipping = true;\n    }\n\n    return {\n      add: function (clip) {\n        clips.push(clip);\n        doClip();\n      },\n      remove: function () {\n        clips.pop();\n        doClip();\n      }\n    };\n  }\n\n  function drawText(style, x, y, string) {\n    if (string !== '') {\n      if (style.textTransform === 'uppercase') {\n        string = string.toUpperCase();\n      }\n\n      context.font = style.fontWeight + ' ' + style.fontSize + ' ' + style.fontFamily;\n      context.textBaseline = 'top';\n      context.fillStyle = style.color;\n      context.fillText(string, x, y + parseFloat(style.fontSize) * 0.1);\n    }\n  }\n\n  function buildRectPath(x, y, w, h, r) {\n    if (w < 2 * r) r = w / 2;\n    if (h < 2 * r) r = h / 2;\n    context.beginPath();\n    context.moveTo(x + r, y);\n    context.arcTo(x + w, y, x + w, y + h, r);\n    context.arcTo(x + w, y + h, x, y + h, r);\n    context.arcTo(x, y + h, x, y, r);\n    context.arcTo(x, y, x + w, y, r);\n    context.closePath();\n  }\n\n  function drawBorder(style, which, x, y, width, height) {\n    const borderWidth = style[which + 'Width'];\n    const borderStyle = style[which + 'Style'];\n    const borderColor = style[which + 'Color'];\n\n    if (borderWidth !== '0px' && borderStyle !== 'none' && borderColor !== 'transparent' && borderColor !== 'rgba(0, 0, 0, 0)') {\n      context.strokeStyle = borderColor;\n      context.lineWidth = parseFloat(borderWidth);\n      context.beginPath();\n      context.moveTo(x, y);\n      context.lineTo(x + width, y + height);\n      context.stroke();\n    }\n  }\n\n  function drawElement(element, style) {\n    let x = 0,\n        y = 0,\n        width = 0,\n        height = 0;\n\n    if (element.nodeType === Node.TEXT_NODE) {\n      // text\n      range.selectNode(element);\n      const rect = range.getBoundingClientRect();\n      x = rect.left - offset.left - 0.5;\n      y = rect.top - offset.top - 0.5;\n      width = rect.width;\n      height = rect.height;\n      drawText(style, x, y, element.nodeValue.trim());\n    } else if (element.nodeType === Node.COMMENT_NODE) {\n      return;\n    } else if (element instanceof HTMLCanvasElement) {\n      // Canvas element\n      if (element.style.display === 'none') return;\n      context.save();\n      const dpr = window.devicePixelRatio;\n      context.scale(1 / dpr, 1 / dpr);\n      context.drawImage(element, 0, 0);\n      context.restore();\n    } else {\n      if (element.style.display === 'none') return;\n      const rect = element.getBoundingClientRect();\n      x = rect.left - offset.left - 0.5;\n      y = rect.top - offset.top - 0.5;\n      width = rect.width;\n      height = rect.height;\n      style = window.getComputedStyle(element); // Get the border of the element used for fill and border\n\n      buildRectPath(x, y, width, height, parseFloat(style.borderRadius));\n      const backgroundColor = style.backgroundColor;\n\n      if (backgroundColor !== 'transparent' && backgroundColor !== 'rgba(0, 0, 0, 0)') {\n        context.fillStyle = backgroundColor;\n        context.fill();\n      } // If all the borders match then stroke the round rectangle\n\n\n      const borders = ['borderTop', 'borderLeft', 'borderBottom', 'borderRight'];\n      let match = true;\n      let prevBorder = null;\n\n      for (const border of borders) {\n        if (prevBorder !== null) {\n          match = style[border + 'Width'] === style[prevBorder + 'Width'] && style[border + 'Color'] === style[prevBorder + 'Color'] && style[border + 'Style'] === style[prevBorder + 'Style'];\n        }\n\n        if (match === false) break;\n        prevBorder = border;\n      }\n\n      if (match === true) {\n        // They all match so stroke the rectangle from before allows for border-radius\n        const width = parseFloat(style.borderTopWidth);\n\n        if (style.borderTopWidth !== '0px' && style.borderTopStyle !== 'none' && style.borderTopColor !== 'transparent' && style.borderTopColor !== 'rgba(0, 0, 0, 0)') {\n          context.strokeStyle = style.borderTopColor;\n          context.lineWidth = width;\n          context.stroke();\n        }\n      } else {\n        // Otherwise draw individual borders\n        drawBorder(style, 'borderTop', x, y, width, 0);\n        drawBorder(style, 'borderLeft', x, y, 0, height);\n        drawBorder(style, 'borderBottom', x, y + height, width, 0);\n        drawBorder(style, 'borderRight', x + width, y, 0, height);\n      }\n\n      if (element instanceof HTMLInputElement) {\n        let accentColor = style.accentColor;\n        if (accentColor === undefined || accentColor === 'auto') accentColor = style.color;\n        color.set(accentColor);\n        const luminance = Math.sqrt(0.299 * color.r ** 2 + 0.587 * color.g ** 2 + 0.114 * color.b ** 2);\n        const accentTextColor = luminance < 0.5 ? 'white' : '#111111';\n\n        if (element.type === 'radio') {\n          buildRectPath(x, y, width, height, height);\n          context.fillStyle = 'white';\n          context.strokeStyle = accentColor;\n          context.lineWidth = 1;\n          context.fill();\n          context.stroke();\n\n          if (element.checked) {\n            buildRectPath(x + 2, y + 2, width - 4, height - 4, height);\n            context.fillStyle = accentColor;\n            context.strokeStyle = accentTextColor;\n            context.lineWidth = 2;\n            context.fill();\n            context.stroke();\n          }\n        }\n\n        if (element.type === 'checkbox') {\n          buildRectPath(x, y, width, height, 2);\n          context.fillStyle = element.checked ? accentColor : 'white';\n          context.strokeStyle = element.checked ? accentTextColor : accentColor;\n          context.lineWidth = 1;\n          context.stroke();\n          context.fill();\n\n          if (element.checked) {\n            const currentTextAlign = context.textAlign;\n            context.textAlign = 'center';\n            const properties = {\n              color: accentTextColor,\n              fontFamily: style.fontFamily,\n              fontSize: height + 'px',\n              fontWeight: 'bold'\n            };\n            drawText(properties, x + width / 2, y, '✔');\n            context.textAlign = currentTextAlign;\n          }\n        }\n\n        if (element.type === 'range') {\n          const [min, max, value] = ['min', 'max', 'value'].map(property => parseFloat(element[property]));\n          const position = (value - min) / (max - min) * (width - height);\n          buildRectPath(x, y + height / 4, width, height / 2, height / 4);\n          context.fillStyle = accentTextColor;\n          context.strokeStyle = accentColor;\n          context.lineWidth = 1;\n          context.fill();\n          context.stroke();\n          buildRectPath(x, y + height / 4, position + height / 2, height / 2, height / 4);\n          context.fillStyle = accentColor;\n          context.fill();\n          buildRectPath(x + position, y, height, height, height / 2);\n          context.fillStyle = accentColor;\n          context.fill();\n        }\n\n        if (element.type === 'color' || element.type === 'text' || element.type === 'number') {\n          clipper.add({\n            x: x,\n            y: y,\n            width: width,\n            height: height\n          });\n          drawText(style, x + parseInt(style.paddingLeft), y + parseInt(style.paddingTop), element.value);\n          clipper.remove();\n        }\n      }\n    }\n    /*\n    // debug\n    context.strokeStyle = '#' + Math.random().toString( 16 ).slice( - 3 );\n    context.strokeRect( x - 0.5, y - 0.5, width + 1, height + 1 );\n    */\n\n\n    const isClipping = style.overflow === 'auto' || style.overflow === 'hidden';\n    if (isClipping) clipper.add({\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    });\n\n    for (let i = 0; i < element.childNodes.length; i++) {\n      drawElement(element.childNodes[i], style);\n    }\n\n    if (isClipping) clipper.remove();\n  }\n\n  const offset = element.getBoundingClientRect();\n  let canvas = canvases.get(element);\n\n  if (canvas === undefined) {\n    canvas = document.createElement('canvas');\n    canvas.width = offset.width;\n    canvas.height = offset.height;\n    canvases.set(element, canvas);\n  }\n\n  const context = canvas.getContext('2d'\n  /*, { alpha: false }*/\n  );\n  const clipper = new Clipper(context); // console.time( 'drawElement' );\n\n  drawElement(element); // console.timeEnd( 'drawElement' );\n\n  return canvas;\n}\n\nfunction htmlevent(element, event, x, y) {\n  const mouseEventInit = {\n    clientX: x * element.offsetWidth + element.offsetLeft,\n    clientY: y * element.offsetHeight + element.offsetTop,\n    view: element.ownerDocument.defaultView\n  };\n  window.dispatchEvent(new MouseEvent(event, mouseEventInit));\n  const rect = element.getBoundingClientRect();\n  x = x * rect.width + rect.left;\n  y = y * rect.height + rect.top;\n\n  function traverse(element) {\n    if (element.nodeType !== Node.TEXT_NODE && element.nodeType !== Node.COMMENT_NODE) {\n      const rect = element.getBoundingClientRect();\n\n      if (x > rect.left && x < rect.right && y > rect.top && y < rect.bottom) {\n        element.dispatchEvent(new MouseEvent(event, mouseEventInit));\n\n        if (element instanceof HTMLInputElement && element.type === 'range' && (event === 'mousedown' || event === 'click')) {\n          const [min, max] = ['min', 'max'].map(property => parseFloat(element[property]));\n          const width = rect.width;\n          const offsetX = x - rect.x;\n          const proportion = offsetX / width;\n          element.value = min + (max - min) * proportion;\n          element.dispatchEvent(new InputEvent('input', {\n            bubbles: true\n          }));\n        }\n      }\n\n      for (let i = 0; i < element.childNodes.length; i++) {\n        traverse(element.childNodes[i]);\n      }\n    }\n  }\n\n  traverse(element);\n}\n\nexport { HTMLMesh };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}