{"ast":null,"code":"import _createClass from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _possibleConstructorReturn from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js\";\nimport _inherits from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Vector3, BoxGeometry } from 'three';\nvar tempNormal = new Vector3();\nfunction getUv(faceDirVector, normal, uvAxis, projectionAxis, radius, sideLength) {\n  var totArcLength = 2 * Math.PI * radius / 4; // length of the planes between the arcs on each axis\n\n  var centerLength = Math.max(sideLength - 2 * radius, 0);\n  var halfArc = Math.PI / 4; // Get the vector projected onto the Y plane\n\n  tempNormal.copy(normal);\n  tempNormal[projectionAxis] = 0;\n  tempNormal.normalize(); // total amount of UV space alloted to a single arc\n\n  var arcUvRatio = 0.5 * totArcLength / (totArcLength + centerLength); // the distance along one arc the point is at\n\n  var arcAngleRatio = 1.0 - tempNormal.angleTo(faceDirVector) / halfArc;\n  if (Math.sign(tempNormal[uvAxis]) === 1) {\n    return arcAngleRatio * arcUvRatio;\n  } else {\n    // total amount of UV space alloted to the plane between the arcs\n    var lenUv = centerLength / (totArcLength + centerLength);\n    return lenUv + arcUvRatio + arcUvRatio * (1.0 - arcAngleRatio);\n  }\n}\nvar RoundedBoxGeometry = /*#__PURE__*/function (_BoxGeometry) {\n  _inherits(RoundedBoxGeometry, _BoxGeometry);\n  var _super = _createSuper(RoundedBoxGeometry);\n  function RoundedBoxGeometry() {\n    var _this;\n    var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    var segments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 2;\n    var radius = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.1;\n    _classCallCheck(this, RoundedBoxGeometry);\n    // ensure segments is odd so we have a plane connecting the rounded corners\n    segments = segments * 2 + 1; // ensure radius isn't bigger than shortest side\n\n    radius = Math.min(width / 2, height / 2, depth / 2, radius);\n    _this = _super.call(this, 1, 1, 1, segments, segments, segments); // if we just have one segment we're the same as a regular box\n\n    if (segments === 1) return _possibleConstructorReturn(_this);\n    var geometry2 = _this.toNonIndexed();\n    _this.index = null;\n    _this.attributes.position = geometry2.attributes.position;\n    _this.attributes.normal = geometry2.attributes.normal;\n    _this.attributes.uv = geometry2.attributes.uv; //\n\n    var position = new Vector3();\n    var normal = new Vector3();\n    var box = new Vector3(width, height, depth).divideScalar(2).subScalar(radius);\n    var positions = _this.attributes.position.array;\n    var normals = _this.attributes.normal.array;\n    var uvs = _this.attributes.uv.array;\n    var faceTris = positions.length / 6;\n    var faceDirVector = new Vector3();\n    var halfSegmentSize = 0.5 / segments;\n    for (var i = 0, j = 0; i < positions.length; i += 3, j += 2) {\n      position.fromArray(positions, i);\n      normal.copy(position);\n      normal.x -= Math.sign(normal.x) * halfSegmentSize;\n      normal.y -= Math.sign(normal.y) * halfSegmentSize;\n      normal.z -= Math.sign(normal.z) * halfSegmentSize;\n      normal.normalize();\n      positions[i + 0] = box.x * Math.sign(position.x) + normal.x * radius;\n      positions[i + 1] = box.y * Math.sign(position.y) + normal.y * radius;\n      positions[i + 2] = box.z * Math.sign(position.z) + normal.z * radius;\n      normals[i + 0] = normal.x;\n      normals[i + 1] = normal.y;\n      normals[i + 2] = normal.z;\n      var side = Math.floor(i / faceTris);\n      switch (side) {\n        case 0:\n          // right\n          // generate UVs along Z then Y\n          faceDirVector.set(1, 0, 0);\n          uvs[j + 0] = getUv(faceDirVector, normal, 'z', 'y', radius, depth);\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'y', 'z', radius, height);\n          break;\n        case 1:\n          // left\n          // generate UVs along Z then Y\n          faceDirVector.set(-1, 0, 0);\n          uvs[j + 0] = 1.0 - getUv(faceDirVector, normal, 'z', 'y', radius, depth);\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'y', 'z', radius, height);\n          break;\n        case 2:\n          // top\n          // generate UVs along X then Z\n          faceDirVector.set(0, 1, 0);\n          uvs[j + 0] = 1.0 - getUv(faceDirVector, normal, 'x', 'z', radius, width);\n          uvs[j + 1] = getUv(faceDirVector, normal, 'z', 'x', radius, depth);\n          break;\n        case 3:\n          // bottom\n          // generate UVs along X then Z\n          faceDirVector.set(0, -1, 0);\n          uvs[j + 0] = 1.0 - getUv(faceDirVector, normal, 'x', 'z', radius, width);\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'z', 'x', radius, depth);\n          break;\n        case 4:\n          // front\n          // generate UVs along X then Y\n          faceDirVector.set(0, 0, 1);\n          uvs[j + 0] = 1.0 - getUv(faceDirVector, normal, 'x', 'y', radius, width);\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'y', 'x', radius, height);\n          break;\n        case 5:\n          // back\n          // generate UVs along X then Y\n          faceDirVector.set(0, 0, -1);\n          uvs[j + 0] = getUv(faceDirVector, normal, 'x', 'y', radius, width);\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'y', 'x', radius, height);\n          break;\n      }\n    }\n    return _this;\n  }\n  return _createClass(RoundedBoxGeometry);\n}(BoxGeometry);\nexport { RoundedBoxGeometry };","map":{"version":3,"names":["Vector3","BoxGeometry","tempNormal","getUv","faceDirVector","normal","uvAxis","projectionAxis","radius","sideLength","totArcLength","Math","PI","centerLength","max","halfArc","copy","normalize","arcUvRatio","arcAngleRatio","angleTo","sign","lenUv","RoundedBoxGeometry","_BoxGeometry","_inherits","_super","_createSuper","_this","width","arguments","length","undefined","height","depth","segments","_classCallCheck","min","call","_possibleConstructorReturn","geometry2","toNonIndexed","index","attributes","position","uv","box","divideScalar","subScalar","positions","array","normals","uvs","faceTris","halfSegmentSize","i","j","fromArray","x","y","z","side","floor","set","_createClass"],"sources":["/home/samuel/experiment/3d/farm/frontend/node_modules/three-stdlib/geometries/RoundedBoxGeometry.js"],"sourcesContent":["import { Vector3, BoxGeometry } from 'three';\n\nconst tempNormal = new Vector3();\n\nfunction getUv(faceDirVector, normal, uvAxis, projectionAxis, radius, sideLength) {\n  const totArcLength = 2 * Math.PI * radius / 4; // length of the planes between the arcs on each axis\n\n  const centerLength = Math.max(sideLength - 2 * radius, 0);\n  const halfArc = Math.PI / 4; // Get the vector projected onto the Y plane\n\n  tempNormal.copy(normal);\n  tempNormal[projectionAxis] = 0;\n  tempNormal.normalize(); // total amount of UV space alloted to a single arc\n\n  const arcUvRatio = 0.5 * totArcLength / (totArcLength + centerLength); // the distance along one arc the point is at\n\n  const arcAngleRatio = 1.0 - tempNormal.angleTo(faceDirVector) / halfArc;\n\n  if (Math.sign(tempNormal[uvAxis]) === 1) {\n    return arcAngleRatio * arcUvRatio;\n  } else {\n    // total amount of UV space alloted to the plane between the arcs\n    const lenUv = centerLength / (totArcLength + centerLength);\n    return lenUv + arcUvRatio + arcUvRatio * (1.0 - arcAngleRatio);\n  }\n}\n\nclass RoundedBoxGeometry extends BoxGeometry {\n  constructor(width = 1, height = 1, depth = 1, segments = 2, radius = 0.1) {\n    // ensure segments is odd so we have a plane connecting the rounded corners\n    segments = segments * 2 + 1; // ensure radius isn't bigger than shortest side\n\n    radius = Math.min(width / 2, height / 2, depth / 2, radius);\n    super(1, 1, 1, segments, segments, segments); // if we just have one segment we're the same as a regular box\n\n    if (segments === 1) return;\n    const geometry2 = this.toNonIndexed();\n    this.index = null;\n    this.attributes.position = geometry2.attributes.position;\n    this.attributes.normal = geometry2.attributes.normal;\n    this.attributes.uv = geometry2.attributes.uv; //\n\n    const position = new Vector3();\n    const normal = new Vector3();\n    const box = new Vector3(width, height, depth).divideScalar(2).subScalar(radius);\n    const positions = this.attributes.position.array;\n    const normals = this.attributes.normal.array;\n    const uvs = this.attributes.uv.array;\n    const faceTris = positions.length / 6;\n    const faceDirVector = new Vector3();\n    const halfSegmentSize = 0.5 / segments;\n\n    for (let i = 0, j = 0; i < positions.length; i += 3, j += 2) {\n      position.fromArray(positions, i);\n      normal.copy(position);\n      normal.x -= Math.sign(normal.x) * halfSegmentSize;\n      normal.y -= Math.sign(normal.y) * halfSegmentSize;\n      normal.z -= Math.sign(normal.z) * halfSegmentSize;\n      normal.normalize();\n      positions[i + 0] = box.x * Math.sign(position.x) + normal.x * radius;\n      positions[i + 1] = box.y * Math.sign(position.y) + normal.y * radius;\n      positions[i + 2] = box.z * Math.sign(position.z) + normal.z * radius;\n      normals[i + 0] = normal.x;\n      normals[i + 1] = normal.y;\n      normals[i + 2] = normal.z;\n      const side = Math.floor(i / faceTris);\n\n      switch (side) {\n        case 0:\n          // right\n          // generate UVs along Z then Y\n          faceDirVector.set(1, 0, 0);\n          uvs[j + 0] = getUv(faceDirVector, normal, 'z', 'y', radius, depth);\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'y', 'z', radius, height);\n          break;\n\n        case 1:\n          // left\n          // generate UVs along Z then Y\n          faceDirVector.set(-1, 0, 0);\n          uvs[j + 0] = 1.0 - getUv(faceDirVector, normal, 'z', 'y', radius, depth);\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'y', 'z', radius, height);\n          break;\n\n        case 2:\n          // top\n          // generate UVs along X then Z\n          faceDirVector.set(0, 1, 0);\n          uvs[j + 0] = 1.0 - getUv(faceDirVector, normal, 'x', 'z', radius, width);\n          uvs[j + 1] = getUv(faceDirVector, normal, 'z', 'x', radius, depth);\n          break;\n\n        case 3:\n          // bottom\n          // generate UVs along X then Z\n          faceDirVector.set(0, -1, 0);\n          uvs[j + 0] = 1.0 - getUv(faceDirVector, normal, 'x', 'z', radius, width);\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'z', 'x', radius, depth);\n          break;\n\n        case 4:\n          // front\n          // generate UVs along X then Y\n          faceDirVector.set(0, 0, 1);\n          uvs[j + 0] = 1.0 - getUv(faceDirVector, normal, 'x', 'y', radius, width);\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'y', 'x', radius, height);\n          break;\n\n        case 5:\n          // back\n          // generate UVs along X then Y\n          faceDirVector.set(0, 0, -1);\n          uvs[j + 0] = getUv(faceDirVector, normal, 'x', 'y', radius, width);\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'y', 'x', radius, height);\n          break;\n      }\n    }\n  }\n\n}\n\nexport { RoundedBoxGeometry };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}