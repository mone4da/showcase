{"ast":null,"code":"import _classCallCheck from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { Pass, FullScreenQuad } from './Pass.js';\nimport { Vector2, Color, WebGLRenderTarget, MeshDepthMaterial, DoubleSide, RGBADepthPacking, NoBlending, UniformsUtils, ShaderMaterial, Matrix4, Vector3, AdditiveBlending } from 'three';\nimport { CopyShader } from '../shaders/CopyShader.js';\nvar OutlinePass = /*#__PURE__*/function (_Pass) {\n  _inherits(OutlinePass, _Pass);\n  var _super = _createSuper(OutlinePass);\n  function OutlinePass(resolution, scene, camera, selectedObjects) {\n    var _this;\n    _classCallCheck(this, OutlinePass);\n    _this = _super.call(this);\n    _defineProperty(_assertThisInitialized(_this), \"renderScene\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"renderCamera\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"selectedObjects\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"visibleEdgeColor\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"hiddenEdgeColor\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"edgeGlow\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"usePatternTexture\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"edgeThickness\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"edgeStrength\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"downSampleRatio\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"pulsePeriod\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"resolution\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"renderTargetMaskBuffer\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"depthMaterial\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"prepareMaskMaterial\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"renderTargetDepthBuffer\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"renderTargetMaskDownSampleBuffer\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"renderTargetBlurBuffer1\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"renderTargetBlurBuffer2\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"edgeDetectionMaterial\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"renderTargetEdgeBuffer1\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"renderTargetEdgeBuffer2\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"separableBlurMaterial1\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"separableBlurMaterial2\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"overlayMaterial\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"materialCopy\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"oldClearAlpha\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"fsQuad\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"tempPulseColor1\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"tempPulseColor2\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"textureMatrix\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"patternTexture\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"_visibilityCache\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"_oldClearColor\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"copyUniforms\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"BlurDirectionX\", new Vector2(1.0, 0.0));\n    _defineProperty(_assertThisInitialized(_this), \"BlurDirectionY\", new Vector2(0.0, 1.0));\n    _this.renderScene = scene;\n    _this.renderCamera = camera;\n    _this.selectedObjects = selectedObjects !== undefined ? selectedObjects : [];\n    _this.visibleEdgeColor = new Color(1, 1, 1);\n    _this.hiddenEdgeColor = new Color(0.1, 0.04, 0.02);\n    _this.edgeGlow = 0.0;\n    _this.usePatternTexture = false;\n    _this.edgeThickness = 1.0;\n    _this.edgeStrength = 3.0;\n    _this.downSampleRatio = 2;\n    _this.pulsePeriod = 0;\n    _this._visibilityCache = new Map();\n    _this.resolution = resolution !== undefined ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256);\n    var resx = Math.round(_this.resolution.x / _this.downSampleRatio);\n    var resy = Math.round(_this.resolution.y / _this.downSampleRatio);\n    _this.renderTargetMaskBuffer = new WebGLRenderTarget(_this.resolution.x, _this.resolution.y);\n    _this.renderTargetMaskBuffer.texture.name = 'OutlinePass.mask';\n    _this.renderTargetMaskBuffer.texture.generateMipmaps = false;\n    _this.depthMaterial = new MeshDepthMaterial();\n    _this.depthMaterial.side = DoubleSide;\n    _this.depthMaterial.depthPacking = RGBADepthPacking;\n    _this.depthMaterial.blending = NoBlending;\n    _this.prepareMaskMaterial = _this.getPrepareMaskMaterial();\n    _this.prepareMaskMaterial.side = DoubleSide;\n    _this.prepareMaskMaterial.fragmentShader = replaceDepthToViewZ(_this.prepareMaskMaterial.fragmentShader, _this.renderCamera);\n    _this.renderTargetDepthBuffer = new WebGLRenderTarget(_this.resolution.x, _this.resolution.y);\n    _this.renderTargetDepthBuffer.texture.name = 'OutlinePass.depth';\n    _this.renderTargetDepthBuffer.texture.generateMipmaps = false;\n    _this.renderTargetMaskDownSampleBuffer = new WebGLRenderTarget(resx, resy);\n    _this.renderTargetMaskDownSampleBuffer.texture.name = 'OutlinePass.depthDownSample';\n    _this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = false;\n    _this.renderTargetBlurBuffer1 = new WebGLRenderTarget(resx, resy);\n    _this.renderTargetBlurBuffer1.texture.name = 'OutlinePass.blur1';\n    _this.renderTargetBlurBuffer1.texture.generateMipmaps = false;\n    _this.renderTargetBlurBuffer2 = new WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2));\n    _this.renderTargetBlurBuffer2.texture.name = 'OutlinePass.blur2';\n    _this.renderTargetBlurBuffer2.texture.generateMipmaps = false;\n    _this.edgeDetectionMaterial = _this.getEdgeDetectionMaterial();\n    _this.renderTargetEdgeBuffer1 = new WebGLRenderTarget(resx, resy);\n    _this.renderTargetEdgeBuffer1.texture.name = 'OutlinePass.edge1';\n    _this.renderTargetEdgeBuffer1.texture.generateMipmaps = false;\n    _this.renderTargetEdgeBuffer2 = new WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2));\n    _this.renderTargetEdgeBuffer2.texture.name = 'OutlinePass.edge2';\n    _this.renderTargetEdgeBuffer2.texture.generateMipmaps = false;\n    var MAX_EDGE_THICKNESS = 4;\n    var MAX_EDGE_GLOW = 4;\n    _this.separableBlurMaterial1 = _this.getSeperableBlurMaterial(MAX_EDGE_THICKNESS);\n    _this.separableBlurMaterial1.uniforms['texSize'].value.set(resx, resy);\n    _this.separableBlurMaterial1.uniforms['kernelRadius'].value = 1;\n    _this.separableBlurMaterial2 = _this.getSeperableBlurMaterial(MAX_EDGE_GLOW);\n    _this.separableBlurMaterial2.uniforms['texSize'].value.set(Math.round(resx / 2), Math.round(resy / 2));\n    _this.separableBlurMaterial2.uniforms['kernelRadius'].value = MAX_EDGE_GLOW; // Overlay material\n\n    _this.overlayMaterial = _this.getOverlayMaterial(); // copy material\n\n    if (CopyShader === undefined) console.error('THREE.OutlinePass relies on CopyShader');\n    var copyShader = CopyShader;\n    _this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\n    _this.copyUniforms['opacity'].value = 1.0;\n    _this.materialCopy = new ShaderMaterial({\n      uniforms: _this.copyUniforms,\n      vertexShader: copyShader.vertexShader,\n      fragmentShader: copyShader.fragmentShader,\n      blending: NoBlending,\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    _this.enabled = true;\n    _this.needsSwap = false;\n    _this._oldClearColor = new Color();\n    _this.oldClearAlpha = 1;\n    _this.fsQuad = new FullScreenQuad(_this.materialCopy);\n    _this.tempPulseColor1 = new Color();\n    _this.tempPulseColor2 = new Color();\n    _this.textureMatrix = new Matrix4();\n    function replaceDepthToViewZ(string, camera) {\n      var type = camera.isPerspectiveCamera ? 'perspective' : 'orthographic';\n      return string.replace(/DEPTH_TO_VIEW_Z/g, type + 'DepthToViewZ');\n    }\n    return _this;\n  }\n  _createClass(OutlinePass, [{\n    key: \"dispose\",\n    value: function dispose() {\n      this.renderTargetMaskBuffer.dispose();\n      this.renderTargetDepthBuffer.dispose();\n      this.renderTargetMaskDownSampleBuffer.dispose();\n      this.renderTargetBlurBuffer1.dispose();\n      this.renderTargetBlurBuffer2.dispose();\n      this.renderTargetEdgeBuffer1.dispose();\n      this.renderTargetEdgeBuffer2.dispose();\n    }\n  }, {\n    key: \"setSize\",\n    value: function setSize(width, height) {\n      this.renderTargetMaskBuffer.setSize(width, height);\n      this.renderTargetDepthBuffer.setSize(width, height);\n      var resx = Math.round(width / this.downSampleRatio);\n      var resy = Math.round(height / this.downSampleRatio);\n      this.renderTargetMaskDownSampleBuffer.setSize(resx, resy);\n      this.renderTargetBlurBuffer1.setSize(resx, resy);\n      this.renderTargetEdgeBuffer1.setSize(resx, resy);\n      this.separableBlurMaterial1.uniforms['texSize'].value.set(resx, resy);\n      resx = Math.round(resx / 2);\n      resy = Math.round(resy / 2);\n      this.renderTargetBlurBuffer2.setSize(resx, resy);\n      this.renderTargetEdgeBuffer2.setSize(resx, resy);\n      this.separableBlurMaterial2.uniforms['texSize'].value.set(resx, resy);\n    }\n  }, {\n    key: \"changeVisibilityOfSelectedObjects\",\n    value: function changeVisibilityOfSelectedObjects(bVisible) {\n      var cache = this._visibilityCache;\n      function gatherSelectedMeshesCallBack(object) {\n        if (object.isMesh) {\n          if (bVisible === true) {\n            object.visible = cache.get(object);\n          } else {\n            cache.set(object, object.visible);\n            object.visible = bVisible;\n          }\n        }\n      }\n      for (var i = 0; i < this.selectedObjects.length; i++) {\n        var selectedObject = this.selectedObjects[i];\n        selectedObject.traverse(gatherSelectedMeshesCallBack);\n      }\n    }\n  }, {\n    key: \"changeVisibilityOfNonSelectedObjects\",\n    value: function changeVisibilityOfNonSelectedObjects(bVisible) {\n      var cache = this._visibilityCache;\n      var selectedMeshes = [];\n      function gatherSelectedMeshesCallBack(object) {\n        if (object.isMesh) selectedMeshes.push(object);\n      }\n      for (var i = 0; i < this.selectedObjects.length; i++) {\n        var selectedObject = this.selectedObjects[i];\n        selectedObject.traverse(gatherSelectedMeshesCallBack);\n      }\n      function VisibilityChangeCallBack(object) {\n        if (object.isMesh || object.isSprite) {\n          // only meshes and sprites are supported by OutlinePass\n          var bFound = false;\n          for (var _i = 0; _i < selectedMeshes.length; _i++) {\n            var selectedObjectId = selectedMeshes[_i].id;\n            if (selectedObjectId === object.id) {\n              bFound = true;\n              break;\n            }\n          }\n          if (bFound === false) {\n            var visibility = object.visible;\n            if (bVisible === false || cache.get(object) === true) {\n              object.visible = bVisible;\n            }\n            cache.set(object, visibility);\n          }\n        } else if (object.isPoints || object.isLine) {\n          // the visibilty of points and lines is always set to false in order to\n          // not affect the outline computation\n          if (bVisible === true) {\n            object.visible = cache.get(object); // restore\n          } else {\n            cache.set(object, object.visible);\n            object.visible = bVisible;\n          }\n        }\n      }\n      this.renderScene.traverse(VisibilityChangeCallBack);\n    }\n  }, {\n    key: \"updateTextureMatrix\",\n    value: function updateTextureMatrix() {\n      this.textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n      this.textureMatrix.multiply(this.renderCamera.projectionMatrix);\n      this.textureMatrix.multiply(this.renderCamera.matrixWorldInverse);\n    }\n  }, {\n    key: \"render\",\n    value: function render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n      if (this.selectedObjects.length > 0) {\n        renderer.getClearColor(this._oldClearColor);\n        this.oldClearAlpha = renderer.getClearAlpha();\n        var oldAutoClear = renderer.autoClear;\n        renderer.autoClear = false;\n        if (maskActive) renderer.state.buffers.stencil.setTest(false);\n        renderer.setClearColor(0xffffff, 1); // Make selected objects invisible\n\n        this.changeVisibilityOfSelectedObjects(false);\n        var currentBackground = this.renderScene.background;\n        this.renderScene.background = null; // 1. Draw Non Selected objects in the depth buffer\n\n        this.renderScene.overrideMaterial = this.depthMaterial;\n        renderer.setRenderTarget(this.renderTargetDepthBuffer);\n        renderer.clear();\n        renderer.render(this.renderScene, this.renderCamera); // Make selected objects visible\n\n        this.changeVisibilityOfSelectedObjects(true);\n        this._visibilityCache.clear(); // Update Texture Matrix for Depth compare\n\n        this.updateTextureMatrix(); // Make non selected objects invisible, and draw only the selected objects, by comparing the depth buffer of non selected objects\n\n        this.changeVisibilityOfNonSelectedObjects(false);\n        this.renderScene.overrideMaterial = this.prepareMaskMaterial;\n        this.prepareMaskMaterial.uniforms['cameraNearFar'].value.set(this.renderCamera.near, this.renderCamera.far);\n        this.prepareMaskMaterial.uniforms['depthTexture'].value = this.renderTargetDepthBuffer.texture;\n        this.prepareMaskMaterial.uniforms['textureMatrix'].value = this.textureMatrix;\n        renderer.setRenderTarget(this.renderTargetMaskBuffer);\n        renderer.clear();\n        renderer.render(this.renderScene, this.renderCamera);\n        this.renderScene.overrideMaterial = null;\n        this.changeVisibilityOfNonSelectedObjects(true);\n        this._visibilityCache.clear();\n        this.renderScene.background = currentBackground; // 2. Downsample to Half resolution\n\n        this.fsQuad.material = this.materialCopy;\n        this.copyUniforms['tDiffuse'].value = this.renderTargetMaskBuffer.texture;\n        renderer.setRenderTarget(this.renderTargetMaskDownSampleBuffer);\n        renderer.clear();\n        this.fsQuad.render(renderer);\n        this.tempPulseColor1.copy(this.visibleEdgeColor);\n        this.tempPulseColor2.copy(this.hiddenEdgeColor);\n        if (this.pulsePeriod > 0) {\n          var scalar = (1 + 0.25) / 2 + Math.cos(performance.now() * 0.01 / this.pulsePeriod) * (1.0 - 0.25) / 2;\n          this.tempPulseColor1.multiplyScalar(scalar);\n          this.tempPulseColor2.multiplyScalar(scalar);\n        } // 3. Apply Edge Detection Pass\n\n        this.fsQuad.material = this.edgeDetectionMaterial;\n        this.edgeDetectionMaterial.uniforms['maskTexture'].value = this.renderTargetMaskDownSampleBuffer.texture;\n        this.edgeDetectionMaterial.uniforms['texSize'].value.set(this.renderTargetMaskDownSampleBuffer.width, this.renderTargetMaskDownSampleBuffer.height);\n        this.edgeDetectionMaterial.uniforms['visibleEdgeColor'].value = this.tempPulseColor1;\n        this.edgeDetectionMaterial.uniforms['hiddenEdgeColor'].value = this.tempPulseColor2;\n        renderer.setRenderTarget(this.renderTargetEdgeBuffer1);\n        renderer.clear();\n        this.fsQuad.render(renderer); // 4. Apply Blur on Half res\n\n        this.fsQuad.material = this.separableBlurMaterial1;\n        this.separableBlurMaterial1.uniforms['colorTexture'].value = this.renderTargetEdgeBuffer1.texture;\n        this.separableBlurMaterial1.uniforms['direction'].value = this.BlurDirectionX;\n        this.separableBlurMaterial1.uniforms['kernelRadius'].value = this.edgeThickness;\n        renderer.setRenderTarget(this.renderTargetBlurBuffer1);\n        renderer.clear();\n        this.fsQuad.render(renderer);\n        this.separableBlurMaterial1.uniforms['colorTexture'].value = this.renderTargetBlurBuffer1.texture;\n        this.separableBlurMaterial1.uniforms['direction'].value = this.BlurDirectionY;\n        renderer.setRenderTarget(this.renderTargetEdgeBuffer1);\n        renderer.clear();\n        this.fsQuad.render(renderer); // Apply Blur on quarter res\n\n        this.fsQuad.material = this.separableBlurMaterial2;\n        this.separableBlurMaterial2.uniforms['colorTexture'].value = this.renderTargetEdgeBuffer1.texture;\n        this.separableBlurMaterial2.uniforms['direction'].value = this.BlurDirectionX;\n        renderer.setRenderTarget(this.renderTargetBlurBuffer2);\n        renderer.clear();\n        this.fsQuad.render(renderer);\n        this.separableBlurMaterial2.uniforms['colorTexture'].value = this.renderTargetBlurBuffer2.texture;\n        this.separableBlurMaterial2.uniforms['direction'].value = this.BlurDirectionY;\n        renderer.setRenderTarget(this.renderTargetEdgeBuffer2);\n        renderer.clear();\n        this.fsQuad.render(renderer); // Blend it additively over the input texture\n\n        this.fsQuad.material = this.overlayMaterial;\n        this.overlayMaterial.uniforms['maskTexture'].value = this.renderTargetMaskBuffer.texture;\n        this.overlayMaterial.uniforms['edgeTexture1'].value = this.renderTargetEdgeBuffer1.texture;\n        this.overlayMaterial.uniforms['edgeTexture2'].value = this.renderTargetEdgeBuffer2.texture;\n        this.overlayMaterial.uniforms['patternTexture'].value = this.patternTexture;\n        this.overlayMaterial.uniforms['edgeStrength'].value = this.edgeStrength;\n        this.overlayMaterial.uniforms['edgeGlow'].value = this.edgeGlow;\n        this.overlayMaterial.uniforms['usePatternTexture'].value = this.usePatternTexture;\n        if (maskActive) renderer.state.buffers.stencil.setTest(true);\n        renderer.setRenderTarget(readBuffer);\n        this.fsQuad.render(renderer);\n        renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);\n        renderer.autoClear = oldAutoClear;\n      }\n      if (this.renderToScreen) {\n        this.fsQuad.material = this.materialCopy;\n        this.copyUniforms['tDiffuse'].value = readBuffer.texture;\n        renderer.setRenderTarget(null);\n        this.fsQuad.render(renderer);\n      }\n    }\n  }, {\n    key: \"getPrepareMaskMaterial\",\n    value: function getPrepareMaskMaterial() {\n      return new ShaderMaterial({\n        uniforms: {\n          depthTexture: {\n            value: null\n          },\n          cameraNearFar: {\n            value: new Vector2(0.5, 0.5)\n          },\n          textureMatrix: {\n            value: null\n          }\n        },\n        vertexShader: \"#include <morphtarget_pars_vertex>\\n\\t\\t\\t\\t#include <skinning_pars_vertex>\\n\\t\\t\\t\\tvarying vec4 projTexCoord;\\n\\t\\t\\t\\tvarying vec4 vPosition;\\n\\t\\t\\t\\tuniform mat4 textureMatrix;\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\t#include <skinbase_vertex>\\n\\t\\t\\t\\t\\t#include <begin_vertex>\\n\\t\\t\\t\\t\\t#include <morphtarget_vertex>\\n\\t\\t\\t\\t\\t#include <skinning_vertex>\\n\\t\\t\\t\\t\\t#include <project_vertex>\\n\\t\\t\\t\\t\\tvPosition = mvPosition;\\n\\t\\t\\t\\t\\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\\n\\t\\t\\t\\t\\tprojTexCoord = textureMatrix * worldPosition;\\n\\t\\t\\t\\t}\",\n        fragmentShader: \"#include <packing>\\n\\t\\t\\t\\tvarying vec4 vPosition;\\n\\t\\t\\t\\tvarying vec4 projTexCoord;\\n\\t\\t\\t\\tuniform sampler2D depthTexture;\\n\\t\\t\\t\\tuniform vec2 cameraNearFar;\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tfloat depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));\\n\\t\\t\\t\\t\\tfloat viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );\\n\\t\\t\\t\\t\\tfloat depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;\\n\\t\\t\\t\\t\\tgl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);\\n\\t\\t\\t\\t}\"\n      });\n    }\n  }, {\n    key: \"getEdgeDetectionMaterial\",\n    value: function getEdgeDetectionMaterial() {\n      return new ShaderMaterial({\n        uniforms: {\n          maskTexture: {\n            value: null\n          },\n          texSize: {\n            value: new Vector2(0.5, 0.5)\n          },\n          visibleEdgeColor: {\n            value: new Vector3(1.0, 1.0, 1.0)\n          },\n          hiddenEdgeColor: {\n            value: new Vector3(1.0, 1.0, 1.0)\n          }\n        },\n        vertexShader: \"varying vec2 vUv;\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvUv = uv;\\n\\t\\t\\t\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\t\\t\\t\\t}\",\n        fragmentShader: \"varying vec2 vUv;\\n\\t\\t\\t\\tuniform sampler2D maskTexture;\\n\\t\\t\\t\\tuniform vec2 texSize;\\n\\t\\t\\t\\tuniform vec3 visibleEdgeColor;\\n\\t\\t\\t\\tuniform vec3 hiddenEdgeColor;\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvec2 invSize = 1.0 / texSize;\\n\\t\\t\\t\\t\\tvec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\\n\\t\\t\\t\\t\\tvec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);\\n\\t\\t\\t\\t\\tvec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);\\n\\t\\t\\t\\t\\tvec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);\\n\\t\\t\\t\\t\\tvec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);\\n\\t\\t\\t\\t\\tfloat diff1 = (c1.r - c2.r)*0.5;\\n\\t\\t\\t\\t\\tfloat diff2 = (c3.r - c4.r)*0.5;\\n\\t\\t\\t\\t\\tfloat d = length( vec2(diff1, diff2) );\\n\\t\\t\\t\\t\\tfloat a1 = min(c1.g, c2.g);\\n\\t\\t\\t\\t\\tfloat a2 = min(c3.g, c4.g);\\n\\t\\t\\t\\t\\tfloat visibilityFactor = min(a1, a2);\\n\\t\\t\\t\\t\\tvec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;\\n\\t\\t\\t\\t\\tgl_FragColor = vec4(edgeColor, 1.0) * vec4(d);\\n\\t\\t\\t\\t}\"\n      });\n    }\n  }, {\n    key: \"getSeperableBlurMaterial\",\n    value: function getSeperableBlurMaterial(maxRadius) {\n      return new ShaderMaterial({\n        defines: {\n          MAX_RADIUS: maxRadius\n        },\n        uniforms: {\n          colorTexture: {\n            value: null\n          },\n          texSize: {\n            value: new Vector2(0.5, 0.5)\n          },\n          direction: {\n            value: new Vector2(0.5, 0.5)\n          },\n          kernelRadius: {\n            value: 1.0\n          }\n        },\n        vertexShader: \"varying vec2 vUv;\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvUv = uv;\\n\\t\\t\\t\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\t\\t\\t\\t}\",\n        fragmentShader: \"#include <common>\\n\\t\\t\\t\\tvarying vec2 vUv;\\n\\t\\t\\t\\tuniform sampler2D colorTexture;\\n\\t\\t\\t\\tuniform vec2 texSize;\\n\\t\\t\\t\\tuniform vec2 direction;\\n\\t\\t\\t\\tuniform float kernelRadius;\\n\\t\\t\\t\\tfloat gaussianPdf(in float x, in float sigma) {\\n\\t\\t\\t\\t\\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvec2 invSize = 1.0 / texSize;\\n\\t\\t\\t\\t\\tfloat weightSum = gaussianPdf(0.0, kernelRadius);\\n\\t\\t\\t\\t\\tvec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;\\n\\t\\t\\t\\t\\tvec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\\n\\t\\t\\t\\t\\tvec2 uvOffset = delta;\\n\\t\\t\\t\\t\\tfor( int i = 1; i <= MAX_RADIUS; i ++ ) {\\n\\t\\t\\t\\t\\t\\tfloat w = gaussianPdf(uvOffset.x, kernelRadius);\\n\\t\\t\\t\\t\\t\\tvec4 sample1 = texture2D( colorTexture, vUv + uvOffset);\\n\\t\\t\\t\\t\\t\\tvec4 sample2 = texture2D( colorTexture, vUv - uvOffset);\\n\\t\\t\\t\\t\\t\\tdiffuseSum += ((sample1 + sample2) * w);\\n\\t\\t\\t\\t\\t\\tweightSum += (2.0 * w);\\n\\t\\t\\t\\t\\t\\tuvOffset += delta;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tgl_FragColor = diffuseSum/weightSum;\\n\\t\\t\\t\\t}\"\n      });\n    }\n  }, {\n    key: \"getOverlayMaterial\",\n    value: function getOverlayMaterial() {\n      return new ShaderMaterial({\n        uniforms: {\n          maskTexture: {\n            value: null\n          },\n          edgeTexture1: {\n            value: null\n          },\n          edgeTexture2: {\n            value: null\n          },\n          patternTexture: {\n            value: null\n          },\n          edgeStrength: {\n            value: 1.0\n          },\n          edgeGlow: {\n            value: 1.0\n          },\n          usePatternTexture: {\n            value: 0.0\n          }\n        },\n        vertexShader: \"varying vec2 vUv;\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvUv = uv;\\n\\t\\t\\t\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\t\\t\\t\\t}\",\n        fragmentShader: \"varying vec2 vUv;\\n\\t\\t\\t\\tuniform sampler2D maskTexture;\\n\\t\\t\\t\\tuniform sampler2D edgeTexture1;\\n\\t\\t\\t\\tuniform sampler2D edgeTexture2;\\n\\t\\t\\t\\tuniform sampler2D patternTexture;\\n\\t\\t\\t\\tuniform float edgeStrength;\\n\\t\\t\\t\\tuniform float edgeGlow;\\n\\t\\t\\t\\tuniform bool usePatternTexture;\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvec4 edgeValue1 = texture2D(edgeTexture1, vUv);\\n\\t\\t\\t\\t\\tvec4 edgeValue2 = texture2D(edgeTexture2, vUv);\\n\\t\\t\\t\\t\\tvec4 maskColor = texture2D(maskTexture, vUv);\\n\\t\\t\\t\\t\\tvec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\\n\\t\\t\\t\\t\\tfloat visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\\n\\t\\t\\t\\t\\tvec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\\n\\t\\t\\t\\t\\tvec4 finalColor = edgeStrength * maskColor.r * edgeValue;\\n\\t\\t\\t\\t\\tif(usePatternTexture)\\n\\t\\t\\t\\t\\t\\tfinalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\\n\\t\\t\\t\\t\\tgl_FragColor = finalColor;\\n\\t\\t\\t\\t}\",\n        blending: AdditiveBlending,\n        depthTest: false,\n        depthWrite: false,\n        transparent: true\n      });\n    }\n  }]);\n  return OutlinePass;\n}(Pass);\nexport { OutlinePass };","map":{"version":3,"names":["_defineProperty","Pass","FullScreenQuad","Vector2","Color","WebGLRenderTarget","MeshDepthMaterial","DoubleSide","RGBADepthPacking","NoBlending","UniformsUtils","ShaderMaterial","Matrix4","Vector3","AdditiveBlending","CopyShader","OutlinePass","_Pass","_inherits","_super","_createSuper","resolution","scene","camera","selectedObjects","_this","_classCallCheck","call","_assertThisInitialized","renderScene","renderCamera","undefined","visibleEdgeColor","hiddenEdgeColor","edgeGlow","usePatternTexture","edgeThickness","edgeStrength","downSampleRatio","pulsePeriod","_visibilityCache","Map","x","y","resx","Math","round","resy","renderTargetMaskBuffer","texture","name","generateMipmaps","depthMaterial","side","depthPacking","blending","prepareMaskMaterial","getPrepareMaskMaterial","fragmentShader","replaceDepthToViewZ","renderTargetDepthBuffer","renderTargetMaskDownSampleBuffer","renderTargetBlurBuffer1","renderTargetBlurBuffer2","edgeDetectionMaterial","getEdgeDetectionMaterial","renderTargetEdgeBuffer1","renderTargetEdgeBuffer2","MAX_EDGE_THICKNESS","MAX_EDGE_GLOW","separableBlurMaterial1","getSeperableBlurMaterial","uniforms","value","set","separableBlurMaterial2","overlayMaterial","getOverlayMaterial","console","error","copyShader","copyUniforms","clone","materialCopy","vertexShader","depthTest","depthWrite","transparent","enabled","needsSwap","_oldClearColor","oldClearAlpha","fsQuad","tempPulseColor1","tempPulseColor2","textureMatrix","string","type","isPerspectiveCamera","replace","_createClass","key","dispose","setSize","width","height","changeVisibilityOfSelectedObjects","bVisible","cache","gatherSelectedMeshesCallBack","object","isMesh","visible","get","i","length","selectedObject","traverse","changeVisibilityOfNonSelectedObjects","selectedMeshes","push","VisibilityChangeCallBack","isSprite","bFound","selectedObjectId","id","visibility","isPoints","isLine","updateTextureMatrix","multiply","projectionMatrix","matrixWorldInverse","render","renderer","writeBuffer","readBuffer","deltaTime","maskActive","getClearColor","getClearAlpha","oldAutoClear","autoClear","state","buffers","stencil","setTest","setClearColor","currentBackground","background","overrideMaterial","setRenderTarget","clear","near","far","material","copy","scalar","cos","performance","now","multiplyScalar","BlurDirectionX","BlurDirectionY","patternTexture","renderToScreen","depthTexture","cameraNearFar","maskTexture","texSize","maxRadius","defines","MAX_RADIUS","colorTexture","direction","kernelRadius","edgeTexture1","edgeTexture2"],"sources":["/home/samuel/experiment/3d/farm/frontend/node_modules/three-stdlib/postprocessing/OutlinePass.js"],"sourcesContent":["import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { Pass, FullScreenQuad } from './Pass.js';\nimport { Vector2, Color, WebGLRenderTarget, MeshDepthMaterial, DoubleSide, RGBADepthPacking, NoBlending, UniformsUtils, ShaderMaterial, Matrix4, Vector3, AdditiveBlending } from 'three';\nimport { CopyShader } from '../shaders/CopyShader.js';\n\nclass OutlinePass extends Pass {\n  constructor(resolution, scene, camera, selectedObjects) {\n    super();\n\n    _defineProperty(this, \"renderScene\", void 0);\n\n    _defineProperty(this, \"renderCamera\", void 0);\n\n    _defineProperty(this, \"selectedObjects\", void 0);\n\n    _defineProperty(this, \"visibleEdgeColor\", void 0);\n\n    _defineProperty(this, \"hiddenEdgeColor\", void 0);\n\n    _defineProperty(this, \"edgeGlow\", void 0);\n\n    _defineProperty(this, \"usePatternTexture\", void 0);\n\n    _defineProperty(this, \"edgeThickness\", void 0);\n\n    _defineProperty(this, \"edgeStrength\", void 0);\n\n    _defineProperty(this, \"downSampleRatio\", void 0);\n\n    _defineProperty(this, \"pulsePeriod\", void 0);\n\n    _defineProperty(this, \"resolution\", void 0);\n\n    _defineProperty(this, \"renderTargetMaskBuffer\", void 0);\n\n    _defineProperty(this, \"depthMaterial\", void 0);\n\n    _defineProperty(this, \"prepareMaskMaterial\", void 0);\n\n    _defineProperty(this, \"renderTargetDepthBuffer\", void 0);\n\n    _defineProperty(this, \"renderTargetMaskDownSampleBuffer\", void 0);\n\n    _defineProperty(this, \"renderTargetBlurBuffer1\", void 0);\n\n    _defineProperty(this, \"renderTargetBlurBuffer2\", void 0);\n\n    _defineProperty(this, \"edgeDetectionMaterial\", void 0);\n\n    _defineProperty(this, \"renderTargetEdgeBuffer1\", void 0);\n\n    _defineProperty(this, \"renderTargetEdgeBuffer2\", void 0);\n\n    _defineProperty(this, \"separableBlurMaterial1\", void 0);\n\n    _defineProperty(this, \"separableBlurMaterial2\", void 0);\n\n    _defineProperty(this, \"overlayMaterial\", void 0);\n\n    _defineProperty(this, \"materialCopy\", void 0);\n\n    _defineProperty(this, \"oldClearAlpha\", void 0);\n\n    _defineProperty(this, \"fsQuad\", void 0);\n\n    _defineProperty(this, \"tempPulseColor1\", void 0);\n\n    _defineProperty(this, \"tempPulseColor2\", void 0);\n\n    _defineProperty(this, \"textureMatrix\", void 0);\n\n    _defineProperty(this, \"patternTexture\", void 0);\n\n    _defineProperty(this, \"_visibilityCache\", void 0);\n\n    _defineProperty(this, \"_oldClearColor\", void 0);\n\n    _defineProperty(this, \"copyUniforms\", void 0);\n\n    _defineProperty(this, \"BlurDirectionX\", new Vector2(1.0, 0.0));\n\n    _defineProperty(this, \"BlurDirectionY\", new Vector2(0.0, 1.0));\n\n    this.renderScene = scene;\n    this.renderCamera = camera;\n    this.selectedObjects = selectedObjects !== undefined ? selectedObjects : [];\n    this.visibleEdgeColor = new Color(1, 1, 1);\n    this.hiddenEdgeColor = new Color(0.1, 0.04, 0.02);\n    this.edgeGlow = 0.0;\n    this.usePatternTexture = false;\n    this.edgeThickness = 1.0;\n    this.edgeStrength = 3.0;\n    this.downSampleRatio = 2;\n    this.pulsePeriod = 0;\n    this._visibilityCache = new Map();\n    this.resolution = resolution !== undefined ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256);\n    const resx = Math.round(this.resolution.x / this.downSampleRatio);\n    const resy = Math.round(this.resolution.y / this.downSampleRatio);\n    this.renderTargetMaskBuffer = new WebGLRenderTarget(this.resolution.x, this.resolution.y);\n    this.renderTargetMaskBuffer.texture.name = 'OutlinePass.mask';\n    this.renderTargetMaskBuffer.texture.generateMipmaps = false;\n    this.depthMaterial = new MeshDepthMaterial();\n    this.depthMaterial.side = DoubleSide;\n    this.depthMaterial.depthPacking = RGBADepthPacking;\n    this.depthMaterial.blending = NoBlending;\n    this.prepareMaskMaterial = this.getPrepareMaskMaterial();\n    this.prepareMaskMaterial.side = DoubleSide;\n    this.prepareMaskMaterial.fragmentShader = replaceDepthToViewZ(this.prepareMaskMaterial.fragmentShader, this.renderCamera);\n    this.renderTargetDepthBuffer = new WebGLRenderTarget(this.resolution.x, this.resolution.y);\n    this.renderTargetDepthBuffer.texture.name = 'OutlinePass.depth';\n    this.renderTargetDepthBuffer.texture.generateMipmaps = false;\n    this.renderTargetMaskDownSampleBuffer = new WebGLRenderTarget(resx, resy);\n    this.renderTargetMaskDownSampleBuffer.texture.name = 'OutlinePass.depthDownSample';\n    this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = false;\n    this.renderTargetBlurBuffer1 = new WebGLRenderTarget(resx, resy);\n    this.renderTargetBlurBuffer1.texture.name = 'OutlinePass.blur1';\n    this.renderTargetBlurBuffer1.texture.generateMipmaps = false;\n    this.renderTargetBlurBuffer2 = new WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2));\n    this.renderTargetBlurBuffer2.texture.name = 'OutlinePass.blur2';\n    this.renderTargetBlurBuffer2.texture.generateMipmaps = false;\n    this.edgeDetectionMaterial = this.getEdgeDetectionMaterial();\n    this.renderTargetEdgeBuffer1 = new WebGLRenderTarget(resx, resy);\n    this.renderTargetEdgeBuffer1.texture.name = 'OutlinePass.edge1';\n    this.renderTargetEdgeBuffer1.texture.generateMipmaps = false;\n    this.renderTargetEdgeBuffer2 = new WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2));\n    this.renderTargetEdgeBuffer2.texture.name = 'OutlinePass.edge2';\n    this.renderTargetEdgeBuffer2.texture.generateMipmaps = false;\n    const MAX_EDGE_THICKNESS = 4;\n    const MAX_EDGE_GLOW = 4;\n    this.separableBlurMaterial1 = this.getSeperableBlurMaterial(MAX_EDGE_THICKNESS);\n    this.separableBlurMaterial1.uniforms['texSize'].value.set(resx, resy);\n    this.separableBlurMaterial1.uniforms['kernelRadius'].value = 1;\n    this.separableBlurMaterial2 = this.getSeperableBlurMaterial(MAX_EDGE_GLOW);\n    this.separableBlurMaterial2.uniforms['texSize'].value.set(Math.round(resx / 2), Math.round(resy / 2));\n    this.separableBlurMaterial2.uniforms['kernelRadius'].value = MAX_EDGE_GLOW; // Overlay material\n\n    this.overlayMaterial = this.getOverlayMaterial(); // copy material\n\n    if (CopyShader === undefined) console.error('THREE.OutlinePass relies on CopyShader');\n    const copyShader = CopyShader;\n    this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\n    this.copyUniforms['opacity'].value = 1.0;\n    this.materialCopy = new ShaderMaterial({\n      uniforms: this.copyUniforms,\n      vertexShader: copyShader.vertexShader,\n      fragmentShader: copyShader.fragmentShader,\n      blending: NoBlending,\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    this.enabled = true;\n    this.needsSwap = false;\n    this._oldClearColor = new Color();\n    this.oldClearAlpha = 1;\n    this.fsQuad = new FullScreenQuad(this.materialCopy);\n    this.tempPulseColor1 = new Color();\n    this.tempPulseColor2 = new Color();\n    this.textureMatrix = new Matrix4();\n\n    function replaceDepthToViewZ(string, camera) {\n      const type = camera.isPerspectiveCamera ? 'perspective' : 'orthographic';\n      return string.replace(/DEPTH_TO_VIEW_Z/g, type + 'DepthToViewZ');\n    }\n  }\n\n  dispose() {\n    this.renderTargetMaskBuffer.dispose();\n    this.renderTargetDepthBuffer.dispose();\n    this.renderTargetMaskDownSampleBuffer.dispose();\n    this.renderTargetBlurBuffer1.dispose();\n    this.renderTargetBlurBuffer2.dispose();\n    this.renderTargetEdgeBuffer1.dispose();\n    this.renderTargetEdgeBuffer2.dispose();\n  }\n\n  setSize(width, height) {\n    this.renderTargetMaskBuffer.setSize(width, height);\n    this.renderTargetDepthBuffer.setSize(width, height);\n    let resx = Math.round(width / this.downSampleRatio);\n    let resy = Math.round(height / this.downSampleRatio);\n    this.renderTargetMaskDownSampleBuffer.setSize(resx, resy);\n    this.renderTargetBlurBuffer1.setSize(resx, resy);\n    this.renderTargetEdgeBuffer1.setSize(resx, resy);\n    this.separableBlurMaterial1.uniforms['texSize'].value.set(resx, resy);\n    resx = Math.round(resx / 2);\n    resy = Math.round(resy / 2);\n    this.renderTargetBlurBuffer2.setSize(resx, resy);\n    this.renderTargetEdgeBuffer2.setSize(resx, resy);\n    this.separableBlurMaterial2.uniforms['texSize'].value.set(resx, resy);\n  }\n\n  changeVisibilityOfSelectedObjects(bVisible) {\n    const cache = this._visibilityCache;\n\n    function gatherSelectedMeshesCallBack(object) {\n      if (object.isMesh) {\n        if (bVisible === true) {\n          object.visible = cache.get(object);\n        } else {\n          cache.set(object, object.visible);\n          object.visible = bVisible;\n        }\n      }\n    }\n\n    for (let i = 0; i < this.selectedObjects.length; i++) {\n      const selectedObject = this.selectedObjects[i];\n      selectedObject.traverse(gatherSelectedMeshesCallBack);\n    }\n  }\n\n  changeVisibilityOfNonSelectedObjects(bVisible) {\n    const cache = this._visibilityCache;\n    const selectedMeshes = [];\n\n    function gatherSelectedMeshesCallBack(object) {\n      if (object.isMesh) selectedMeshes.push(object);\n    }\n\n    for (let i = 0; i < this.selectedObjects.length; i++) {\n      const selectedObject = this.selectedObjects[i];\n      selectedObject.traverse(gatherSelectedMeshesCallBack);\n    }\n\n    function VisibilityChangeCallBack(object) {\n      if (object.isMesh || object.isSprite) {\n        // only meshes and sprites are supported by OutlinePass\n        let bFound = false;\n\n        for (let i = 0; i < selectedMeshes.length; i++) {\n          const selectedObjectId = selectedMeshes[i].id;\n\n          if (selectedObjectId === object.id) {\n            bFound = true;\n            break;\n          }\n        }\n\n        if (bFound === false) {\n          const visibility = object.visible;\n\n          if (bVisible === false || cache.get(object) === true) {\n            object.visible = bVisible;\n          }\n\n          cache.set(object, visibility);\n        }\n      } else if (object.isPoints || object.isLine) {\n        // the visibilty of points and lines is always set to false in order to\n        // not affect the outline computation\n        if (bVisible === true) {\n          object.visible = cache.get(object); // restore\n        } else {\n          cache.set(object, object.visible);\n          object.visible = bVisible;\n        }\n      }\n    }\n\n    this.renderScene.traverse(VisibilityChangeCallBack);\n  }\n\n  updateTextureMatrix() {\n    this.textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n    this.textureMatrix.multiply(this.renderCamera.projectionMatrix);\n    this.textureMatrix.multiply(this.renderCamera.matrixWorldInverse);\n  }\n\n  render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n    if (this.selectedObjects.length > 0) {\n      renderer.getClearColor(this._oldClearColor);\n      this.oldClearAlpha = renderer.getClearAlpha();\n      const oldAutoClear = renderer.autoClear;\n      renderer.autoClear = false;\n      if (maskActive) renderer.state.buffers.stencil.setTest(false);\n      renderer.setClearColor(0xffffff, 1); // Make selected objects invisible\n\n      this.changeVisibilityOfSelectedObjects(false);\n      const currentBackground = this.renderScene.background;\n      this.renderScene.background = null; // 1. Draw Non Selected objects in the depth buffer\n\n      this.renderScene.overrideMaterial = this.depthMaterial;\n      renderer.setRenderTarget(this.renderTargetDepthBuffer);\n      renderer.clear();\n      renderer.render(this.renderScene, this.renderCamera); // Make selected objects visible\n\n      this.changeVisibilityOfSelectedObjects(true);\n\n      this._visibilityCache.clear(); // Update Texture Matrix for Depth compare\n\n\n      this.updateTextureMatrix(); // Make non selected objects invisible, and draw only the selected objects, by comparing the depth buffer of non selected objects\n\n      this.changeVisibilityOfNonSelectedObjects(false);\n      this.renderScene.overrideMaterial = this.prepareMaskMaterial;\n      this.prepareMaskMaterial.uniforms['cameraNearFar'].value.set(this.renderCamera.near, this.renderCamera.far);\n      this.prepareMaskMaterial.uniforms['depthTexture'].value = this.renderTargetDepthBuffer.texture;\n      this.prepareMaskMaterial.uniforms['textureMatrix'].value = this.textureMatrix;\n      renderer.setRenderTarget(this.renderTargetMaskBuffer);\n      renderer.clear();\n      renderer.render(this.renderScene, this.renderCamera);\n      this.renderScene.overrideMaterial = null;\n      this.changeVisibilityOfNonSelectedObjects(true);\n\n      this._visibilityCache.clear();\n\n      this.renderScene.background = currentBackground; // 2. Downsample to Half resolution\n\n      this.fsQuad.material = this.materialCopy;\n      this.copyUniforms['tDiffuse'].value = this.renderTargetMaskBuffer.texture;\n      renderer.setRenderTarget(this.renderTargetMaskDownSampleBuffer);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.tempPulseColor1.copy(this.visibleEdgeColor);\n      this.tempPulseColor2.copy(this.hiddenEdgeColor);\n\n      if (this.pulsePeriod > 0) {\n        const scalar = (1 + 0.25) / 2 + Math.cos(performance.now() * 0.01 / this.pulsePeriod) * (1.0 - 0.25) / 2;\n        this.tempPulseColor1.multiplyScalar(scalar);\n        this.tempPulseColor2.multiplyScalar(scalar);\n      } // 3. Apply Edge Detection Pass\n\n\n      this.fsQuad.material = this.edgeDetectionMaterial;\n      this.edgeDetectionMaterial.uniforms['maskTexture'].value = this.renderTargetMaskDownSampleBuffer.texture;\n      this.edgeDetectionMaterial.uniforms['texSize'].value.set(this.renderTargetMaskDownSampleBuffer.width, this.renderTargetMaskDownSampleBuffer.height);\n      this.edgeDetectionMaterial.uniforms['visibleEdgeColor'].value = this.tempPulseColor1;\n      this.edgeDetectionMaterial.uniforms['hiddenEdgeColor'].value = this.tempPulseColor2;\n      renderer.setRenderTarget(this.renderTargetEdgeBuffer1);\n      renderer.clear();\n      this.fsQuad.render(renderer); // 4. Apply Blur on Half res\n\n      this.fsQuad.material = this.separableBlurMaterial1;\n      this.separableBlurMaterial1.uniforms['colorTexture'].value = this.renderTargetEdgeBuffer1.texture;\n      this.separableBlurMaterial1.uniforms['direction'].value = this.BlurDirectionX;\n      this.separableBlurMaterial1.uniforms['kernelRadius'].value = this.edgeThickness;\n      renderer.setRenderTarget(this.renderTargetBlurBuffer1);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.separableBlurMaterial1.uniforms['colorTexture'].value = this.renderTargetBlurBuffer1.texture;\n      this.separableBlurMaterial1.uniforms['direction'].value = this.BlurDirectionY;\n      renderer.setRenderTarget(this.renderTargetEdgeBuffer1);\n      renderer.clear();\n      this.fsQuad.render(renderer); // Apply Blur on quarter res\n\n      this.fsQuad.material = this.separableBlurMaterial2;\n      this.separableBlurMaterial2.uniforms['colorTexture'].value = this.renderTargetEdgeBuffer1.texture;\n      this.separableBlurMaterial2.uniforms['direction'].value = this.BlurDirectionX;\n      renderer.setRenderTarget(this.renderTargetBlurBuffer2);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.separableBlurMaterial2.uniforms['colorTexture'].value = this.renderTargetBlurBuffer2.texture;\n      this.separableBlurMaterial2.uniforms['direction'].value = this.BlurDirectionY;\n      renderer.setRenderTarget(this.renderTargetEdgeBuffer2);\n      renderer.clear();\n      this.fsQuad.render(renderer); // Blend it additively over the input texture\n\n      this.fsQuad.material = this.overlayMaterial;\n      this.overlayMaterial.uniforms['maskTexture'].value = this.renderTargetMaskBuffer.texture;\n      this.overlayMaterial.uniforms['edgeTexture1'].value = this.renderTargetEdgeBuffer1.texture;\n      this.overlayMaterial.uniforms['edgeTexture2'].value = this.renderTargetEdgeBuffer2.texture;\n      this.overlayMaterial.uniforms['patternTexture'].value = this.patternTexture;\n      this.overlayMaterial.uniforms['edgeStrength'].value = this.edgeStrength;\n      this.overlayMaterial.uniforms['edgeGlow'].value = this.edgeGlow;\n      this.overlayMaterial.uniforms['usePatternTexture'].value = this.usePatternTexture;\n      if (maskActive) renderer.state.buffers.stencil.setTest(true);\n      renderer.setRenderTarget(readBuffer);\n      this.fsQuad.render(renderer);\n      renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);\n      renderer.autoClear = oldAutoClear;\n    }\n\n    if (this.renderToScreen) {\n      this.fsQuad.material = this.materialCopy;\n      this.copyUniforms['tDiffuse'].value = readBuffer.texture;\n      renderer.setRenderTarget(null);\n      this.fsQuad.render(renderer);\n    }\n  }\n\n  getPrepareMaskMaterial() {\n    return new ShaderMaterial({\n      uniforms: {\n        depthTexture: {\n          value: null\n        },\n        cameraNearFar: {\n          value: new Vector2(0.5, 0.5)\n        },\n        textureMatrix: {\n          value: null\n        }\n      },\n      vertexShader: `#include <morphtarget_pars_vertex>\n\t\t\t\t#include <skinning_pars_vertex>\n\t\t\t\tvarying vec4 projTexCoord;\n\t\t\t\tvarying vec4 vPosition;\n\t\t\t\tuniform mat4 textureMatrix;\n\t\t\t\tvoid main() {\n\t\t\t\t\t#include <skinbase_vertex>\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <morphtarget_vertex>\n\t\t\t\t\t#include <skinning_vertex>\n\t\t\t\t\t#include <project_vertex>\n\t\t\t\t\tvPosition = mvPosition;\n\t\t\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\t\t\t\t\tprojTexCoord = textureMatrix * worldPosition;\n\t\t\t\t}`,\n      fragmentShader: `#include <packing>\n\t\t\t\tvarying vec4 vPosition;\n\t\t\t\tvarying vec4 projTexCoord;\n\t\t\t\tuniform sampler2D depthTexture;\n\t\t\t\tuniform vec2 cameraNearFar;\n\t\t\t\tvoid main() {\n\t\t\t\t\tfloat depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));\n\t\t\t\t\tfloat viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );\n\t\t\t\t\tfloat depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;\n\t\t\t\t\tgl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);\n\t\t\t\t}`\n    });\n  }\n\n  getEdgeDetectionMaterial() {\n    return new ShaderMaterial({\n      uniforms: {\n        maskTexture: {\n          value: null\n        },\n        texSize: {\n          value: new Vector2(0.5, 0.5)\n        },\n        visibleEdgeColor: {\n          value: new Vector3(1.0, 1.0, 1.0)\n        },\n        hiddenEdgeColor: {\n          value: new Vector3(1.0, 1.0, 1.0)\n        }\n      },\n      vertexShader: `varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n      fragmentShader: `varying vec2 vUv;\n\t\t\t\tuniform sampler2D maskTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec3 visibleEdgeColor;\n\t\t\t\tuniform vec3 hiddenEdgeColor;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tvec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\n\t\t\t\t\tvec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);\n\t\t\t\t\tvec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);\n\t\t\t\t\tvec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);\n\t\t\t\t\tvec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);\n\t\t\t\t\tfloat diff1 = (c1.r - c2.r)*0.5;\n\t\t\t\t\tfloat diff2 = (c3.r - c4.r)*0.5;\n\t\t\t\t\tfloat d = length( vec2(diff1, diff2) );\n\t\t\t\t\tfloat a1 = min(c1.g, c2.g);\n\t\t\t\t\tfloat a2 = min(c3.g, c4.g);\n\t\t\t\t\tfloat visibilityFactor = min(a1, a2);\n\t\t\t\t\tvec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;\n\t\t\t\t\tgl_FragColor = vec4(edgeColor, 1.0) * vec4(d);\n\t\t\t\t}`\n    });\n  }\n\n  getSeperableBlurMaterial(maxRadius) {\n    return new ShaderMaterial({\n      defines: {\n        MAX_RADIUS: maxRadius\n      },\n      uniforms: {\n        colorTexture: {\n          value: null\n        },\n        texSize: {\n          value: new Vector2(0.5, 0.5)\n        },\n        direction: {\n          value: new Vector2(0.5, 0.5)\n        },\n        kernelRadius: {\n          value: 1.0\n        }\n      },\n      vertexShader: `varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n      fragmentShader: `#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec2 direction;\n\t\t\t\tuniform float kernelRadius;\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n\t\t\t\t}\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, kernelRadius);\n\t\t\t\t\tvec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;\n\t\t\t\t\tvec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\n\t\t\t\t\tvec2 uvOffset = delta;\n\t\t\t\t\tfor( int i = 1; i <= MAX_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat w = gaussianPdf(uvOffset.x, kernelRadius);\n\t\t\t\t\t\tvec4 sample1 = texture2D( colorTexture, vUv + uvOffset);\n\t\t\t\t\t\tvec4 sample2 = texture2D( colorTexture, vUv - uvOffset);\n\t\t\t\t\t\tdiffuseSum += ((sample1 + sample2) * w);\n\t\t\t\t\t\tweightSum += (2.0 * w);\n\t\t\t\t\t\tuvOffset += delta;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = diffuseSum/weightSum;\n\t\t\t\t}`\n    });\n  }\n\n  getOverlayMaterial() {\n    return new ShaderMaterial({\n      uniforms: {\n        maskTexture: {\n          value: null\n        },\n        edgeTexture1: {\n          value: null\n        },\n        edgeTexture2: {\n          value: null\n        },\n        patternTexture: {\n          value: null\n        },\n        edgeStrength: {\n          value: 1.0\n        },\n        edgeGlow: {\n          value: 1.0\n        },\n        usePatternTexture: {\n          value: 0.0\n        }\n      },\n      vertexShader: `varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n      fragmentShader: `varying vec2 vUv;\n\t\t\t\tuniform sampler2D maskTexture;\n\t\t\t\tuniform sampler2D edgeTexture1;\n\t\t\t\tuniform sampler2D edgeTexture2;\n\t\t\t\tuniform sampler2D patternTexture;\n\t\t\t\tuniform float edgeStrength;\n\t\t\t\tuniform float edgeGlow;\n\t\t\t\tuniform bool usePatternTexture;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec4 edgeValue1 = texture2D(edgeTexture1, vUv);\n\t\t\t\t\tvec4 edgeValue2 = texture2D(edgeTexture2, vUv);\n\t\t\t\t\tvec4 maskColor = texture2D(maskTexture, vUv);\n\t\t\t\t\tvec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\n\t\t\t\t\tfloat visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\n\t\t\t\t\tvec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\n\t\t\t\t\tvec4 finalColor = edgeStrength * maskColor.r * edgeValue;\n\t\t\t\t\tif(usePatternTexture)\n\t\t\t\t\t\tfinalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\n\t\t\t\t\tgl_FragColor = finalColor;\n\t\t\t\t}`,\n      blending: AdditiveBlending,\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n  }\n\n}\n\nexport { OutlinePass };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}