{"ast":null,"code":"import _construct from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/construct.js\";\nimport _toConsumableArray from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport PropertyNode from './core/PropertyNode.js';\nimport VarNode from './core/VarNode.js';\nimport AttributeNode from './core/AttributeNode.js';\nimport ConstNode from './core/ConstNode.js';\nimport UniformNode from './core/UniformNode.js';\nimport BufferNode from './accessors/BufferNode.js';\nimport PositionNode from './accessors/PositionNode.js';\nimport NormalNode from './accessors/NormalNode.js';\nimport CameraNode from './accessors/CameraNode.js';\nimport ModelNode from './accessors/ModelNode.js';\nimport TextureNode from './accessors/TextureNode.js';\nimport UVNode from './accessors/UVNode.js';\nimport OperatorNode from './math/OperatorNode.js';\nimport CondNode from './math/CondNode.js';\nimport MathNode from './math/MathNode.js';\nimport ArrayElementNode from './utils/ArrayElementNode.js';\nimport ConvertNode from './utils/ConvertNode.js';\nimport JoinNode from './utils/JoinNode.js';\nimport SplitNode from './utils/SplitNode.js';\nimport { getValueFromType } from './core/NodeUtils.js';\n\n// core nodes\nvar NodeHandler = {\n  construct: function construct(NodeClosure, params) {\n    var inputs = params.shift();\n    return NodeClosure.apply(void 0, [new ShaderNodeObjects(inputs)].concat(_toConsumableArray(params)));\n  },\n  get: function get(node, prop) {\n    if (typeof prop === 'string' && node[prop] === undefined) {\n      if (/^[xyzwrgbastpq]{1,4}$/.test(prop) === true) {\n        // accessing properties ( swizzle )\n        prop = prop.replace(/r|s/g, 'x').replace(/g|t/g, 'y').replace(/b|p/g, 'z').replace(/a|q/g, 'w');\n        return new ShaderNodeObject(new SplitNode(node, prop));\n      } else if (/^\\d+$/.test(prop) === true) {\n        // accessing array\n        return new ShaderNodeObject(new ArrayElementNode(node, uint(Number(prop))));\n      }\n    }\n    return node[prop];\n  }\n};\nvar nodeObjects = new WeakMap();\nvar ShaderNodeObject = function ShaderNodeObject(obj) {\n  var type = typeof obj;\n  if (type === 'number' || type === 'boolean') {\n    return new ShaderNodeObject(getAutoTypedConstNode(obj));\n  } else if (type === 'object') {\n    if (obj.isNode === true) {\n      var _nodeObject = nodeObjects.get(obj);\n      if (_nodeObject === undefined) {\n        _nodeObject = new Proxy(obj, NodeHandler);\n        nodeObjects.set(obj, _nodeObject);\n        nodeObjects.set(_nodeObject, _nodeObject);\n      }\n      return _nodeObject;\n    }\n  }\n  return obj;\n};\nvar ShaderNodeObjects = function ShaderNodeObjects(objects) {\n  for (var name in objects) {\n    objects[name] = new ShaderNodeObject(objects[name]);\n  }\n  return objects;\n};\nvar getShaderNodeArray = function getShaderNodeArray(array) {\n  var len = array.length;\n  for (var i = 0; i < len; i++) {\n    array[i] = new ShaderNodeObject(array[i]);\n  }\n  return array;\n};\nvar ShaderNodeProxy = function ShaderNodeProxy(NodeClass) {\n  var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var factor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  if (scope === null) {\n    return function () {\n      for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {\n        params[_key] = arguments[_key];\n      }\n      return new ShaderNodeObject(_construct(NodeClass, _toConsumableArray(getShaderNodeArray(params))));\n    };\n  } else if (factor === null) {\n    return function () {\n      for (var _len2 = arguments.length, params = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        params[_key2] = arguments[_key2];\n      }\n      return new ShaderNodeObject(_construct(NodeClass, [scope].concat(_toConsumableArray(getShaderNodeArray(params)))));\n    };\n  } else {\n    factor = new ShaderNodeObject(factor);\n    return function () {\n      for (var _len3 = arguments.length, params = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        params[_key3] = arguments[_key3];\n      }\n      return new ShaderNodeObject(_construct(NodeClass, [scope].concat(_toConsumableArray(getShaderNodeArray(params)), [factor])));\n    };\n  }\n};\nvar ShaderNodeScript = function ShaderNodeScript(jsFunc) {\n  return function (inputs, builder) {\n    new ShaderNodeObjects(inputs);\n    return new ShaderNodeObject(jsFunc(inputs, builder));\n  };\n};\nvar bools = [false, true];\nvar uints = [0, 1, 2, 3];\nvar ints = [-1, -2];\nvar floats = [0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / (Math.PI * 2), Math.PI / 2];\nvar boolsCacheMap = new Map();\nfor (var _i = 0, _bools = bools; _i < _bools.length; _i++) {\n  var _bool = _bools[_i];\n  boolsCacheMap.set(_bool, new ConstNode(_bool));\n}\nvar uintsCacheMap = new Map();\nfor (var _i2 = 0, _uints = uints; _i2 < _uints.length; _i2++) {\n  var _uint = _uints[_i2];\n  uintsCacheMap.set(_uint, new ConstNode(_uint, 'uint'));\n}\nvar intsCacheMap = new Map(_toConsumableArray(uintsCacheMap).map(function (el) {\n  return new ConstNode(el.value, 'int');\n}));\nfor (var _i3 = 0, _ints = ints; _i3 < _ints.length; _i3++) {\n  var _int = _ints[_i3];\n  intsCacheMap.set(_int, new ConstNode(_int, 'int'));\n}\nvar floatsCacheMap = new Map(_toConsumableArray(intsCacheMap).map(function (el) {\n  return new ConstNode(el.value);\n}));\nfor (var _i4 = 0, _floats = floats; _i4 < _floats.length; _i4++) {\n  var _float = _floats[_i4];\n  floatsCacheMap.set(_float, new ConstNode(_float));\n}\nfor (var _i5 = 0, _floats2 = floats; _i5 < _floats2.length; _i5++) {\n  var _float2 = _floats2[_i5];\n  floatsCacheMap.set(-_float2, new ConstNode(-_float2));\n}\nvar constNodesCacheMap = new Map([].concat(_toConsumableArray(boolsCacheMap), _toConsumableArray(floatsCacheMap)));\nvar getAutoTypedConstNode = function getAutoTypedConstNode(value) {\n  if (constNodesCacheMap.has(value)) {\n    return constNodesCacheMap.get(value);\n  } else if (value.isNode === true) {\n    return value;\n  } else {\n    return new ConstNode(value);\n  }\n};\nvar ConvertType = function ConvertType(type) {\n  var cacheMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return function () {\n    for (var _len4 = arguments.length, params = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      params[_key4] = arguments[_key4];\n    }\n    if (params.length === 0) {\n      return nodeObject(new ConstNode(getValueFromType(type), type));\n    } else {\n      if (type === 'color' && params[0].isNode !== true) {\n        params = [getValueFromType.apply(void 0, [type].concat(_toConsumableArray(params)))];\n      }\n      if (params.length === 1 && cacheMap !== null && cacheMap.has(params[0])) {\n        return cacheMap.get(params[0]);\n      }\n      var nodes = params.map(getAutoTypedConstNode);\n      return nodeObject(new ConvertNode(nodes.length === 1 ? nodes[0] : new JoinNode(nodes), type));\n    }\n  };\n}; //\n// Node Material Shader Syntax\n//\n\nvar ShaderNode = new Proxy(ShaderNodeScript, NodeHandler);\nvar nodeObject = function nodeObject(val) {\n  return new ShaderNodeObject(val);\n};\nvar uniform = function uniform(value) {\n  var _value$node;\n\n  // TODO: get ConstNode from .traverse() in the future\n  value = value.isNode === true ? ((_value$node = value.node) === null || _value$node === void 0 ? void 0 : _value$node.value) || value.value : value;\n  return nodeObject(new UniformNode(value, value.nodeType));\n};\nvar label = function label(node, name) {\n  node = nodeObject(node);\n  if (node.isVarNode === true) {\n    node.name = name;\n    return node;\n  }\n  return nodeObject(new VarNode(node, name));\n};\nvar temp = function temp(node) {\n  return nodeObject(new VarNode(nodeObject(node)));\n};\nvar color = new ConvertType('color');\nvar float = new ConvertType('float', floatsCacheMap);\nvar int = new ConvertType('int', intsCacheMap);\nvar uint = new ConvertType('uint', uintsCacheMap);\nvar bool = new ConvertType('bool', boolsCacheMap);\nvar vec2 = new ConvertType('vec2');\nvar ivec2 = new ConvertType('ivec2');\nvar uvec2 = new ConvertType('uvec2');\nvar bvec2 = new ConvertType('bvec2');\nvar vec3 = new ConvertType('vec3');\nvar ivec3 = new ConvertType('ivec3');\nvar uvec3 = new ConvertType('uvec3');\nvar bvec3 = new ConvertType('bvec3');\nvar vec4 = new ConvertType('vec4');\nvar ivec4 = new ConvertType('ivec4');\nvar uvec4 = new ConvertType('uvec4');\nvar bvec4 = new ConvertType('bvec4');\nvar mat3 = new ConvertType('mat3');\nvar imat3 = new ConvertType('imat3');\nvar umat3 = new ConvertType('umat3');\nvar bmat3 = new ConvertType('bmat3');\nvar mat4 = new ConvertType('mat4');\nvar imat4 = new ConvertType('imat4');\nvar umat4 = new ConvertType('umat4');\nvar bmat4 = new ConvertType('bmat4');\nvar join = function join() {\n  for (var _len5 = arguments.length, params = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n    params[_key5] = arguments[_key5];\n  }\n  return nodeObject(new JoinNode(getShaderNodeArray(params)));\n};\nvar uv = function uv() {\n  for (var _len6 = arguments.length, params = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n    params[_key6] = arguments[_key6];\n  }\n  return nodeObject(_construct(UVNode, params));\n};\nvar attribute = function attribute() {\n  for (var _len7 = arguments.length, params = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n    params[_key7] = arguments[_key7];\n  }\n  return nodeObject(_construct(AttributeNode, params));\n};\nvar buffer = function buffer() {\n  for (var _len8 = arguments.length, params = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n    params[_key8] = arguments[_key8];\n  }\n  return nodeObject(_construct(BufferNode, params));\n};\nvar texture = function texture() {\n  for (var _len9 = arguments.length, params = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n    params[_key9] = arguments[_key9];\n  }\n  return nodeObject(_construct(TextureNode, params));\n};\nvar sampler = function sampler(texture) {\n  return nodeObject(new ConvertNode(texture.isNode === true ? texture : new TextureNode(texture), 'sampler'));\n};\nvar cond = function cond() {\n  for (var _len10 = arguments.length, params = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n    params[_key10] = arguments[_key10];\n  }\n  return nodeObject(_construct(CondNode, _toConsumableArray(getShaderNodeArray(params))));\n};\nvar addTo = function addTo(varNode) {\n  for (var _len11 = arguments.length, params = new Array(_len11 > 1 ? _len11 - 1 : 0), _key11 = 1; _key11 < _len11; _key11++) {\n    params[_key11 - 1] = arguments[_key11];\n  }\n  varNode.node = add.apply(void 0, [varNode.node].concat(_toConsumableArray(getShaderNodeArray(params))));\n  return nodeObject(varNode);\n};\nvar add = new ShaderNodeProxy(OperatorNode, '+');\nvar sub = new ShaderNodeProxy(OperatorNode, '-');\nvar mul = new ShaderNodeProxy(OperatorNode, '*');\nvar div = new ShaderNodeProxy(OperatorNode, '/');\nvar remainder = new ShaderNodeProxy(OperatorNode, '%');\nvar equal = new ShaderNodeProxy(OperatorNode, '==');\nvar assign = new ShaderNodeProxy(OperatorNode, '=');\nvar lessThan = new ShaderNodeProxy(OperatorNode, '<');\nvar greaterThan = new ShaderNodeProxy(OperatorNode, '>');\nvar lessThanEqual = new ShaderNodeProxy(OperatorNode, '<=');\nvar greaterThanEqual = new ShaderNodeProxy(OperatorNode, '>=');\nvar and = new ShaderNodeProxy(OperatorNode, '&&');\nvar or = new ShaderNodeProxy(OperatorNode, '||');\nvar xor = new ShaderNodeProxy(OperatorNode, '^^');\nvar bitAnd = new ShaderNodeProxy(OperatorNode, '&');\nvar bitOr = new ShaderNodeProxy(OperatorNode, '|');\nvar bitXor = new ShaderNodeProxy(OperatorNode, '^');\nvar shiftLeft = new ShaderNodeProxy(OperatorNode, '<<');\nvar shiftRight = new ShaderNodeProxy(OperatorNode, '>>');\nvar element = new ShaderNodeProxy(ArrayElementNode);\nvar normalGeometry = new ShaderNodeObject(new NormalNode(NormalNode.GEOMETRY));\nvar normalLocal = new ShaderNodeObject(new NormalNode(NormalNode.LOCAL));\nvar normalWorld = new ShaderNodeObject(new NormalNode(NormalNode.WORLD));\nvar normalView = new ShaderNodeObject(new NormalNode(NormalNode.VIEW));\nvar transformedNormalView = new ShaderNodeObject(new VarNode(new NormalNode(NormalNode.VIEW), 'TransformedNormalView', 'vec3'));\nvar positionLocal = new ShaderNodeObject(new PositionNode(PositionNode.LOCAL));\nvar positionWorld = new ShaderNodeObject(new PositionNode(PositionNode.WORLD));\nvar positionView = new ShaderNodeObject(new PositionNode(PositionNode.VIEW));\nvar positionViewDirection = new ShaderNodeObject(new PositionNode(PositionNode.VIEW_DIRECTION));\nvar viewMatrix = new ShaderNodeObject(new ModelNode(ModelNode.VIEW_MATRIX));\nvar cameraPosition = new ShaderNodeObject(new CameraNode(CameraNode.POSITION));\nvar diffuseColor = new ShaderNodeObject(new PropertyNode('DiffuseColor', 'vec4'));\nvar roughness = new ShaderNodeObject(new PropertyNode('Roughness', 'float'));\nvar metalness = new ShaderNodeObject(new PropertyNode('Metalness', 'float'));\nvar alphaTest = new ShaderNodeObject(new PropertyNode('AlphaTest', 'float'));\nvar specularColor = new ShaderNodeObject(new PropertyNode('SpecularColor', 'color'));\nvar abs = new ShaderNodeProxy(MathNode, 'abs');\nvar acos = new ShaderNodeProxy(MathNode, 'acos');\nvar asin = new ShaderNodeProxy(MathNode, 'asin');\nvar atan = new ShaderNodeProxy(MathNode, 'atan');\nvar ceil = new ShaderNodeProxy(MathNode, 'ceil');\nvar clamp = new ShaderNodeProxy(MathNode, 'clamp');\nvar cos = new ShaderNodeProxy(MathNode, 'cos');\nvar cross = new ShaderNodeProxy(MathNode, 'cross');\nvar degrees = new ShaderNodeProxy(MathNode, 'degrees');\nvar dFdx = new ShaderNodeProxy(MathNode, 'dFdx');\nvar dFdy = new ShaderNodeProxy(MathNode, 'dFdy');\nvar distance = new ShaderNodeProxy(MathNode, 'distance');\nvar dot = new ShaderNodeProxy(MathNode, 'dot');\nvar exp = new ShaderNodeProxy(MathNode, 'exp');\nvar exp2 = new ShaderNodeProxy(MathNode, 'exp2');\nvar faceforward = new ShaderNodeProxy(MathNode, 'faceforward');\nvar floor = new ShaderNodeProxy(MathNode, 'floor');\nvar fract = new ShaderNodeProxy(MathNode, 'fract');\nvar invert = new ShaderNodeProxy(MathNode, 'invert');\nvar inversesqrt = new ShaderNodeProxy(MathNode, 'inversesqrt');\nvar length = new ShaderNodeProxy(MathNode, 'length');\nvar log = new ShaderNodeProxy(MathNode, 'log');\nvar log2 = new ShaderNodeProxy(MathNode, 'log2');\nvar max = new ShaderNodeProxy(MathNode, 'max');\nvar min = new ShaderNodeProxy(MathNode, 'min');\nvar mix = new ShaderNodeProxy(MathNode, 'mix');\nvar mod = new ShaderNodeProxy(MathNode, 'mod');\nvar negate = new ShaderNodeProxy(MathNode, 'negate');\nvar normalize = new ShaderNodeProxy(MathNode, 'normalize');\nvar pow = new ShaderNodeProxy(MathNode, 'pow');\nvar pow2 = new ShaderNodeProxy(MathNode, 'pow', 2);\nvar pow3 = new ShaderNodeProxy(MathNode, 'pow', 3);\nvar pow4 = new ShaderNodeProxy(MathNode, 'pow', 4);\nvar radians = new ShaderNodeProxy(MathNode, 'radians');\nvar reflect = new ShaderNodeProxy(MathNode, 'reflect');\nvar refract = new ShaderNodeProxy(MathNode, 'refract');\nvar round = new ShaderNodeProxy(MathNode, 'round');\nvar saturate = new ShaderNodeProxy(MathNode, 'saturate');\nvar sign = new ShaderNodeProxy(MathNode, 'sign');\nvar sin = new ShaderNodeProxy(MathNode, 'sin');\nvar smoothstep = new ShaderNodeProxy(MathNode, 'smoothstep');\nvar sqrt = new ShaderNodeProxy(MathNode, 'sqrt');\nvar step = new ShaderNodeProxy(MathNode, 'step');\nvar tan = new ShaderNodeProxy(MathNode, 'tan');\nvar transformDirection = new ShaderNodeProxy(MathNode, 'transformDirection');\nvar EPSILON = float(1e-6);\nvar INFINITY = float(1e6);\nexport { EPSILON, INFINITY, ShaderNode, abs, acos, add, addTo, alphaTest, and, asin, assign, atan, attribute, bitAnd, bitOr, bitXor, bmat3, bmat4, bool, buffer, bvec2, bvec3, bvec4, cameraPosition, ceil, clamp, color, cond, cos, cross, dFdx, dFdy, degrees, diffuseColor, distance, div, dot, element, equal, exp, exp2, faceforward, float, floor, fract, greaterThan, greaterThanEqual, imat3, imat4, int, inversesqrt, invert, ivec2, ivec3, ivec4, join, label, length, lessThan, lessThanEqual, log, log2, mat3, mat4, max, metalness, min, mix, mod, mul, negate, nodeObject, normalGeometry, normalLocal, normalView, normalWorld, normalize, or, positionLocal, positionView, positionViewDirection, positionWorld, pow, pow2, pow3, pow4, radians, reflect, refract, remainder, roughness, round, sampler, saturate, shiftLeft, shiftRight, sign, sin, smoothstep, specularColor, sqrt, step, sub, tan, temp, texture, transformDirection, transformedNormalView, uint, umat3, umat4, uniform, uv, uvec2, uvec3, uvec4, vec2, vec3, vec4, viewMatrix, xor };","map":{"version":3,"names":["PropertyNode","VarNode","AttributeNode","ConstNode","UniformNode","BufferNode","PositionNode","NormalNode","CameraNode","ModelNode","TextureNode","UVNode","OperatorNode","CondNode","MathNode","ArrayElementNode","ConvertNode","JoinNode","SplitNode","getValueFromType","NodeHandler","construct","NodeClosure","params","inputs","shift","apply","ShaderNodeObjects","concat","_toConsumableArray","get","node","prop","undefined","test","replace","ShaderNodeObject","uint","Number","nodeObjects","WeakMap","obj","type","getAutoTypedConstNode","isNode","nodeObject","Proxy","set","objects","name","getShaderNodeArray","array","len","length","i","ShaderNodeProxy","NodeClass","scope","arguments","factor","_len","Array","_key","_construct","_len2","_key2","_len3","_key3","ShaderNodeScript","jsFunc","builder","bools","uints","ints","floats","Math","PI","boolsCacheMap","Map","_i","_bools","bool","uintsCacheMap","_i2","_uints","intsCacheMap","map","el","value","_i3","_ints","int","floatsCacheMap","_i4","_floats","float","_i5","_floats2","constNodesCacheMap","has","ConvertType","cacheMap","_len4","_key4","nodes","ShaderNode","val","uniform","_value$node","nodeType","label","isVarNode","temp","color","vec2","ivec2","uvec2","bvec2","vec3","ivec3","uvec3","bvec3","vec4","ivec4","uvec4","bvec4","mat3","imat3","umat3","bmat3","mat4","imat4","umat4","bmat4","join","_len5","_key5","uv","_len6","_key6","attribute","_len7","_key7","buffer","_len8","_key8","texture","_len9","_key9","sampler","cond","_len10","_key10","addTo","varNode","_len11","_key11","add","sub","mul","div","remainder","equal","assign","lessThan","greaterThan","lessThanEqual","greaterThanEqual","and","or","xor","bitAnd","bitOr","bitXor","shiftLeft","shiftRight","element","normalGeometry","GEOMETRY","normalLocal","LOCAL","normalWorld","WORLD","normalView","VIEW","transformedNormalView","positionLocal","positionWorld","positionView","positionViewDirection","VIEW_DIRECTION","viewMatrix","VIEW_MATRIX","cameraPosition","POSITION","diffuseColor","roughness","metalness","alphaTest","specularColor","abs","acos","asin","atan","ceil","clamp","cos","cross","degrees","dFdx","dFdy","distance","dot","exp","exp2","faceforward","floor","fract","invert","inversesqrt","log","log2","max","min","mix","mod","negate","normalize","pow","pow2","pow3","pow4","radians","reflect","refract","round","saturate","sign","sin","smoothstep","sqrt","step","tan","transformDirection","EPSILON","INFINITY"],"sources":["/home/samuel/experiment/3d/farm/frontend/node_modules/three-stdlib/nodes/ShaderNode.js"],"sourcesContent":["import PropertyNode from './core/PropertyNode.js';\nimport VarNode from './core/VarNode.js';\nimport AttributeNode from './core/AttributeNode.js';\nimport ConstNode from './core/ConstNode.js';\nimport UniformNode from './core/UniformNode.js';\nimport BufferNode from './accessors/BufferNode.js';\nimport PositionNode from './accessors/PositionNode.js';\nimport NormalNode from './accessors/NormalNode.js';\nimport CameraNode from './accessors/CameraNode.js';\nimport ModelNode from './accessors/ModelNode.js';\nimport TextureNode from './accessors/TextureNode.js';\nimport UVNode from './accessors/UVNode.js';\nimport OperatorNode from './math/OperatorNode.js';\nimport CondNode from './math/CondNode.js';\nimport MathNode from './math/MathNode.js';\nimport ArrayElementNode from './utils/ArrayElementNode.js';\nimport ConvertNode from './utils/ConvertNode.js';\nimport JoinNode from './utils/JoinNode.js';\nimport SplitNode from './utils/SplitNode.js';\nimport { getValueFromType } from './core/NodeUtils.js';\n\n// core nodes\nconst NodeHandler = {\n  construct(NodeClosure, params) {\n    const inputs = params.shift();\n    return NodeClosure(new ShaderNodeObjects(inputs), ...params);\n  },\n\n  get: function (node, prop) {\n    if (typeof prop === 'string' && node[prop] === undefined) {\n      if (/^[xyzwrgbastpq]{1,4}$/.test(prop) === true) {\n        // accessing properties ( swizzle )\n        prop = prop.replace(/r|s/g, 'x').replace(/g|t/g, 'y').replace(/b|p/g, 'z').replace(/a|q/g, 'w');\n        return new ShaderNodeObject(new SplitNode(node, prop));\n      } else if (/^\\d+$/.test(prop) === true) {\n        // accessing array\n        return new ShaderNodeObject(new ArrayElementNode(node, uint(Number(prop))));\n      }\n    }\n\n    return node[prop];\n  }\n};\nconst nodeObjects = new WeakMap();\n\nconst ShaderNodeObject = function (obj) {\n  const type = typeof obj;\n\n  if (type === 'number' || type === 'boolean') {\n    return new ShaderNodeObject(getAutoTypedConstNode(obj));\n  } else if (type === 'object') {\n    if (obj.isNode === true) {\n      let nodeObject = nodeObjects.get(obj);\n\n      if (nodeObject === undefined) {\n        nodeObject = new Proxy(obj, NodeHandler);\n        nodeObjects.set(obj, nodeObject);\n        nodeObjects.set(nodeObject, nodeObject);\n      }\n\n      return nodeObject;\n    }\n  }\n\n  return obj;\n};\n\nconst ShaderNodeObjects = function (objects) {\n  for (const name in objects) {\n    objects[name] = new ShaderNodeObject(objects[name]);\n  }\n\n  return objects;\n};\n\nconst getShaderNodeArray = array => {\n  const len = array.length;\n\n  for (let i = 0; i < len; i++) {\n    array[i] = new ShaderNodeObject(array[i]);\n  }\n\n  return array;\n};\n\nconst ShaderNodeProxy = function (NodeClass, scope = null, factor = null) {\n  if (scope === null) {\n    return (...params) => {\n      return new ShaderNodeObject(new NodeClass(...getShaderNodeArray(params)));\n    };\n  } else if (factor === null) {\n    return (...params) => {\n      return new ShaderNodeObject(new NodeClass(scope, ...getShaderNodeArray(params)));\n    };\n  } else {\n    factor = new ShaderNodeObject(factor);\n    return (...params) => {\n      return new ShaderNodeObject(new NodeClass(scope, ...getShaderNodeArray(params), factor));\n    };\n  }\n};\n\nconst ShaderNodeScript = function (jsFunc) {\n  return (inputs, builder) => {\n    new ShaderNodeObjects(inputs);\n    return new ShaderNodeObject(jsFunc(inputs, builder));\n  };\n};\n\nconst bools = [false, true];\nconst uints = [0, 1, 2, 3];\nconst ints = [-1, -2];\nconst floats = [0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / (Math.PI * 2), Math.PI / 2];\nconst boolsCacheMap = new Map();\n\nfor (let bool of bools) boolsCacheMap.set(bool, new ConstNode(bool));\n\nconst uintsCacheMap = new Map();\n\nfor (let uint of uints) uintsCacheMap.set(uint, new ConstNode(uint, 'uint'));\n\nconst intsCacheMap = new Map([...uintsCacheMap].map(el => new ConstNode(el.value, 'int')));\n\nfor (let int of ints) intsCacheMap.set(int, new ConstNode(int, 'int'));\n\nconst floatsCacheMap = new Map([...intsCacheMap].map(el => new ConstNode(el.value)));\n\nfor (let float of floats) floatsCacheMap.set(float, new ConstNode(float));\n\nfor (let float of floats) floatsCacheMap.set(-float, new ConstNode(-float));\n\nconst constNodesCacheMap = new Map([...boolsCacheMap, ...floatsCacheMap]);\n\nconst getAutoTypedConstNode = value => {\n  if (constNodesCacheMap.has(value)) {\n    return constNodesCacheMap.get(value);\n  } else if (value.isNode === true) {\n    return value;\n  } else {\n    return new ConstNode(value);\n  }\n};\n\nconst ConvertType = function (type, cacheMap = null) {\n  return (...params) => {\n    if (params.length === 0) {\n      return nodeObject(new ConstNode(getValueFromType(type), type));\n    } else {\n      if (type === 'color' && params[0].isNode !== true) {\n        params = [getValueFromType(type, ...params)];\n      }\n\n      if (params.length === 1 && cacheMap !== null && cacheMap.has(params[0])) {\n        return cacheMap.get(params[0]);\n      }\n\n      const nodes = params.map(getAutoTypedConstNode);\n      return nodeObject(new ConvertNode(nodes.length === 1 ? nodes[0] : new JoinNode(nodes), type));\n    }\n  };\n}; //\n// Node Material Shader Syntax\n//\n\n\nconst ShaderNode = new Proxy(ShaderNodeScript, NodeHandler);\nconst nodeObject = val => {\n  return new ShaderNodeObject(val);\n};\nconst uniform = value => {\n  var _value$node;\n\n  // TODO: get ConstNode from .traverse() in the future\n  value = value.isNode === true ? ((_value$node = value.node) === null || _value$node === void 0 ? void 0 : _value$node.value) || value.value : value;\n  return nodeObject(new UniformNode(value, value.nodeType));\n};\nconst label = (node, name) => {\n  node = nodeObject(node);\n\n  if (node.isVarNode === true) {\n    node.name = name;\n    return node;\n  }\n\n  return nodeObject(new VarNode(node, name));\n};\nconst temp = node => nodeObject(new VarNode(nodeObject(node)));\nconst color = new ConvertType('color');\nconst float = new ConvertType('float', floatsCacheMap);\nconst int = new ConvertType('int', intsCacheMap);\nconst uint = new ConvertType('uint', uintsCacheMap);\nconst bool = new ConvertType('bool', boolsCacheMap);\nconst vec2 = new ConvertType('vec2');\nconst ivec2 = new ConvertType('ivec2');\nconst uvec2 = new ConvertType('uvec2');\nconst bvec2 = new ConvertType('bvec2');\nconst vec3 = new ConvertType('vec3');\nconst ivec3 = new ConvertType('ivec3');\nconst uvec3 = new ConvertType('uvec3');\nconst bvec3 = new ConvertType('bvec3');\nconst vec4 = new ConvertType('vec4');\nconst ivec4 = new ConvertType('ivec4');\nconst uvec4 = new ConvertType('uvec4');\nconst bvec4 = new ConvertType('bvec4');\nconst mat3 = new ConvertType('mat3');\nconst imat3 = new ConvertType('imat3');\nconst umat3 = new ConvertType('umat3');\nconst bmat3 = new ConvertType('bmat3');\nconst mat4 = new ConvertType('mat4');\nconst imat4 = new ConvertType('imat4');\nconst umat4 = new ConvertType('umat4');\nconst bmat4 = new ConvertType('bmat4');\nconst join = (...params) => nodeObject(new JoinNode(getShaderNodeArray(params)));\nconst uv = (...params) => nodeObject(new UVNode(...params));\nconst attribute = (...params) => nodeObject(new AttributeNode(...params));\nconst buffer = (...params) => nodeObject(new BufferNode(...params));\nconst texture = (...params) => nodeObject(new TextureNode(...params));\nconst sampler = texture => nodeObject(new ConvertNode(texture.isNode === true ? texture : new TextureNode(texture), 'sampler'));\nconst cond = (...params) => nodeObject(new CondNode(...getShaderNodeArray(params)));\nconst addTo = (varNode, ...params) => {\n  varNode.node = add(varNode.node, ...getShaderNodeArray(params));\n  return nodeObject(varNode);\n};\nconst add = new ShaderNodeProxy(OperatorNode, '+');\nconst sub = new ShaderNodeProxy(OperatorNode, '-');\nconst mul = new ShaderNodeProxy(OperatorNode, '*');\nconst div = new ShaderNodeProxy(OperatorNode, '/');\nconst remainder = new ShaderNodeProxy(OperatorNode, '%');\nconst equal = new ShaderNodeProxy(OperatorNode, '==');\nconst assign = new ShaderNodeProxy(OperatorNode, '=');\nconst lessThan = new ShaderNodeProxy(OperatorNode, '<');\nconst greaterThan = new ShaderNodeProxy(OperatorNode, '>');\nconst lessThanEqual = new ShaderNodeProxy(OperatorNode, '<=');\nconst greaterThanEqual = new ShaderNodeProxy(OperatorNode, '>=');\nconst and = new ShaderNodeProxy(OperatorNode, '&&');\nconst or = new ShaderNodeProxy(OperatorNode, '||');\nconst xor = new ShaderNodeProxy(OperatorNode, '^^');\nconst bitAnd = new ShaderNodeProxy(OperatorNode, '&');\nconst bitOr = new ShaderNodeProxy(OperatorNode, '|');\nconst bitXor = new ShaderNodeProxy(OperatorNode, '^');\nconst shiftLeft = new ShaderNodeProxy(OperatorNode, '<<');\nconst shiftRight = new ShaderNodeProxy(OperatorNode, '>>');\nconst element = new ShaderNodeProxy(ArrayElementNode);\nconst normalGeometry = new ShaderNodeObject(new NormalNode(NormalNode.GEOMETRY));\nconst normalLocal = new ShaderNodeObject(new NormalNode(NormalNode.LOCAL));\nconst normalWorld = new ShaderNodeObject(new NormalNode(NormalNode.WORLD));\nconst normalView = new ShaderNodeObject(new NormalNode(NormalNode.VIEW));\nconst transformedNormalView = new ShaderNodeObject(new VarNode(new NormalNode(NormalNode.VIEW), 'TransformedNormalView', 'vec3'));\nconst positionLocal = new ShaderNodeObject(new PositionNode(PositionNode.LOCAL));\nconst positionWorld = new ShaderNodeObject(new PositionNode(PositionNode.WORLD));\nconst positionView = new ShaderNodeObject(new PositionNode(PositionNode.VIEW));\nconst positionViewDirection = new ShaderNodeObject(new PositionNode(PositionNode.VIEW_DIRECTION));\nconst viewMatrix = new ShaderNodeObject(new ModelNode(ModelNode.VIEW_MATRIX));\nconst cameraPosition = new ShaderNodeObject(new CameraNode(CameraNode.POSITION));\nconst diffuseColor = new ShaderNodeObject(new PropertyNode('DiffuseColor', 'vec4'));\nconst roughness = new ShaderNodeObject(new PropertyNode('Roughness', 'float'));\nconst metalness = new ShaderNodeObject(new PropertyNode('Metalness', 'float'));\nconst alphaTest = new ShaderNodeObject(new PropertyNode('AlphaTest', 'float'));\nconst specularColor = new ShaderNodeObject(new PropertyNode('SpecularColor', 'color'));\nconst abs = new ShaderNodeProxy(MathNode, 'abs');\nconst acos = new ShaderNodeProxy(MathNode, 'acos');\nconst asin = new ShaderNodeProxy(MathNode, 'asin');\nconst atan = new ShaderNodeProxy(MathNode, 'atan');\nconst ceil = new ShaderNodeProxy(MathNode, 'ceil');\nconst clamp = new ShaderNodeProxy(MathNode, 'clamp');\nconst cos = new ShaderNodeProxy(MathNode, 'cos');\nconst cross = new ShaderNodeProxy(MathNode, 'cross');\nconst degrees = new ShaderNodeProxy(MathNode, 'degrees');\nconst dFdx = new ShaderNodeProxy(MathNode, 'dFdx');\nconst dFdy = new ShaderNodeProxy(MathNode, 'dFdy');\nconst distance = new ShaderNodeProxy(MathNode, 'distance');\nconst dot = new ShaderNodeProxy(MathNode, 'dot');\nconst exp = new ShaderNodeProxy(MathNode, 'exp');\nconst exp2 = new ShaderNodeProxy(MathNode, 'exp2');\nconst faceforward = new ShaderNodeProxy(MathNode, 'faceforward');\nconst floor = new ShaderNodeProxy(MathNode, 'floor');\nconst fract = new ShaderNodeProxy(MathNode, 'fract');\nconst invert = new ShaderNodeProxy(MathNode, 'invert');\nconst inversesqrt = new ShaderNodeProxy(MathNode, 'inversesqrt');\nconst length = new ShaderNodeProxy(MathNode, 'length');\nconst log = new ShaderNodeProxy(MathNode, 'log');\nconst log2 = new ShaderNodeProxy(MathNode, 'log2');\nconst max = new ShaderNodeProxy(MathNode, 'max');\nconst min = new ShaderNodeProxy(MathNode, 'min');\nconst mix = new ShaderNodeProxy(MathNode, 'mix');\nconst mod = new ShaderNodeProxy(MathNode, 'mod');\nconst negate = new ShaderNodeProxy(MathNode, 'negate');\nconst normalize = new ShaderNodeProxy(MathNode, 'normalize');\nconst pow = new ShaderNodeProxy(MathNode, 'pow');\nconst pow2 = new ShaderNodeProxy(MathNode, 'pow', 2);\nconst pow3 = new ShaderNodeProxy(MathNode, 'pow', 3);\nconst pow4 = new ShaderNodeProxy(MathNode, 'pow', 4);\nconst radians = new ShaderNodeProxy(MathNode, 'radians');\nconst reflect = new ShaderNodeProxy(MathNode, 'reflect');\nconst refract = new ShaderNodeProxy(MathNode, 'refract');\nconst round = new ShaderNodeProxy(MathNode, 'round');\nconst saturate = new ShaderNodeProxy(MathNode, 'saturate');\nconst sign = new ShaderNodeProxy(MathNode, 'sign');\nconst sin = new ShaderNodeProxy(MathNode, 'sin');\nconst smoothstep = new ShaderNodeProxy(MathNode, 'smoothstep');\nconst sqrt = new ShaderNodeProxy(MathNode, 'sqrt');\nconst step = new ShaderNodeProxy(MathNode, 'step');\nconst tan = new ShaderNodeProxy(MathNode, 'tan');\nconst transformDirection = new ShaderNodeProxy(MathNode, 'transformDirection');\nconst EPSILON = float(1e-6);\nconst INFINITY = float(1e6);\n\nexport { EPSILON, INFINITY, ShaderNode, abs, acos, add, addTo, alphaTest, and, asin, assign, atan, attribute, bitAnd, bitOr, bitXor, bmat3, bmat4, bool, buffer, bvec2, bvec3, bvec4, cameraPosition, ceil, clamp, color, cond, cos, cross, dFdx, dFdy, degrees, diffuseColor, distance, div, dot, element, equal, exp, exp2, faceforward, float, floor, fract, greaterThan, greaterThanEqual, imat3, imat4, int, inversesqrt, invert, ivec2, ivec3, ivec4, join, label, length, lessThan, lessThanEqual, log, log2, mat3, mat4, max, metalness, min, mix, mod, mul, negate, nodeObject, normalGeometry, normalLocal, normalView, normalWorld, normalize, or, positionLocal, positionView, positionViewDirection, positionWorld, pow, pow2, pow3, pow4, radians, reflect, refract, remainder, roughness, round, sampler, saturate, shiftLeft, shiftRight, sign, sin, smoothstep, specularColor, sqrt, step, sub, tan, temp, texture, transformDirection, transformedNormalView, uint, umat3, umat4, uniform, uv, uvec2, uvec3, uvec4, vec2, vec3, vec4, viewMatrix, xor };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}