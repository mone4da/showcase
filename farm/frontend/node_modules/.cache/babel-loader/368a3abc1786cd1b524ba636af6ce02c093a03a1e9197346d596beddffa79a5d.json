{"ast":null,"code":"import _assertThisInitialized from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _classCallCheck from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Group, LightProbe, DirectionalLight, WebGLCubeRenderTarget } from 'three';\nvar SessionLightProbe = /*#__PURE__*/function () {\n  function SessionLightProbe(xrLight, renderer, lightProbe, environmentEstimation, estimationStartCallback) {\n    var _this = this;\n    _classCallCheck(this, SessionLightProbe);\n    this.xrLight = xrLight;\n    this.renderer = renderer;\n    this.lightProbe = lightProbe;\n    this.xrWebGLBinding = null;\n    this.estimationStartCallback = estimationStartCallback;\n    this.frameCallback = this.onXRFrame.bind(this);\n    var session = renderer.xr.getSession(); // If the XRWebGLBinding class is available then we can also query an\n    // estimated reflection cube map.\n\n    if (environmentEstimation && 'XRWebGLBinding' in window) {\n      // This is the simplest way I know of to initialize a WebGL cubemap in Three.\n      var cubeRenderTarget = new WebGLCubeRenderTarget(16);\n      xrLight.environment = cubeRenderTarget.texture;\n      var gl = renderer.getContext(); // Ensure that we have any extensions needed to use the preferred cube map format.\n\n      switch (session.preferredReflectionFormat) {\n        case 'srgba8':\n          gl.getExtension('EXT_sRGB');\n          break;\n        case 'rgba16f':\n          gl.getExtension('OES_texture_half_float');\n          break;\n      }\n      this.xrWebGLBinding = new XRWebGLBinding(session, gl);\n      this.lightProbe.addEventListener('reflectionchange', function () {\n        _this.updateReflection();\n      });\n    } // Start monitoring the XR animation frame loop to look for lighting\n    // estimation changes.\n\n    session.requestAnimationFrame(this.frameCallback);\n  }\n  _createClass(SessionLightProbe, [{\n    key: \"updateReflection\",\n    value: function updateReflection() {\n      var textureProperties = this.renderer.properties.get(this.xrLight.environment);\n      if (textureProperties) {\n        var cubeMap = this.xrWebGLBinding.getReflectionCubeMap(this.lightProbe);\n        if (cubeMap) {\n          textureProperties.__webglTexture = cubeMap;\n          this.xrLight.environment.needsPMREMUpdate = true;\n        }\n      }\n    }\n  }, {\n    key: \"onXRFrame\",\n    value: function onXRFrame(time, xrFrame) {\n      // If either this obejct or the XREstimatedLight has been destroyed, stop\n      // running the frame loop.\n      if (!this.xrLight) {\n        return;\n      }\n      var session = xrFrame.session;\n      session.requestAnimationFrame(this.frameCallback);\n      var lightEstimate = xrFrame.getLightEstimate(this.lightProbe);\n      if (lightEstimate) {\n        // We can copy the estimate's spherical harmonics array directly into the light probe.\n        this.xrLight.lightProbe.sh.fromArray(lightEstimate.sphericalHarmonicsCoefficients);\n        this.xrLight.lightProbe.intensity = 1.0; // For the directional light we have to normalize the color and set the scalar as the\n        // intensity, since WebXR can return color values that exceed 1.0.\n\n        var intensityScalar = Math.max(1.0, Math.max(lightEstimate.primaryLightIntensity.x, Math.max(lightEstimate.primaryLightIntensity.y, lightEstimate.primaryLightIntensity.z)));\n        this.xrLight.directionalLight.color.setRGB(lightEstimate.primaryLightIntensity.x / intensityScalar, lightEstimate.primaryLightIntensity.y / intensityScalar, lightEstimate.primaryLightIntensity.z / intensityScalar);\n        this.xrLight.directionalLight.intensity = intensityScalar;\n        this.xrLight.directionalLight.position.copy(lightEstimate.primaryLightDirection);\n        if (this.estimationStartCallback) {\n          this.estimationStartCallback();\n          this.estimationStartCallback = null;\n        }\n      }\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.xrLight = null;\n      this.renderer = null;\n      this.lightProbe = null;\n      this.xrWebGLBinding = null;\n    }\n  }]);\n  return SessionLightProbe;\n}();\nvar XREstimatedLight = /*#__PURE__*/function (_Group) {\n  _inherits(XREstimatedLight, _Group);\n  var _super = _createSuper(XREstimatedLight);\n  function XREstimatedLight(renderer) {\n    var _this2;\n    var environmentEstimation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    _classCallCheck(this, XREstimatedLight);\n    _this2 = _super.call(this);\n    _this2.lightProbe = new LightProbe();\n    _this2.lightProbe.intensity = 0;\n    _this2.add(_this2.lightProbe);\n    _this2.directionalLight = new DirectionalLight();\n    _this2.directionalLight.intensity = 0;\n    _this2.add(_this2.directionalLight); // Will be set to a cube map in the SessionLightProbe is environment estimation is\n    // available and requested.\n\n    _this2.environment = null;\n    var sessionLightProbe = null;\n    var estimationStarted = false;\n    renderer.xr.addEventListener('sessionstart', function () {\n      var session = renderer.xr.getSession();\n      if ('requestLightProbe' in session) {\n        session.requestLightProbe({\n          reflectionFormat: session.preferredReflectionFormat\n        }).then(function (probe) {\n          sessionLightProbe = new SessionLightProbe(_assertThisInitialized(_this2), renderer, probe, environmentEstimation, function () {\n            estimationStarted = true; // Fired to indicate that the estimated lighting values are now being updated.\n\n            _this2.dispatchEvent({\n              type: 'estimationstart'\n            });\n          });\n        });\n      }\n    });\n    renderer.xr.addEventListener('sessionend', function () {\n      if (sessionLightProbe) {\n        sessionLightProbe.dispose();\n        sessionLightProbe = null;\n      }\n      if (estimationStarted) {\n        // Fired to indicate that the estimated lighting values are no longer being updated.\n        _this2.dispatchEvent({\n          type: 'estimationend'\n        });\n      }\n    }); // Done inline to provide access to sessionLightProbe.\n\n    _this2.dispose = function () {\n      if (sessionLightProbe) {\n        sessionLightProbe.dispose();\n        sessionLightProbe = null;\n      }\n      _this2.remove(_this2.lightProbe);\n      _this2.lightProbe = null;\n      _this2.remove(_this2.directionalLight);\n      _this2.directionalLight = null;\n      _this2.environment = null;\n    };\n    return _this2;\n  }\n  return _createClass(XREstimatedLight);\n}(Group);\nexport { XREstimatedLight };","map":{"version":3,"names":["Group","LightProbe","DirectionalLight","WebGLCubeRenderTarget","SessionLightProbe","xrLight","renderer","lightProbe","environmentEstimation","estimationStartCallback","_this","_classCallCheck","xrWebGLBinding","frameCallback","onXRFrame","bind","session","xr","getSession","window","cubeRenderTarget","environment","texture","gl","getContext","preferredReflectionFormat","getExtension","XRWebGLBinding","addEventListener","updateReflection","requestAnimationFrame","_createClass","key","value","textureProperties","properties","get","cubeMap","getReflectionCubeMap","__webglTexture","needsPMREMUpdate","time","xrFrame","lightEstimate","getLightEstimate","sh","fromArray","sphericalHarmonicsCoefficients","intensity","intensityScalar","Math","max","primaryLightIntensity","x","y","z","directionalLight","color","setRGB","position","copy","primaryLightDirection","dispose","XREstimatedLight","_Group","_inherits","_super","_createSuper","_this2","arguments","length","undefined","call","add","sessionLightProbe","estimationStarted","requestLightProbe","reflectionFormat","then","probe","_assertThisInitialized","dispatchEvent","type","remove"],"sources":["/home/samuel/experiment/3d/farm/frontend/node_modules/three-stdlib/webxr/XREstimatedLight.js"],"sourcesContent":["import { Group, LightProbe, DirectionalLight, WebGLCubeRenderTarget } from 'three';\n\nclass SessionLightProbe {\n  constructor(xrLight, renderer, lightProbe, environmentEstimation, estimationStartCallback) {\n    this.xrLight = xrLight;\n    this.renderer = renderer;\n    this.lightProbe = lightProbe;\n    this.xrWebGLBinding = null;\n    this.estimationStartCallback = estimationStartCallback;\n    this.frameCallback = this.onXRFrame.bind(this);\n    const session = renderer.xr.getSession(); // If the XRWebGLBinding class is available then we can also query an\n    // estimated reflection cube map.\n\n    if (environmentEstimation && 'XRWebGLBinding' in window) {\n      // This is the simplest way I know of to initialize a WebGL cubemap in Three.\n      const cubeRenderTarget = new WebGLCubeRenderTarget(16);\n      xrLight.environment = cubeRenderTarget.texture;\n      const gl = renderer.getContext(); // Ensure that we have any extensions needed to use the preferred cube map format.\n\n      switch (session.preferredReflectionFormat) {\n        case 'srgba8':\n          gl.getExtension('EXT_sRGB');\n          break;\n\n        case 'rgba16f':\n          gl.getExtension('OES_texture_half_float');\n          break;\n      }\n\n      this.xrWebGLBinding = new XRWebGLBinding(session, gl);\n      this.lightProbe.addEventListener('reflectionchange', () => {\n        this.updateReflection();\n      });\n    } // Start monitoring the XR animation frame loop to look for lighting\n    // estimation changes.\n\n\n    session.requestAnimationFrame(this.frameCallback);\n  }\n\n  updateReflection() {\n    const textureProperties = this.renderer.properties.get(this.xrLight.environment);\n\n    if (textureProperties) {\n      const cubeMap = this.xrWebGLBinding.getReflectionCubeMap(this.lightProbe);\n\n      if (cubeMap) {\n        textureProperties.__webglTexture = cubeMap;\n        this.xrLight.environment.needsPMREMUpdate = true;\n      }\n    }\n  }\n\n  onXRFrame(time, xrFrame) {\n    // If either this obejct or the XREstimatedLight has been destroyed, stop\n    // running the frame loop.\n    if (!this.xrLight) {\n      return;\n    }\n\n    const session = xrFrame.session;\n    session.requestAnimationFrame(this.frameCallback);\n    const lightEstimate = xrFrame.getLightEstimate(this.lightProbe);\n\n    if (lightEstimate) {\n      // We can copy the estimate's spherical harmonics array directly into the light probe.\n      this.xrLight.lightProbe.sh.fromArray(lightEstimate.sphericalHarmonicsCoefficients);\n      this.xrLight.lightProbe.intensity = 1.0; // For the directional light we have to normalize the color and set the scalar as the\n      // intensity, since WebXR can return color values that exceed 1.0.\n\n      const intensityScalar = Math.max(1.0, Math.max(lightEstimate.primaryLightIntensity.x, Math.max(lightEstimate.primaryLightIntensity.y, lightEstimate.primaryLightIntensity.z)));\n      this.xrLight.directionalLight.color.setRGB(lightEstimate.primaryLightIntensity.x / intensityScalar, lightEstimate.primaryLightIntensity.y / intensityScalar, lightEstimate.primaryLightIntensity.z / intensityScalar);\n      this.xrLight.directionalLight.intensity = intensityScalar;\n      this.xrLight.directionalLight.position.copy(lightEstimate.primaryLightDirection);\n\n      if (this.estimationStartCallback) {\n        this.estimationStartCallback();\n        this.estimationStartCallback = null;\n      }\n    }\n  }\n\n  dispose() {\n    this.xrLight = null;\n    this.renderer = null;\n    this.lightProbe = null;\n    this.xrWebGLBinding = null;\n  }\n\n}\n\nclass XREstimatedLight extends Group {\n  constructor(renderer, environmentEstimation = true) {\n    super();\n    this.lightProbe = new LightProbe();\n    this.lightProbe.intensity = 0;\n    this.add(this.lightProbe);\n    this.directionalLight = new DirectionalLight();\n    this.directionalLight.intensity = 0;\n    this.add(this.directionalLight); // Will be set to a cube map in the SessionLightProbe is environment estimation is\n    // available and requested.\n\n    this.environment = null;\n    let sessionLightProbe = null;\n    let estimationStarted = false;\n    renderer.xr.addEventListener('sessionstart', () => {\n      const session = renderer.xr.getSession();\n\n      if ('requestLightProbe' in session) {\n        session.requestLightProbe({\n          reflectionFormat: session.preferredReflectionFormat\n        }).then(probe => {\n          sessionLightProbe = new SessionLightProbe(this, renderer, probe, environmentEstimation, () => {\n            estimationStarted = true; // Fired to indicate that the estimated lighting values are now being updated.\n\n            this.dispatchEvent({\n              type: 'estimationstart'\n            });\n          });\n        });\n      }\n    });\n    renderer.xr.addEventListener('sessionend', () => {\n      if (sessionLightProbe) {\n        sessionLightProbe.dispose();\n        sessionLightProbe = null;\n      }\n\n      if (estimationStarted) {\n        // Fired to indicate that the estimated lighting values are no longer being updated.\n        this.dispatchEvent({\n          type: 'estimationend'\n        });\n      }\n    }); // Done inline to provide access to sessionLightProbe.\n\n    this.dispose = () => {\n      if (sessionLightProbe) {\n        sessionLightProbe.dispose();\n        sessionLightProbe = null;\n      }\n\n      this.remove(this.lightProbe);\n      this.lightProbe = null;\n      this.remove(this.directionalLight);\n      this.directionalLight = null;\n      this.environment = null;\n    };\n  }\n\n}\n\nexport { XREstimatedLight };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}