{"ast":null,"code":"import _classCallCheck from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Loader, FileLoader, BufferGeometry, BufferAttribute } from 'three';\nvar _taskCache = new WeakMap();\nvar DRACOLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(DRACOLoader, _Loader);\n  var _super = _createSuper(DRACOLoader);\n  function DRACOLoader(manager) {\n    var _this;\n    _classCallCheck(this, DRACOLoader);\n    _this = _super.call(this, manager);\n    _this.decoderPath = '';\n    _this.decoderConfig = {};\n    _this.decoderBinary = null;\n    _this.decoderPending = null;\n    _this.workerLimit = 4;\n    _this.workerPool = [];\n    _this.workerNextTaskID = 1;\n    _this.workerSourceURL = '';\n    _this.defaultAttributeIDs = {\n      position: 'POSITION',\n      normal: 'NORMAL',\n      color: 'COLOR',\n      uv: 'TEX_COORD'\n    };\n    _this.defaultAttributeTypes = {\n      position: 'Float32Array',\n      normal: 'Float32Array',\n      color: 'Float32Array',\n      uv: 'Float32Array'\n    };\n    return _this;\n  }\n  _createClass(DRACOLoader, [{\n    key: \"setDecoderPath\",\n    value: function setDecoderPath(path) {\n      this.decoderPath = path;\n      return this;\n    }\n  }, {\n    key: \"setDecoderConfig\",\n    value: function setDecoderConfig(config) {\n      this.decoderConfig = config;\n      return this;\n    }\n  }, {\n    key: \"setWorkerLimit\",\n    value: function setWorkerLimit(workerLimit) {\n      this.workerLimit = workerLimit;\n      return this;\n    }\n  }, {\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var _this2 = this;\n      var loader = new FileLoader(this.manager);\n      loader.setPath(this.path);\n      loader.setResponseType('arraybuffer');\n      loader.setRequestHeader(this.requestHeader);\n      loader.setWithCredentials(this.withCredentials);\n      loader.load(url, function (buffer) {\n        var taskConfig = {\n          attributeIDs: _this2.defaultAttributeIDs,\n          attributeTypes: _this2.defaultAttributeTypes,\n          useUniqueIDs: false\n        };\n        _this2.decodeGeometry(buffer, taskConfig).then(onLoad).catch(onError);\n      }, onProgress, onError);\n    }\n    /** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */\n  }, {\n    key: \"decodeDracoFile\",\n    value: function decodeDracoFile(buffer, callback, attributeIDs, attributeTypes) {\n      var taskConfig = {\n        attributeIDs: attributeIDs || this.defaultAttributeIDs,\n        attributeTypes: attributeTypes || this.defaultAttributeTypes,\n        useUniqueIDs: !!attributeIDs\n      };\n      this.decodeGeometry(buffer, taskConfig).then(callback);\n    }\n  }, {\n    key: \"decodeGeometry\",\n    value: function decodeGeometry(buffer, taskConfig) {\n      var _this3 = this;\n      // TODO: For backward-compatibility, support 'attributeTypes' objects containing\n      // references (rather than names) to typed array constructors. These must be\n      // serialized before sending them to the worker.\n      for (var attribute in taskConfig.attributeTypes) {\n        var type = taskConfig.attributeTypes[attribute];\n        if (type.BYTES_PER_ELEMENT !== undefined) {\n          taskConfig.attributeTypes[attribute] = type.name;\n        }\n      } //\n\n      var taskKey = JSON.stringify(taskConfig); // Check for an existing task using this buffer. A transferred buffer cannot be transferred\n      // again from this thread.\n\n      if (_taskCache.has(buffer)) {\n        var cachedTask = _taskCache.get(buffer);\n        if (cachedTask.key === taskKey) {\n          return cachedTask.promise;\n        } else if (buffer.byteLength === 0) {\n          // Technically, it would be possible to wait for the previous task to complete,\n          // transfer the buffer back, and decode again with the second configuration. That\n          // is complex, and I don't know of any reason to decode a Draco buffer twice in\n          // different ways, so this is left unimplemented.\n          throw new Error('THREE.DRACOLoader: Unable to re-decode a buffer with different ' + 'settings. Buffer has already been transferred.');\n        }\n      } //\n\n      var worker;\n      var taskID = this.workerNextTaskID++;\n      var taskCost = buffer.byteLength; // Obtain a worker and assign a task, and construct a geometry instance\n      // when the task completes.\n\n      var geometryPending = this._getWorker(taskID, taskCost).then(function (_worker) {\n        worker = _worker;\n        return new Promise(function (resolve, reject) {\n          worker._callbacks[taskID] = {\n            resolve: resolve,\n            reject: reject\n          };\n          worker.postMessage({\n            type: 'decode',\n            id: taskID,\n            taskConfig: taskConfig,\n            buffer: buffer\n          }, [buffer]); // this.debug();\n        });\n      }).then(function (message) {\n        return _this3._createGeometry(message.geometry);\n      }); // Remove task from the task list.\n      // Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)\n\n      geometryPending.catch(function () {\n        return true;\n      }).then(function () {\n        if (worker && taskID) {\n          _this3._releaseTask(worker, taskID); // this.debug();\n        }\n      }); // Cache the task result.\n\n      _taskCache.set(buffer, {\n        key: taskKey,\n        promise: geometryPending\n      });\n      return geometryPending;\n    }\n  }, {\n    key: \"_createGeometry\",\n    value: function _createGeometry(geometryData) {\n      var geometry = new BufferGeometry();\n      if (geometryData.index) {\n        geometry.setIndex(new BufferAttribute(geometryData.index.array, 1));\n      }\n      for (var i = 0; i < geometryData.attributes.length; i++) {\n        var attribute = geometryData.attributes[i];\n        var name = attribute.name;\n        var array = attribute.array;\n        var itemSize = attribute.itemSize;\n        geometry.setAttribute(name, new BufferAttribute(array, itemSize));\n      }\n      return geometry;\n    }\n  }, {\n    key: \"_loadLibrary\",\n    value: function _loadLibrary(url, responseType) {\n      var loader = new FileLoader(this.manager);\n      loader.setPath(this.decoderPath);\n      loader.setResponseType(responseType);\n      loader.setWithCredentials(this.withCredentials);\n      return new Promise(function (resolve, reject) {\n        loader.load(url, resolve, undefined, reject);\n      });\n    }\n  }, {\n    key: \"preload\",\n    value: function preload() {\n      this._initDecoder();\n      return this;\n    }\n  }, {\n    key: \"_initDecoder\",\n    value: function _initDecoder() {\n      var _this4 = this;\n      if (this.decoderPending) return this.decoderPending;\n      var useJS = typeof WebAssembly !== 'object' || this.decoderConfig.type === 'js';\n      var librariesPending = [];\n      if (useJS) {\n        librariesPending.push(this._loadLibrary('draco_decoder.js', 'text'));\n      } else {\n        librariesPending.push(this._loadLibrary('draco_wasm_wrapper.js', 'text'));\n        librariesPending.push(this._loadLibrary('draco_decoder.wasm', 'arraybuffer'));\n      }\n      this.decoderPending = Promise.all(librariesPending).then(function (libraries) {\n        var jsContent = libraries[0];\n        if (!useJS) {\n          _this4.decoderConfig.wasmBinary = libraries[1];\n        }\n        var fn = DRACOWorker.toString();\n        var body = ['/* draco decoder */', jsContent, '', '/* worker */', fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}'))].join('\\n');\n        _this4.workerSourceURL = URL.createObjectURL(new Blob([body]));\n      });\n      return this.decoderPending;\n    }\n  }, {\n    key: \"_getWorker\",\n    value: function _getWorker(taskID, taskCost) {\n      var _this5 = this;\n      return this._initDecoder().then(function () {\n        if (_this5.workerPool.length < _this5.workerLimit) {\n          var _worker2 = new Worker(_this5.workerSourceURL);\n          _worker2._callbacks = {};\n          _worker2._taskCosts = {};\n          _worker2._taskLoad = 0;\n          _worker2.postMessage({\n            type: 'init',\n            decoderConfig: _this5.decoderConfig\n          });\n          _worker2.onmessage = function (e) {\n            var message = e.data;\n            switch (message.type) {\n              case 'decode':\n                _worker2._callbacks[message.id].resolve(message);\n                break;\n              case 'error':\n                _worker2._callbacks[message.id].reject(message);\n                break;\n              default:\n                console.error('THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"');\n            }\n          };\n          _this5.workerPool.push(_worker2);\n        } else {\n          _this5.workerPool.sort(function (a, b) {\n            return a._taskLoad > b._taskLoad ? -1 : 1;\n          });\n        }\n        var worker = _this5.workerPool[_this5.workerPool.length - 1];\n        worker._taskCosts[taskID] = taskCost;\n        worker._taskLoad += taskCost;\n        return worker;\n      });\n    }\n  }, {\n    key: \"_releaseTask\",\n    value: function _releaseTask(worker, taskID) {\n      worker._taskLoad -= worker._taskCosts[taskID];\n      delete worker._callbacks[taskID];\n      delete worker._taskCosts[taskID];\n    }\n  }, {\n    key: \"debug\",\n    value: function debug() {\n      console.log('Task load: ', this.workerPool.map(function (worker) {\n        return worker._taskLoad;\n      }));\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      for (var i = 0; i < this.workerPool.length; ++i) {\n        this.workerPool[i].terminate();\n      }\n      this.workerPool.length = 0;\n      return this;\n    }\n  }]);\n  return DRACOLoader;\n}(Loader);\n/* WEB WORKER */\nfunction DRACOWorker() {\n  var decoderConfig;\n  var decoderPending;\n  onmessage = function onmessage(e) {\n    var message = e.data;\n    switch (message.type) {\n      case 'init':\n        decoderConfig = message.decoderConfig;\n        decoderPending = new Promise(function (resolve\n        /*, reject*/) {\n          decoderConfig.onModuleLoaded = function (draco) {\n            // Module is Promise-like. Wrap before resolving to avoid loop.\n            resolve({\n              draco: draco\n            });\n          };\n          DracoDecoderModule(decoderConfig); // eslint-disable-line no-undef\n        });\n\n        break;\n      case 'decode':\n        var buffer = message.buffer;\n        var taskConfig = message.taskConfig;\n        decoderPending.then(function (module) {\n          var draco = module.draco;\n          var decoder = new draco.Decoder();\n          var decoderBuffer = new draco.DecoderBuffer();\n          decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);\n          try {\n            var geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);\n            var buffers = geometry.attributes.map(function (attr) {\n              return attr.array.buffer;\n            });\n            if (geometry.index) buffers.push(geometry.index.array.buffer);\n            self.postMessage({\n              type: 'decode',\n              id: message.id,\n              geometry: geometry\n            }, buffers);\n          } catch (error) {\n            console.error(error);\n            self.postMessage({\n              type: 'error',\n              id: message.id,\n              error: error.message\n            });\n          } finally {\n            draco.destroy(decoderBuffer);\n            draco.destroy(decoder);\n          }\n        });\n        break;\n    }\n  };\n  function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n    var attributeIDs = taskConfig.attributeIDs;\n    var attributeTypes = taskConfig.attributeTypes;\n    var dracoGeometry;\n    var decodingStatus;\n    var geometryType = decoder.GetEncodedGeometryType(decoderBuffer);\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      dracoGeometry = new draco.Mesh();\n      decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);\n    } else if (geometryType === draco.POINT_CLOUD) {\n      dracoGeometry = new draco.PointCloud();\n      decodingStatus = decoder.DecodeBufferToPointCloud(decoderBuffer, dracoGeometry);\n    } else {\n      throw new Error('THREE.DRACOLoader: Unexpected geometry type.');\n    }\n    if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n      throw new Error('THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg());\n    }\n    var geometry = {\n      index: null,\n      attributes: []\n    }; // Gather all vertex attributes.\n\n    for (var attributeName in attributeIDs) {\n      var attributeType = self[attributeTypes[attributeName]];\n      var attribute = void 0;\n      var attributeID = void 0; // A Draco file may be created with default vertex attributes, whose attribute IDs\n      // are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,\n      // a Draco file may contain a custom set of attributes, identified by known unique\n      // IDs. glTF files always do the latter, and `.drc` files typically do the former.\n\n      if (taskConfig.useUniqueIDs) {\n        attributeID = attributeIDs[attributeName];\n        attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);\n      } else {\n        attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);\n        if (attributeID === -1) continue;\n        attribute = decoder.GetAttribute(dracoGeometry, attributeID);\n      }\n      geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));\n    } // Add index.\n\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      geometry.index = decodeIndex(draco, decoder, dracoGeometry);\n    }\n    draco.destroy(dracoGeometry);\n    return geometry;\n  }\n  function decodeIndex(draco, decoder, dracoGeometry) {\n    var numFaces = dracoGeometry.num_faces();\n    var numIndices = numFaces * 3;\n    var byteLength = numIndices * 4;\n    var ptr = draco._malloc(byteLength);\n    decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\n    var index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();\n    draco._free(ptr);\n    return {\n      array: index,\n      itemSize: 1\n    };\n  }\n  function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n    var numComponents = attribute.num_components();\n    var numPoints = dracoGeometry.num_points();\n    var numValues = numPoints * numComponents;\n    var byteLength = numValues * attributeType.BYTES_PER_ELEMENT;\n    var dataType = getDracoDataType(draco, attributeType);\n    var ptr = draco._malloc(byteLength);\n    decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);\n    var array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();\n    draco._free(ptr);\n    return {\n      name: attributeName,\n      array: array,\n      itemSize: numComponents\n    };\n  }\n  function getDracoDataType(draco, attributeType) {\n    switch (attributeType) {\n      case Float32Array:\n        return draco.DT_FLOAT32;\n      case Int8Array:\n        return draco.DT_INT8;\n      case Int16Array:\n        return draco.DT_INT16;\n      case Int32Array:\n        return draco.DT_INT32;\n      case Uint8Array:\n        return draco.DT_UINT8;\n      case Uint16Array:\n        return draco.DT_UINT16;\n      case Uint32Array:\n        return draco.DT_UINT32;\n    }\n  }\n}\nexport { DRACOLoader };","map":{"version":3,"names":["Loader","FileLoader","BufferGeometry","BufferAttribute","_taskCache","WeakMap","DRACOLoader","_Loader","_inherits","_super","_createSuper","manager","_this","_classCallCheck","call","decoderPath","decoderConfig","decoderBinary","decoderPending","workerLimit","workerPool","workerNextTaskID","workerSourceURL","defaultAttributeIDs","position","normal","color","uv","defaultAttributeTypes","_createClass","key","value","setDecoderPath","path","setDecoderConfig","config","setWorkerLimit","load","url","onLoad","onProgress","onError","_this2","loader","setPath","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","buffer","taskConfig","attributeIDs","attributeTypes","useUniqueIDs","decodeGeometry","then","catch","decodeDracoFile","callback","_this3","attribute","type","BYTES_PER_ELEMENT","undefined","name","taskKey","JSON","stringify","has","cachedTask","get","promise","byteLength","Error","worker","taskID","taskCost","geometryPending","_getWorker","_worker","Promise","resolve","reject","_callbacks","postMessage","id","message","_createGeometry","geometry","_releaseTask","set","geometryData","index","setIndex","array","i","attributes","length","itemSize","setAttribute","_loadLibrary","responseType","preload","_initDecoder","_this4","useJS","WebAssembly","librariesPending","push","all","libraries","jsContent","wasmBinary","fn","DRACOWorker","toString","body","substring","indexOf","lastIndexOf","join","URL","createObjectURL","Blob","_this5","Worker","_taskCosts","_taskLoad","onmessage","e","data","console","error","sort","a","b","debug","log","map","dispose","terminate","onModuleLoaded","draco","DracoDecoderModule","module","decoder","Decoder","decoderBuffer","DecoderBuffer","Init","Int8Array","buffers","attr","self","destroy","dracoGeometry","decodingStatus","geometryType","GetEncodedGeometryType","TRIANGULAR_MESH","Mesh","DecodeBufferToMesh","POINT_CLOUD","PointCloud","DecodeBufferToPointCloud","ok","ptr","error_msg","attributeName","attributeType","attributeID","GetAttributeByUniqueId","GetAttributeId","GetAttribute","decodeAttribute","decodeIndex","numFaces","num_faces","numIndices","_malloc","GetTrianglesUInt32Array","Uint32Array","HEAPF32","slice","_free","numComponents","num_components","numPoints","num_points","numValues","dataType","getDracoDataType","GetAttributeDataArrayForAllPoints","Float32Array","DT_FLOAT32","DT_INT8","Int16Array","DT_INT16","Int32Array","DT_INT32","Uint8Array","DT_UINT8","Uint16Array","DT_UINT16","DT_UINT32"],"sources":["/home/samuel/experiment/3d/farm/frontend/node_modules/three-stdlib/loaders/DRACOLoader.js"],"sourcesContent":["import { Loader, FileLoader, BufferGeometry, BufferAttribute } from 'three';\n\nconst _taskCache = new WeakMap();\n\nclass DRACOLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.decoderPath = '';\n    this.decoderConfig = {};\n    this.decoderBinary = null;\n    this.decoderPending = null;\n    this.workerLimit = 4;\n    this.workerPool = [];\n    this.workerNextTaskID = 1;\n    this.workerSourceURL = '';\n    this.defaultAttributeIDs = {\n      position: 'POSITION',\n      normal: 'NORMAL',\n      color: 'COLOR',\n      uv: 'TEX_COORD'\n    };\n    this.defaultAttributeTypes = {\n      position: 'Float32Array',\n      normal: 'Float32Array',\n      color: 'Float32Array',\n      uv: 'Float32Array'\n    };\n  }\n\n  setDecoderPath(path) {\n    this.decoderPath = path;\n    return this;\n  }\n\n  setDecoderConfig(config) {\n    this.decoderConfig = config;\n    return this;\n  }\n\n  setWorkerLimit(workerLimit) {\n    this.workerLimit = workerLimit;\n    return this;\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, buffer => {\n      const taskConfig = {\n        attributeIDs: this.defaultAttributeIDs,\n        attributeTypes: this.defaultAttributeTypes,\n        useUniqueIDs: false\n      };\n      this.decodeGeometry(buffer, taskConfig).then(onLoad).catch(onError);\n    }, onProgress, onError);\n  }\n  /** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */\n\n\n  decodeDracoFile(buffer, callback, attributeIDs, attributeTypes) {\n    const taskConfig = {\n      attributeIDs: attributeIDs || this.defaultAttributeIDs,\n      attributeTypes: attributeTypes || this.defaultAttributeTypes,\n      useUniqueIDs: !!attributeIDs\n    };\n    this.decodeGeometry(buffer, taskConfig).then(callback);\n  }\n\n  decodeGeometry(buffer, taskConfig) {\n    // TODO: For backward-compatibility, support 'attributeTypes' objects containing\n    // references (rather than names) to typed array constructors. These must be\n    // serialized before sending them to the worker.\n    for (const attribute in taskConfig.attributeTypes) {\n      const type = taskConfig.attributeTypes[attribute];\n\n      if (type.BYTES_PER_ELEMENT !== undefined) {\n        taskConfig.attributeTypes[attribute] = type.name;\n      }\n    } //\n\n\n    const taskKey = JSON.stringify(taskConfig); // Check for an existing task using this buffer. A transferred buffer cannot be transferred\n    // again from this thread.\n\n    if (_taskCache.has(buffer)) {\n      const cachedTask = _taskCache.get(buffer);\n\n      if (cachedTask.key === taskKey) {\n        return cachedTask.promise;\n      } else if (buffer.byteLength === 0) {\n        // Technically, it would be possible to wait for the previous task to complete,\n        // transfer the buffer back, and decode again with the second configuration. That\n        // is complex, and I don't know of any reason to decode a Draco buffer twice in\n        // different ways, so this is left unimplemented.\n        throw new Error('THREE.DRACOLoader: Unable to re-decode a buffer with different ' + 'settings. Buffer has already been transferred.');\n      }\n    } //\n\n\n    let worker;\n    const taskID = this.workerNextTaskID++;\n    const taskCost = buffer.byteLength; // Obtain a worker and assign a task, and construct a geometry instance\n    // when the task completes.\n\n    const geometryPending = this._getWorker(taskID, taskCost).then(_worker => {\n      worker = _worker;\n      return new Promise((resolve, reject) => {\n        worker._callbacks[taskID] = {\n          resolve,\n          reject\n        };\n        worker.postMessage({\n          type: 'decode',\n          id: taskID,\n          taskConfig,\n          buffer\n        }, [buffer]); // this.debug();\n      });\n    }).then(message => this._createGeometry(message.geometry)); // Remove task from the task list.\n    // Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)\n\n\n    geometryPending.catch(() => true).then(() => {\n      if (worker && taskID) {\n        this._releaseTask(worker, taskID); // this.debug();\n\n      }\n    }); // Cache the task result.\n\n    _taskCache.set(buffer, {\n      key: taskKey,\n      promise: geometryPending\n    });\n\n    return geometryPending;\n  }\n\n  _createGeometry(geometryData) {\n    const geometry = new BufferGeometry();\n\n    if (geometryData.index) {\n      geometry.setIndex(new BufferAttribute(geometryData.index.array, 1));\n    }\n\n    for (let i = 0; i < geometryData.attributes.length; i++) {\n      const attribute = geometryData.attributes[i];\n      const name = attribute.name;\n      const array = attribute.array;\n      const itemSize = attribute.itemSize;\n      geometry.setAttribute(name, new BufferAttribute(array, itemSize));\n    }\n\n    return geometry;\n  }\n\n  _loadLibrary(url, responseType) {\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.decoderPath);\n    loader.setResponseType(responseType);\n    loader.setWithCredentials(this.withCredentials);\n    return new Promise((resolve, reject) => {\n      loader.load(url, resolve, undefined, reject);\n    });\n  }\n\n  preload() {\n    this._initDecoder();\n\n    return this;\n  }\n\n  _initDecoder() {\n    if (this.decoderPending) return this.decoderPending;\n    const useJS = typeof WebAssembly !== 'object' || this.decoderConfig.type === 'js';\n    const librariesPending = [];\n\n    if (useJS) {\n      librariesPending.push(this._loadLibrary('draco_decoder.js', 'text'));\n    } else {\n      librariesPending.push(this._loadLibrary('draco_wasm_wrapper.js', 'text'));\n      librariesPending.push(this._loadLibrary('draco_decoder.wasm', 'arraybuffer'));\n    }\n\n    this.decoderPending = Promise.all(librariesPending).then(libraries => {\n      const jsContent = libraries[0];\n\n      if (!useJS) {\n        this.decoderConfig.wasmBinary = libraries[1];\n      }\n\n      const fn = DRACOWorker.toString();\n      const body = ['/* draco decoder */', jsContent, '', '/* worker */', fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}'))].join('\\n');\n      this.workerSourceURL = URL.createObjectURL(new Blob([body]));\n    });\n    return this.decoderPending;\n  }\n\n  _getWorker(taskID, taskCost) {\n    return this._initDecoder().then(() => {\n      if (this.workerPool.length < this.workerLimit) {\n        const worker = new Worker(this.workerSourceURL);\n        worker._callbacks = {};\n        worker._taskCosts = {};\n        worker._taskLoad = 0;\n        worker.postMessage({\n          type: 'init',\n          decoderConfig: this.decoderConfig\n        });\n\n        worker.onmessage = function (e) {\n          const message = e.data;\n\n          switch (message.type) {\n            case 'decode':\n              worker._callbacks[message.id].resolve(message);\n\n              break;\n\n            case 'error':\n              worker._callbacks[message.id].reject(message);\n\n              break;\n\n            default:\n              console.error('THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"');\n          }\n        };\n\n        this.workerPool.push(worker);\n      } else {\n        this.workerPool.sort(function (a, b) {\n          return a._taskLoad > b._taskLoad ? -1 : 1;\n        });\n      }\n\n      const worker = this.workerPool[this.workerPool.length - 1];\n      worker._taskCosts[taskID] = taskCost;\n      worker._taskLoad += taskCost;\n      return worker;\n    });\n  }\n\n  _releaseTask(worker, taskID) {\n    worker._taskLoad -= worker._taskCosts[taskID];\n    delete worker._callbacks[taskID];\n    delete worker._taskCosts[taskID];\n  }\n\n  debug() {\n    console.log('Task load: ', this.workerPool.map(worker => worker._taskLoad));\n  }\n\n  dispose() {\n    for (let i = 0; i < this.workerPool.length; ++i) {\n      this.workerPool[i].terminate();\n    }\n\n    this.workerPool.length = 0;\n    return this;\n  }\n\n}\n/* WEB WORKER */\n\n\nfunction DRACOWorker() {\n  let decoderConfig;\n  let decoderPending;\n\n  onmessage = function (e) {\n    const message = e.data;\n\n    switch (message.type) {\n      case 'init':\n        decoderConfig = message.decoderConfig;\n        decoderPending = new Promise(function (resolve\n        /*, reject*/\n        ) {\n          decoderConfig.onModuleLoaded = function (draco) {\n            // Module is Promise-like. Wrap before resolving to avoid loop.\n            resolve({\n              draco: draco\n            });\n          };\n\n          DracoDecoderModule(decoderConfig); // eslint-disable-line no-undef\n        });\n        break;\n\n      case 'decode':\n        const buffer = message.buffer;\n        const taskConfig = message.taskConfig;\n        decoderPending.then(module => {\n          const draco = module.draco;\n          const decoder = new draco.Decoder();\n          const decoderBuffer = new draco.DecoderBuffer();\n          decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);\n\n          try {\n            const geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);\n            const buffers = geometry.attributes.map(attr => attr.array.buffer);\n            if (geometry.index) buffers.push(geometry.index.array.buffer);\n            self.postMessage({\n              type: 'decode',\n              id: message.id,\n              geometry\n            }, buffers);\n          } catch (error) {\n            console.error(error);\n            self.postMessage({\n              type: 'error',\n              id: message.id,\n              error: error.message\n            });\n          } finally {\n            draco.destroy(decoderBuffer);\n            draco.destroy(decoder);\n          }\n        });\n        break;\n    }\n  };\n\n  function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n    const attributeIDs = taskConfig.attributeIDs;\n    const attributeTypes = taskConfig.attributeTypes;\n    let dracoGeometry;\n    let decodingStatus;\n    const geometryType = decoder.GetEncodedGeometryType(decoderBuffer);\n\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      dracoGeometry = new draco.Mesh();\n      decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);\n    } else if (geometryType === draco.POINT_CLOUD) {\n      dracoGeometry = new draco.PointCloud();\n      decodingStatus = decoder.DecodeBufferToPointCloud(decoderBuffer, dracoGeometry);\n    } else {\n      throw new Error('THREE.DRACOLoader: Unexpected geometry type.');\n    }\n\n    if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n      throw new Error('THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg());\n    }\n\n    const geometry = {\n      index: null,\n      attributes: []\n    }; // Gather all vertex attributes.\n\n    for (const attributeName in attributeIDs) {\n      const attributeType = self[attributeTypes[attributeName]];\n      let attribute;\n      let attributeID; // A Draco file may be created with default vertex attributes, whose attribute IDs\n      // are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,\n      // a Draco file may contain a custom set of attributes, identified by known unique\n      // IDs. glTF files always do the latter, and `.drc` files typically do the former.\n\n      if (taskConfig.useUniqueIDs) {\n        attributeID = attributeIDs[attributeName];\n        attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);\n      } else {\n        attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);\n        if (attributeID === -1) continue;\n        attribute = decoder.GetAttribute(dracoGeometry, attributeID);\n      }\n\n      geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));\n    } // Add index.\n\n\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      geometry.index = decodeIndex(draco, decoder, dracoGeometry);\n    }\n\n    draco.destroy(dracoGeometry);\n    return geometry;\n  }\n\n  function decodeIndex(draco, decoder, dracoGeometry) {\n    const numFaces = dracoGeometry.num_faces();\n    const numIndices = numFaces * 3;\n    const byteLength = numIndices * 4;\n\n    const ptr = draco._malloc(byteLength);\n\n    decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\n    const index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();\n\n    draco._free(ptr);\n\n    return {\n      array: index,\n      itemSize: 1\n    };\n  }\n\n  function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n    const numComponents = attribute.num_components();\n    const numPoints = dracoGeometry.num_points();\n    const numValues = numPoints * numComponents;\n    const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;\n    const dataType = getDracoDataType(draco, attributeType);\n\n    const ptr = draco._malloc(byteLength);\n\n    decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);\n    const array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();\n\n    draco._free(ptr);\n\n    return {\n      name: attributeName,\n      array: array,\n      itemSize: numComponents\n    };\n  }\n\n  function getDracoDataType(draco, attributeType) {\n    switch (attributeType) {\n      case Float32Array:\n        return draco.DT_FLOAT32;\n\n      case Int8Array:\n        return draco.DT_INT8;\n\n      case Int16Array:\n        return draco.DT_INT16;\n\n      case Int32Array:\n        return draco.DT_INT32;\n\n      case Uint8Array:\n        return draco.DT_UINT8;\n\n      case Uint16Array:\n        return draco.DT_UINT16;\n\n      case Uint32Array:\n        return draco.DT_UINT32;\n    }\n  }\n}\n\nexport { DRACOLoader };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}