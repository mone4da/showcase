{"ast":null,"code":"import _classCallCheck from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Matrix4, Vector3, Box3, DirectionalLight, MathUtils, ShaderChunk, Vector2 } from 'three';\nimport { CSMFrustum } from './CSMFrustum.js';\nimport { CSMShader } from './CSMShader.js';\nvar _cameraToLightMatrix = new Matrix4();\nvar _lightSpaceFrustum = new CSMFrustum();\nvar _center = new Vector3();\nvar _bbox = new Box3();\nvar _uniformArray = [];\nvar _logArray = [];\nvar CSM = /*#__PURE__*/function () {\n  function CSM(data) {\n    _classCallCheck(this, CSM);\n    data = data || {};\n    this.camera = data.camera;\n    this.parent = data.parent;\n    this.cascades = data.cascades || 3;\n    this.maxFar = data.maxFar || 100000;\n    this.mode = data.mode || 'practical';\n    this.shadowMapSize = data.shadowMapSize || 2048;\n    this.shadowBias = data.shadowBias || 0.000001;\n    this.lightDirection = data.lightDirection || new Vector3(1, -1, 1).normalize();\n    this.lightIntensity = data.lightIntensity || 1;\n    this.lightNear = data.lightNear || 1;\n    this.lightFar = data.lightFar || 2000;\n    this.lightMargin = data.lightMargin || 200;\n    this.customSplitsCallback = data.customSplitsCallback;\n    this.fade = false;\n    this.mainFrustum = new CSMFrustum();\n    this.frustums = [];\n    this.breaks = [];\n    this.lights = [];\n    this.shaders = new Map();\n    this.createLights();\n    this.updateFrustums();\n    this.injectInclude();\n  }\n  _createClass(CSM, [{\n    key: \"createLights\",\n    value: function createLights() {\n      for (var i = 0; i < this.cascades; i++) {\n        var light = new DirectionalLight(0xffffff, this.lightIntensity);\n        light.castShadow = true;\n        light.shadow.mapSize.width = this.shadowMapSize;\n        light.shadow.mapSize.height = this.shadowMapSize;\n        light.shadow.camera.near = this.lightNear;\n        light.shadow.camera.far = this.lightFar;\n        light.shadow.bias = this.shadowBias;\n        this.parent.add(light);\n        this.parent.add(light.target);\n        this.lights.push(light);\n      }\n    }\n  }, {\n    key: \"initCascades\",\n    value: function initCascades() {\n      var camera = this.camera;\n      camera.updateProjectionMatrix();\n      this.mainFrustum.setFromProjectionMatrix(camera.projectionMatrix, this.maxFar);\n      this.mainFrustum.split(this.breaks, this.frustums);\n    }\n  }, {\n    key: \"updateShadowBounds\",\n    value: function updateShadowBounds() {\n      var frustums = this.frustums;\n      for (var i = 0; i < frustums.length; i++) {\n        var light = this.lights[i];\n        var shadowCam = light.shadow.camera;\n        var frustum = this.frustums[i]; // Get the two points that represent that furthest points on the frustum assuming\n        // that's either the diagonal across the far plane or the diagonal across the whole\n        // frustum itself.\n\n        var nearVerts = frustum.vertices.near;\n        var farVerts = frustum.vertices.far;\n        var point1 = farVerts[0];\n        var point2 = void 0;\n        if (point1.distanceTo(farVerts[2]) > point1.distanceTo(nearVerts[2])) {\n          point2 = farVerts[2];\n        } else {\n          point2 = nearVerts[2];\n        }\n        var squaredBBWidth = point1.distanceTo(point2);\n        if (this.fade) {\n          // expand the shadow extents by the fade margin if fade is enabled.\n          var camera = this.camera;\n          var far = Math.max(camera.far, this.maxFar);\n          var linearDepth = frustum.vertices.far[0].z / (far - camera.near);\n          var margin = 0.25 * Math.pow(linearDepth, 2.0) * (far - camera.near);\n          squaredBBWidth += margin;\n        }\n        shadowCam.left = -squaredBBWidth / 2;\n        shadowCam.right = squaredBBWidth / 2;\n        shadowCam.top = squaredBBWidth / 2;\n        shadowCam.bottom = -squaredBBWidth / 2;\n        shadowCam.updateProjectionMatrix();\n      }\n    }\n  }, {\n    key: \"getBreaks\",\n    value: function getBreaks() {\n      var camera = this.camera;\n      var far = Math.min(camera.far, this.maxFar);\n      this.breaks.length = 0;\n      switch (this.mode) {\n        case 'uniform':\n          uniformSplit(this.cascades, camera.near, far, this.breaks);\n          break;\n        case 'logarithmic':\n          logarithmicSplit(this.cascades, camera.near, far, this.breaks);\n          break;\n        case 'practical':\n          practicalSplit(this.cascades, camera.near, far, 0.5, this.breaks);\n          break;\n        case 'custom':\n          if (this.customSplitsCallback === undefined) console.error('CSM: Custom split scheme callback not defined.');\n          this.customSplitsCallback(this.cascades, camera.near, far, this.breaks);\n          break;\n      }\n      function uniformSplit(amount, near, far, target) {\n        for (var i = 1; i < amount; i++) {\n          target.push((near + (far - near) * i / amount) / far);\n        }\n        target.push(1);\n      }\n      function logarithmicSplit(amount, near, far, target) {\n        for (var i = 1; i < amount; i++) {\n          target.push(near * Math.pow(far / near, i / amount) / far);\n        }\n        target.push(1);\n      }\n      function practicalSplit(amount, near, far, lambda, target) {\n        _uniformArray.length = 0;\n        _logArray.length = 0;\n        logarithmicSplit(amount, near, far, _logArray);\n        uniformSplit(amount, near, far, _uniformArray);\n        for (var i = 1; i < amount; i++) {\n          target.push(MathUtils.lerp(_uniformArray[i - 1], _logArray[i - 1], lambda));\n        }\n        target.push(1);\n      }\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      var camera = this.camera;\n      var frustums = this.frustums;\n      for (var i = 0; i < frustums.length; i++) {\n        var light = this.lights[i];\n        var shadowCam = light.shadow.camera;\n        var texelWidth = (shadowCam.right - shadowCam.left) / this.shadowMapSize;\n        var texelHeight = (shadowCam.top - shadowCam.bottom) / this.shadowMapSize;\n        light.shadow.camera.updateMatrixWorld(true);\n        _cameraToLightMatrix.multiplyMatrices(light.shadow.camera.matrixWorldInverse, camera.matrixWorld);\n        frustums[i].toSpace(_cameraToLightMatrix, _lightSpaceFrustum);\n        var nearVerts = _lightSpaceFrustum.vertices.near;\n        var farVerts = _lightSpaceFrustum.vertices.far;\n        _bbox.makeEmpty();\n        for (var j = 0; j < 4; j++) {\n          _bbox.expandByPoint(nearVerts[j]);\n          _bbox.expandByPoint(farVerts[j]);\n        }\n        _bbox.getCenter(_center);\n        _center.z = _bbox.max.z + this.lightMargin;\n        _center.x = Math.floor(_center.x / texelWidth) * texelWidth;\n        _center.y = Math.floor(_center.y / texelHeight) * texelHeight;\n        _center.applyMatrix4(light.shadow.camera.matrixWorld);\n        light.position.copy(_center);\n        light.target.position.copy(_center);\n        light.target.position.x += this.lightDirection.x;\n        light.target.position.y += this.lightDirection.y;\n        light.target.position.z += this.lightDirection.z;\n      }\n    }\n  }, {\n    key: \"injectInclude\",\n    value: function injectInclude() {\n      ShaderChunk.lights_fragment_begin = CSMShader.lights_fragment_begin;\n      ShaderChunk.lights_pars_begin = CSMShader.lights_pars_begin;\n    }\n  }, {\n    key: \"setupMaterial\",\n    value: function setupMaterial(material) {\n      material.defines = material.defines || {};\n      material.defines.USE_CSM = 1;\n      material.defines.CSM_CASCADES = this.cascades;\n      if (this.fade) {\n        material.defines.CSM_FADE = '';\n      }\n      var breaksVec2 = [];\n      var scope = this;\n      var shaders = this.shaders;\n      material.onBeforeCompile = function (shader) {\n        var far = Math.min(scope.camera.far, scope.maxFar);\n        scope.getExtendedBreaks(breaksVec2);\n        shader.uniforms.CSM_cascades = {\n          value: breaksVec2\n        };\n        shader.uniforms.cameraNear = {\n          value: scope.camera.near\n        };\n        shader.uniforms.shadowFar = {\n          value: far\n        };\n        shaders.set(material, shader);\n      };\n      shaders.set(material, null);\n    }\n  }, {\n    key: \"updateUniforms\",\n    value: function updateUniforms() {\n      var far = Math.min(this.camera.far, this.maxFar);\n      var shaders = this.shaders;\n      shaders.forEach(function (shader, material) {\n        if (shader !== null) {\n          var uniforms = shader.uniforms;\n          this.getExtendedBreaks(uniforms.CSM_cascades.value);\n          uniforms.cameraNear.value = this.camera.near;\n          uniforms.shadowFar.value = far;\n        }\n        if (!this.fade && 'CSM_FADE' in material.defines) {\n          delete material.defines.CSM_FADE;\n          material.needsUpdate = true;\n        } else if (this.fade && !('CSM_FADE' in material.defines)) {\n          material.defines.CSM_FADE = '';\n          material.needsUpdate = true;\n        }\n      }, this);\n    }\n  }, {\n    key: \"getExtendedBreaks\",\n    value: function getExtendedBreaks(target) {\n      while (target.length < this.breaks.length) {\n        target.push(new Vector2());\n      }\n      target.length = this.breaks.length;\n      for (var i = 0; i < this.cascades; i++) {\n        var amount = this.breaks[i];\n        var prev = this.breaks[i - 1] || 0;\n        target[i].x = prev;\n        target[i].y = amount;\n      }\n    }\n  }, {\n    key: \"updateFrustums\",\n    value: function updateFrustums() {\n      this.getBreaks();\n      this.initCascades();\n      this.updateShadowBounds();\n      this.updateUniforms();\n    }\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      for (var i = 0; i < this.lights.length; i++) {\n        this.parent.remove(this.lights[i]);\n      }\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      var shaders = this.shaders;\n      shaders.forEach(function (shader, material) {\n        delete material.onBeforeCompile;\n        delete material.defines.USE_CSM;\n        delete material.defines.CSM_CASCADES;\n        delete material.defines.CSM_FADE;\n        if (shader !== null) {\n          delete shader.uniforms.CSM_cascades;\n          delete shader.uniforms.cameraNear;\n          delete shader.uniforms.shadowFar;\n        }\n        material.needsUpdate = true;\n      });\n      shaders.clear();\n    }\n  }]);\n  return CSM;\n}();\nexport { CSM };","map":{"version":3,"names":["Matrix4","Vector3","Box3","DirectionalLight","MathUtils","ShaderChunk","Vector2","CSMFrustum","CSMShader","_cameraToLightMatrix","_lightSpaceFrustum","_center","_bbox","_uniformArray","_logArray","CSM","data","_classCallCheck","camera","parent","cascades","maxFar","mode","shadowMapSize","shadowBias","lightDirection","normalize","lightIntensity","lightNear","lightFar","lightMargin","customSplitsCallback","fade","mainFrustum","frustums","breaks","lights","shaders","Map","createLights","updateFrustums","injectInclude","_createClass","key","value","i","light","castShadow","shadow","mapSize","width","height","near","far","bias","add","target","push","initCascades","updateProjectionMatrix","setFromProjectionMatrix","projectionMatrix","split","updateShadowBounds","length","shadowCam","frustum","nearVerts","vertices","farVerts","point1","point2","distanceTo","squaredBBWidth","Math","max","linearDepth","z","margin","pow","left","right","top","bottom","getBreaks","min","uniformSplit","logarithmicSplit","practicalSplit","undefined","console","error","amount","lambda","lerp","update","texelWidth","texelHeight","updateMatrixWorld","multiplyMatrices","matrixWorldInverse","matrixWorld","toSpace","makeEmpty","j","expandByPoint","getCenter","x","floor","y","applyMatrix4","position","copy","lights_fragment_begin","lights_pars_begin","setupMaterial","material","defines","USE_CSM","CSM_CASCADES","CSM_FADE","breaksVec2","scope","onBeforeCompile","shader","getExtendedBreaks","uniforms","CSM_cascades","cameraNear","shadowFar","set","updateUniforms","forEach","needsUpdate","prev","remove","dispose","clear"],"sources":["/home/samuel/experiment/3d/farm/frontend/node_modules/three-stdlib/csm/CSM.js"],"sourcesContent":["import { Matrix4, Vector3, Box3, DirectionalLight, MathUtils, ShaderChunk, Vector2 } from 'three';\nimport { CSMFrustum } from './CSMFrustum.js';\nimport { CSMShader } from './CSMShader.js';\n\nconst _cameraToLightMatrix = new Matrix4();\n\nconst _lightSpaceFrustum = new CSMFrustum();\n\nconst _center = new Vector3();\n\nconst _bbox = new Box3();\n\nconst _uniformArray = [];\nconst _logArray = [];\nclass CSM {\n  constructor(data) {\n    data = data || {};\n    this.camera = data.camera;\n    this.parent = data.parent;\n    this.cascades = data.cascades || 3;\n    this.maxFar = data.maxFar || 100000;\n    this.mode = data.mode || 'practical';\n    this.shadowMapSize = data.shadowMapSize || 2048;\n    this.shadowBias = data.shadowBias || 0.000001;\n    this.lightDirection = data.lightDirection || new Vector3(1, -1, 1).normalize();\n    this.lightIntensity = data.lightIntensity || 1;\n    this.lightNear = data.lightNear || 1;\n    this.lightFar = data.lightFar || 2000;\n    this.lightMargin = data.lightMargin || 200;\n    this.customSplitsCallback = data.customSplitsCallback;\n    this.fade = false;\n    this.mainFrustum = new CSMFrustum();\n    this.frustums = [];\n    this.breaks = [];\n    this.lights = [];\n    this.shaders = new Map();\n    this.createLights();\n    this.updateFrustums();\n    this.injectInclude();\n  }\n\n  createLights() {\n    for (let i = 0; i < this.cascades; i++) {\n      const light = new DirectionalLight(0xffffff, this.lightIntensity);\n      light.castShadow = true;\n      light.shadow.mapSize.width = this.shadowMapSize;\n      light.shadow.mapSize.height = this.shadowMapSize;\n      light.shadow.camera.near = this.lightNear;\n      light.shadow.camera.far = this.lightFar;\n      light.shadow.bias = this.shadowBias;\n      this.parent.add(light);\n      this.parent.add(light.target);\n      this.lights.push(light);\n    }\n  }\n\n  initCascades() {\n    const camera = this.camera;\n    camera.updateProjectionMatrix();\n    this.mainFrustum.setFromProjectionMatrix(camera.projectionMatrix, this.maxFar);\n    this.mainFrustum.split(this.breaks, this.frustums);\n  }\n\n  updateShadowBounds() {\n    const frustums = this.frustums;\n\n    for (let i = 0; i < frustums.length; i++) {\n      const light = this.lights[i];\n      const shadowCam = light.shadow.camera;\n      const frustum = this.frustums[i]; // Get the two points that represent that furthest points on the frustum assuming\n      // that's either the diagonal across the far plane or the diagonal across the whole\n      // frustum itself.\n\n      const nearVerts = frustum.vertices.near;\n      const farVerts = frustum.vertices.far;\n      const point1 = farVerts[0];\n      let point2;\n\n      if (point1.distanceTo(farVerts[2]) > point1.distanceTo(nearVerts[2])) {\n        point2 = farVerts[2];\n      } else {\n        point2 = nearVerts[2];\n      }\n\n      let squaredBBWidth = point1.distanceTo(point2);\n\n      if (this.fade) {\n        // expand the shadow extents by the fade margin if fade is enabled.\n        const camera = this.camera;\n        const far = Math.max(camera.far, this.maxFar);\n        const linearDepth = frustum.vertices.far[0].z / (far - camera.near);\n        const margin = 0.25 * Math.pow(linearDepth, 2.0) * (far - camera.near);\n        squaredBBWidth += margin;\n      }\n\n      shadowCam.left = -squaredBBWidth / 2;\n      shadowCam.right = squaredBBWidth / 2;\n      shadowCam.top = squaredBBWidth / 2;\n      shadowCam.bottom = -squaredBBWidth / 2;\n      shadowCam.updateProjectionMatrix();\n    }\n  }\n\n  getBreaks() {\n    const camera = this.camera;\n    const far = Math.min(camera.far, this.maxFar);\n    this.breaks.length = 0;\n\n    switch (this.mode) {\n      case 'uniform':\n        uniformSplit(this.cascades, camera.near, far, this.breaks);\n        break;\n\n      case 'logarithmic':\n        logarithmicSplit(this.cascades, camera.near, far, this.breaks);\n        break;\n\n      case 'practical':\n        practicalSplit(this.cascades, camera.near, far, 0.5, this.breaks);\n        break;\n\n      case 'custom':\n        if (this.customSplitsCallback === undefined) console.error('CSM: Custom split scheme callback not defined.');\n        this.customSplitsCallback(this.cascades, camera.near, far, this.breaks);\n        break;\n    }\n\n    function uniformSplit(amount, near, far, target) {\n      for (let i = 1; i < amount; i++) {\n        target.push((near + (far - near) * i / amount) / far);\n      }\n\n      target.push(1);\n    }\n\n    function logarithmicSplit(amount, near, far, target) {\n      for (let i = 1; i < amount; i++) {\n        target.push(near * (far / near) ** (i / amount) / far);\n      }\n\n      target.push(1);\n    }\n\n    function practicalSplit(amount, near, far, lambda, target) {\n      _uniformArray.length = 0;\n      _logArray.length = 0;\n      logarithmicSplit(amount, near, far, _logArray);\n      uniformSplit(amount, near, far, _uniformArray);\n\n      for (let i = 1; i < amount; i++) {\n        target.push(MathUtils.lerp(_uniformArray[i - 1], _logArray[i - 1], lambda));\n      }\n\n      target.push(1);\n    }\n  }\n\n  update() {\n    const camera = this.camera;\n    const frustums = this.frustums;\n\n    for (let i = 0; i < frustums.length; i++) {\n      const light = this.lights[i];\n      const shadowCam = light.shadow.camera;\n      const texelWidth = (shadowCam.right - shadowCam.left) / this.shadowMapSize;\n      const texelHeight = (shadowCam.top - shadowCam.bottom) / this.shadowMapSize;\n      light.shadow.camera.updateMatrixWorld(true);\n\n      _cameraToLightMatrix.multiplyMatrices(light.shadow.camera.matrixWorldInverse, camera.matrixWorld);\n\n      frustums[i].toSpace(_cameraToLightMatrix, _lightSpaceFrustum);\n      const nearVerts = _lightSpaceFrustum.vertices.near;\n      const farVerts = _lightSpaceFrustum.vertices.far;\n\n      _bbox.makeEmpty();\n\n      for (let j = 0; j < 4; j++) {\n        _bbox.expandByPoint(nearVerts[j]);\n\n        _bbox.expandByPoint(farVerts[j]);\n      }\n\n      _bbox.getCenter(_center);\n\n      _center.z = _bbox.max.z + this.lightMargin;\n      _center.x = Math.floor(_center.x / texelWidth) * texelWidth;\n      _center.y = Math.floor(_center.y / texelHeight) * texelHeight;\n\n      _center.applyMatrix4(light.shadow.camera.matrixWorld);\n\n      light.position.copy(_center);\n      light.target.position.copy(_center);\n      light.target.position.x += this.lightDirection.x;\n      light.target.position.y += this.lightDirection.y;\n      light.target.position.z += this.lightDirection.z;\n    }\n  }\n\n  injectInclude() {\n    ShaderChunk.lights_fragment_begin = CSMShader.lights_fragment_begin;\n    ShaderChunk.lights_pars_begin = CSMShader.lights_pars_begin;\n  }\n\n  setupMaterial(material) {\n    material.defines = material.defines || {};\n    material.defines.USE_CSM = 1;\n    material.defines.CSM_CASCADES = this.cascades;\n\n    if (this.fade) {\n      material.defines.CSM_FADE = '';\n    }\n\n    const breaksVec2 = [];\n    const scope = this;\n    const shaders = this.shaders;\n\n    material.onBeforeCompile = function (shader) {\n      const far = Math.min(scope.camera.far, scope.maxFar);\n      scope.getExtendedBreaks(breaksVec2);\n      shader.uniforms.CSM_cascades = {\n        value: breaksVec2\n      };\n      shader.uniforms.cameraNear = {\n        value: scope.camera.near\n      };\n      shader.uniforms.shadowFar = {\n        value: far\n      };\n      shaders.set(material, shader);\n    };\n\n    shaders.set(material, null);\n  }\n\n  updateUniforms() {\n    const far = Math.min(this.camera.far, this.maxFar);\n    const shaders = this.shaders;\n    shaders.forEach(function (shader, material) {\n      if (shader !== null) {\n        const uniforms = shader.uniforms;\n        this.getExtendedBreaks(uniforms.CSM_cascades.value);\n        uniforms.cameraNear.value = this.camera.near;\n        uniforms.shadowFar.value = far;\n      }\n\n      if (!this.fade && 'CSM_FADE' in material.defines) {\n        delete material.defines.CSM_FADE;\n        material.needsUpdate = true;\n      } else if (this.fade && !('CSM_FADE' in material.defines)) {\n        material.defines.CSM_FADE = '';\n        material.needsUpdate = true;\n      }\n    }, this);\n  }\n\n  getExtendedBreaks(target) {\n    while (target.length < this.breaks.length) {\n      target.push(new Vector2());\n    }\n\n    target.length = this.breaks.length;\n\n    for (let i = 0; i < this.cascades; i++) {\n      const amount = this.breaks[i];\n      const prev = this.breaks[i - 1] || 0;\n      target[i].x = prev;\n      target[i].y = amount;\n    }\n  }\n\n  updateFrustums() {\n    this.getBreaks();\n    this.initCascades();\n    this.updateShadowBounds();\n    this.updateUniforms();\n  }\n\n  remove() {\n    for (let i = 0; i < this.lights.length; i++) {\n      this.parent.remove(this.lights[i]);\n    }\n  }\n\n  dispose() {\n    const shaders = this.shaders;\n    shaders.forEach(function (shader, material) {\n      delete material.onBeforeCompile;\n      delete material.defines.USE_CSM;\n      delete material.defines.CSM_CASCADES;\n      delete material.defines.CSM_FADE;\n\n      if (shader !== null) {\n        delete shader.uniforms.CSM_cascades;\n        delete shader.uniforms.cameraNear;\n        delete shader.uniforms.shadowFar;\n      }\n\n      material.needsUpdate = true;\n    });\n    shaders.clear();\n  }\n\n}\n\nexport { CSM };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}