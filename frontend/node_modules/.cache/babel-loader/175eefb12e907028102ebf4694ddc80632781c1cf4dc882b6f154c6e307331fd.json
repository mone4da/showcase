{"ast":null,"code":"import _objectSpread from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { Loader, FileLoader, ShapePath } from 'three';\nvar FontLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(FontLoader, _Loader);\n  var _super = _createSuper(FontLoader);\n  function FontLoader(manager) {\n    _classCallCheck(this, FontLoader);\n    return _super.call(this, manager);\n  }\n  _createClass(FontLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var _this = this;\n      var loader = new FileLoader(this.manager);\n      loader.setPath(this.path);\n      loader.setRequestHeader(this.requestHeader);\n      loader.setWithCredentials(this.withCredentials);\n      loader.load(url, function (response) {\n        if (typeof response !== 'string') throw new Error('unsupported data type');\n        var json = JSON.parse(response);\n        var font = _this.parse(json);\n        if (onLoad) onLoad(font);\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(json) {\n      return new Font(json);\n    }\n  }]);\n  return FontLoader;\n}(Loader);\nvar Font = /*#__PURE__*/function () {\n  function Font(data) {\n    _classCallCheck(this, Font);\n    _defineProperty(this, \"data\", void 0);\n    this.data = data;\n  }\n  _createClass(Font, [{\n    key: \"generateShapes\",\n    value: function generateShapes(text) {\n      var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n      var _options = arguments.length > 2 ? arguments[2] : undefined;\n      var shapes = [];\n      var options = _objectSpread({\n        letterSpacing: 0,\n        lineHeight: 1\n      }, _options);\n      var paths = createPaths(text, size, this.data, options);\n      for (var p = 0, pl = paths.length; p < pl; p++) {\n        Array.prototype.push.apply(shapes, paths[p].toShapes(false));\n      }\n      return shapes;\n    }\n  }]);\n  return Font;\n}();\n_defineProperty(Font, \"isFont\", void 0);\n_defineProperty(Font, \"type\", void 0);\nfunction createPaths(text, size, data, options) {\n  var chars = Array.from(text);\n  var scale = size / data.resolution;\n  var line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;\n  var paths = [];\n  var offsetX = 0,\n    offsetY = 0;\n  for (var i = 0; i < chars.length; i++) {\n    var char = chars[i];\n    if (char === '\\n') {\n      offsetX = 0;\n      offsetY -= line_height * options.lineHeight;\n    } else {\n      var ret = createPath(char, scale, offsetX, offsetY, data);\n      if (ret) {\n        offsetX += ret.offsetX + options.letterSpacing;\n        paths.push(ret.path);\n      }\n    }\n  }\n  return paths;\n}\nfunction createPath(char, scale, offsetX, offsetY, data) {\n  var glyph = data.glyphs[char] || data.glyphs['?'];\n  if (!glyph) {\n    console.error('THREE.Font: character \"' + char + '\" does not exists in font family ' + data.familyName + '.');\n    return;\n  }\n  var path = new ShapePath();\n  var x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;\n  if (glyph.o) {\n    var outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));\n    for (var i = 0, l = outline.length; i < l;) {\n      var action = outline[i++];\n      switch (action) {\n        case 'm':\n          // moveTo\n          x = parseInt(outline[i++]) * scale + offsetX;\n          y = parseInt(outline[i++]) * scale + offsetY;\n          path.moveTo(x, y);\n          break;\n        case 'l':\n          // lineTo\n          x = parseInt(outline[i++]) * scale + offsetX;\n          y = parseInt(outline[i++]) * scale + offsetY;\n          path.lineTo(x, y);\n          break;\n        case 'q':\n          // quadraticCurveTo\n          cpx = parseInt(outline[i++]) * scale + offsetX;\n          cpy = parseInt(outline[i++]) * scale + offsetY;\n          cpx1 = parseInt(outline[i++]) * scale + offsetX;\n          cpy1 = parseInt(outline[i++]) * scale + offsetY;\n          path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);\n          break;\n        case 'b':\n          // bezierCurveTo\n          cpx = parseInt(outline[i++]) * scale + offsetX;\n          cpy = parseInt(outline[i++]) * scale + offsetY;\n          cpx1 = parseInt(outline[i++]) * scale + offsetX;\n          cpy1 = parseInt(outline[i++]) * scale + offsetY;\n          cpx2 = parseInt(outline[i++]) * scale + offsetX;\n          cpy2 = parseInt(outline[i++]) * scale + offsetY;\n          path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);\n          break;\n      }\n    }\n  }\n  return {\n    offsetX: glyph.ha * scale,\n    path: path\n  };\n}\nexport { Font, FontLoader };","map":{"version":3,"names":["_defineProperty","Loader","FileLoader","ShapePath","FontLoader","_Loader","_inherits","_super","_createSuper","manager","_classCallCheck","call","_createClass","key","value","load","url","onLoad","onProgress","onError","_this","loader","setPath","path","setRequestHeader","requestHeader","setWithCredentials","withCredentials","response","Error","json","JSON","parse","font","Font","data","generateShapes","text","size","arguments","length","undefined","_options","shapes","options","_objectSpread","letterSpacing","lineHeight","paths","createPaths","p","pl","Array","prototype","push","apply","toShapes","chars","from","scale","resolution","line_height","boundingBox","yMax","yMin","underlineThickness","offsetX","offsetY","i","char","ret","createPath","glyph","glyphs","console","error","familyName","x","y","cpx","cpy","cpx1","cpy1","cpx2","cpy2","o","outline","_cachedOutline","split","l","action","parseInt","moveTo","lineTo","quadraticCurveTo","bezierCurveTo","ha"],"sources":["/home/samuel/experiment/3d/farm/frontend/node_modules/three-stdlib/loaders/FontLoader.js"],"sourcesContent":["import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { Loader, FileLoader, ShapePath } from 'three';\n\nclass FontLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, response => {\n      if (typeof response !== 'string') throw new Error('unsupported data type');\n      const json = JSON.parse(response);\n      const font = this.parse(json);\n      if (onLoad) onLoad(font);\n    }, onProgress, onError);\n  }\n\n  parse(json) {\n    return new Font(json);\n  }\n\n}\nclass Font {\n  constructor(data) {\n    _defineProperty(this, \"data\", void 0);\n\n    this.data = data;\n  }\n\n  generateShapes(text, size = 100, _options) {\n    const shapes = [];\n    const options = {\n      letterSpacing: 0,\n      lineHeight: 1,\n      ..._options\n    };\n    const paths = createPaths(text, size, this.data, options);\n\n    for (let p = 0, pl = paths.length; p < pl; p++) {\n      Array.prototype.push.apply(shapes, paths[p].toShapes(false));\n    }\n\n    return shapes;\n  }\n\n}\n\n_defineProperty(Font, \"isFont\", void 0);\n\n_defineProperty(Font, \"type\", void 0);\n\nfunction createPaths(text, size, data, options) {\n  const chars = Array.from(text);\n  const scale = size / data.resolution;\n  const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;\n  const paths = [];\n  let offsetX = 0,\n      offsetY = 0;\n\n  for (let i = 0; i < chars.length; i++) {\n    const char = chars[i];\n\n    if (char === '\\n') {\n      offsetX = 0;\n      offsetY -= line_height * options.lineHeight;\n    } else {\n      const ret = createPath(char, scale, offsetX, offsetY, data);\n\n      if (ret) {\n        offsetX += ret.offsetX + options.letterSpacing;\n        paths.push(ret.path);\n      }\n    }\n  }\n\n  return paths;\n}\n\nfunction createPath(char, scale, offsetX, offsetY, data) {\n  const glyph = data.glyphs[char] || data.glyphs['?'];\n\n  if (!glyph) {\n    console.error('THREE.Font: character \"' + char + '\" does not exists in font family ' + data.familyName + '.');\n    return;\n  }\n\n  const path = new ShapePath();\n  let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;\n\n  if (glyph.o) {\n    const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));\n\n    for (let i = 0, l = outline.length; i < l;) {\n      const action = outline[i++];\n\n      switch (action) {\n        case 'm':\n          // moveTo\n          x = parseInt(outline[i++]) * scale + offsetX;\n          y = parseInt(outline[i++]) * scale + offsetY;\n          path.moveTo(x, y);\n          break;\n\n        case 'l':\n          // lineTo\n          x = parseInt(outline[i++]) * scale + offsetX;\n          y = parseInt(outline[i++]) * scale + offsetY;\n          path.lineTo(x, y);\n          break;\n\n        case 'q':\n          // quadraticCurveTo\n          cpx = parseInt(outline[i++]) * scale + offsetX;\n          cpy = parseInt(outline[i++]) * scale + offsetY;\n          cpx1 = parseInt(outline[i++]) * scale + offsetX;\n          cpy1 = parseInt(outline[i++]) * scale + offsetY;\n          path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);\n          break;\n\n        case 'b':\n          // bezierCurveTo\n          cpx = parseInt(outline[i++]) * scale + offsetX;\n          cpy = parseInt(outline[i++]) * scale + offsetY;\n          cpx1 = parseInt(outline[i++]) * scale + offsetX;\n          cpy1 = parseInt(outline[i++]) * scale + offsetY;\n          cpx2 = parseInt(outline[i++]) * scale + offsetX;\n          cpy2 = parseInt(outline[i++]) * scale + offsetY;\n          path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);\n          break;\n      }\n    }\n  }\n\n  return {\n    offsetX: glyph.ha * scale,\n    path\n  };\n}\n\nexport { Font, FontLoader };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}