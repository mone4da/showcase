{"ast":null,"code":"import _createForOfIteratorHelper from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport NodeUniform from './NodeUniform.js';\nimport NodeAttribute from './NodeAttribute.js';\nimport NodeVary from './NodeVary.js';\nimport NodeVar from './NodeVar.js';\nimport NodeCode from './NodeCode.js';\nimport NodeKeywords from './NodeKeywords.js';\nimport { NodeUpdateType } from './constants.js';\nimport { REVISION, LinearEncoding } from 'three';\nvar shaderStages = ['fragment', 'vertex'];\nvar vector = ['x', 'y', 'z', 'w'];\nvar toFloat = function toFloat(value) {\n  value = Number(value);\n  return value + (value % 1 ? '' : '.0');\n};\nvar NodeBuilder = /*#__PURE__*/function () {\n  function NodeBuilder(object, renderer, parser) {\n    _classCallCheck(this, NodeBuilder);\n    this.object = object;\n    this.material = object.material;\n    this.renderer = renderer;\n    this.parser = parser;\n    this.nodes = [];\n    this.updateNodes = [];\n    this.hashNodes = {};\n    this.vertexShader = null;\n    this.fragmentShader = null;\n    this.flowNodes = {\n      vertex: [],\n      fragment: []\n    };\n    this.flowCode = {\n      vertex: '',\n      fragment: ''\n    };\n    this.uniforms = {\n      vertex: [],\n      fragment: [],\n      index: 0\n    };\n    this.codes = {\n      vertex: [],\n      fragment: []\n    };\n    this.attributes = [];\n    this.varys = [];\n    this.vars = {\n      vertex: [],\n      fragment: []\n    };\n    this.flow = {\n      code: ''\n    };\n    this.stack = [];\n    this.context = {\n      keywords: new NodeKeywords(),\n      material: object.material\n    };\n    this.nodesData = new WeakMap();\n    this.flowsData = new WeakMap();\n    this.shaderStage = null;\n    this.node = null;\n  }\n  _createClass(NodeBuilder, [{\n    key: \"addStack\",\n    value: function addStack(node) {\n      /*\n      if ( this.stack.indexOf( node ) !== - 1 ) {\n      console.warn( 'Recursive node: ', node );\n      }\n      */\n      this.stack.push(node);\n    }\n  }, {\n    key: \"removeStack\",\n    value: function removeStack(node) {\n      var lastStack = this.stack.pop();\n      if (lastStack !== node) {\n        throw new Error('NodeBuilder: Invalid node stack!');\n      }\n    }\n  }, {\n    key: \"setHashNode\",\n    value: function setHashNode(node, hash) {\n      this.hashNodes[hash] = node;\n    }\n  }, {\n    key: \"addNode\",\n    value: function addNode(node) {\n      if (this.nodes.indexOf(node) === -1) {\n        var updateType = node.getUpdateType(this);\n        if (updateType !== NodeUpdateType.None) {\n          this.updateNodes.push(node);\n        }\n        this.nodes.push(node);\n        this.setHashNode(node, node.getHash(this));\n      }\n    }\n  }, {\n    key: \"getMethod\",\n    value: function getMethod(method) {\n      return method;\n    }\n  }, {\n    key: \"getNodeFromHash\",\n    value: function getNodeFromHash(hash) {\n      return this.hashNodes[hash];\n    }\n  }, {\n    key: \"addFlow\",\n    value: function addFlow(shaderStage, node) {\n      this.flowNodes[shaderStage].push(node);\n      return node;\n    }\n  }, {\n    key: \"setContext\",\n    value: function setContext(context) {\n      this.context = context;\n    }\n  }, {\n    key: \"getContext\",\n    value: function getContext() {\n      return this.context;\n    }\n  }, {\n    key: \"getTexture\",\n    value: function getTexture() {\n      console.warn('Abstract function.');\n    }\n  }, {\n    key: \"getTextureBias\",\n    value: function getTextureBias() {\n      console.warn('Abstract function.');\n    }\n  }, {\n    key: \"getCubeTexture\",\n    value: function getCubeTexture() {\n      console.warn('Abstract function.');\n    }\n  }, {\n    key: \"getCubeTextureBias\",\n    value: function getCubeTextureBias() {\n      console.warn('Abstract function.');\n    } // @TODO: rename to .generateConst()\n  }, {\n    key: \"getConst\",\n    value: function getConst(type, value) {\n      var _this = this;\n      if (type === 'float') return toFloat(value);\n      if (type === 'int') return \"\".concat(Math.round(value));\n      if (type === 'uint') return value >= 0 ? \"\".concat(Math.round(value), \"u\") : '0u';\n      if (type === 'bool') return value ? 'true' : 'false';\n      if (type === 'color') {\n        return \"\".concat(this.getType('vec3'), \"( \").concat(toFloat(value.r), \", \").concat(toFloat(value.g), \", \").concat(toFloat(value.b), \" )\");\n      }\n      var typeLength = this.getTypeLength(type);\n      var componentType = this.getComponentType(type);\n      var getConst = function getConst(value) {\n        return _this.getConst(componentType, value);\n      };\n      if (typeLength === 2) {\n        return \"\".concat(this.getType(type), \"( \").concat(getConst(value.x), \", \").concat(getConst(value.y), \" )\");\n      } else if (typeLength === 3) {\n        return \"\".concat(this.getType(type), \"( \").concat(getConst(value.x), \", \").concat(getConst(value.y), \", \").concat(getConst(value.z), \" )\");\n      } else if (typeLength === 4) {\n        return \"\".concat(this.getType(type), \"( \").concat(getConst(value.x), \", \").concat(getConst(value.y), \", \").concat(getConst(value.z), \", \").concat(getConst(value.w), \" )\");\n      }\n      throw new Error(\"NodeBuilder: Type '\".concat(type, \"' not found in generate constant attempt.\"));\n    }\n  }, {\n    key: \"getType\",\n    value: function getType(type) {\n      return type;\n    }\n  }, {\n    key: \"generateMethod\",\n    value: function generateMethod(method) {\n      return method;\n    }\n  }, {\n    key: \"getAttribute\",\n    value: function getAttribute(name, type) {\n      var attributes = this.attributes; // find attribute\n      var _iterator = _createForOfIteratorHelper(attributes),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _attribute = _step.value;\n          if (_attribute.name === name) {\n            return _attribute;\n          }\n        } // create a new if no exist\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      var attribute = new NodeAttribute(name, type);\n      attributes.push(attribute);\n      return attribute;\n    }\n  }, {\n    key: \"getPropertyName\",\n    value: function getPropertyName(node\n    /*, shaderStage*/) {\n      return node.name;\n    }\n  }, {\n    key: \"isVector\",\n    value: function isVector(type) {\n      return /vec\\d/.test(type);\n    }\n  }, {\n    key: \"isMatrix\",\n    value: function isMatrix(type) {\n      return /mat\\d/.test(type);\n    }\n  }, {\n    key: \"isReference\",\n    value: function isReference(type) {\n      return type === 'void' || type === 'property' || type === 'sampler';\n    }\n  }, {\n    key: \"isShaderStage\",\n    value: function isShaderStage(shaderStage) {\n      return this.shaderStage === shaderStage;\n    }\n  }, {\n    key: \"getTextureEncodingFromMap\",\n    value: function getTextureEncodingFromMap(map) {\n      var encoding;\n      if (map && map.isTexture) {\n        encoding = map.encoding;\n      } else if (map && map.isWebGLRenderTarget) {\n        encoding = map.texture.encoding;\n      } else {\n        encoding = LinearEncoding;\n      }\n      return encoding;\n    }\n  }, {\n    key: \"getComponentType\",\n    value: function getComponentType(type) {\n      type = this.getVectorType(type);\n      var componentType = /(b|i|u|)(vec|mat)([2-4])/.exec(type);\n      if (componentType === null) return null;\n      if (componentType[1] === 'b') return 'bool';\n      if (componentType[1] === 'i') return 'int';\n      if (componentType[1] === 'u') return 'uint';\n      return 'float';\n    }\n  }, {\n    key: \"getVectorType\",\n    value: function getVectorType(type) {\n      if (type === 'color') return 'vec3';\n      if (type === 'texture') return 'vec4';\n      return type;\n    }\n  }, {\n    key: \"getTypeFromLength\",\n    value: function getTypeFromLength(type) {\n      if (type === 1) return 'float';\n      if (type === 2) return 'vec2';\n      if (type === 3) return 'vec3';\n      if (type === 4) return 'vec4';\n      return 0;\n    }\n  }, {\n    key: \"getTypeLength\",\n    value: function getTypeLength(type) {\n      var vecType = this.getVectorType(type);\n      var vecNum = /vec([2-4])/.exec(vecType);\n      if (vecNum !== null) return Number(vecNum[1]);\n      if (vecType === 'float' || vecType === 'bool' || vecType === 'int' || vecType === 'uint') return 1;\n      return 0;\n    }\n  }, {\n    key: \"getVectorFromMatrix\",\n    value: function getVectorFromMatrix(type) {\n      return type.replace('mat', 'vec');\n    }\n  }, {\n    key: \"getDataFromNode\",\n    value: function getDataFromNode(node) {\n      var shaderStage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.shaderStage;\n      var nodeData = this.nodesData.get(node);\n      if (nodeData === undefined) {\n        nodeData = {\n          vertex: {},\n          fragment: {}\n        };\n        this.nodesData.set(node, nodeData);\n      }\n      return shaderStage !== null ? nodeData[shaderStage] : nodeData;\n    }\n  }, {\n    key: \"getUniformFromNode\",\n    value: function getUniformFromNode(node, shaderStage, type) {\n      var nodeData = this.getDataFromNode(node, shaderStage);\n      var nodeUniform = nodeData.uniform;\n      if (nodeUniform === undefined) {\n        var index = this.uniforms.index++;\n        nodeUniform = new NodeUniform('nodeUniform' + index, type, node);\n        this.uniforms[shaderStage].push(nodeUniform);\n        nodeData.uniform = nodeUniform;\n      }\n      return nodeUniform;\n    }\n  }, {\n    key: \"getVarFromNode\",\n    value: function getVarFromNode(node, type) {\n      var shaderStage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.shaderStage;\n      var nodeData = this.getDataFromNode(node, shaderStage);\n      var nodeVar = nodeData.variable;\n      if (nodeVar === undefined) {\n        var vars = this.vars[shaderStage];\n        var index = vars.length;\n        nodeVar = new NodeVar('nodeVar' + index, type);\n        vars.push(nodeVar);\n        nodeData.variable = nodeVar;\n      }\n      return nodeVar;\n    }\n  }, {\n    key: \"getVaryFromNode\",\n    value: function getVaryFromNode(node, type) {\n      var nodeData = this.getDataFromNode(node, null);\n      var nodeVary = nodeData.vary;\n      if (nodeVary === undefined) {\n        var varys = this.varys;\n        var index = varys.length;\n        nodeVary = new NodeVary('nodeVary' + index, type);\n        varys.push(nodeVary);\n        nodeData.vary = nodeVary;\n      }\n      return nodeVary;\n    }\n  }, {\n    key: \"getCodeFromNode\",\n    value: function getCodeFromNode(node, type) {\n      var shaderStage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.shaderStage;\n      var nodeData = this.getDataFromNode(node);\n      var nodeCode = nodeData.code;\n      if (nodeCode === undefined) {\n        var codes = this.codes[shaderStage];\n        var index = codes.length;\n        nodeCode = new NodeCode('nodeCode' + index, type);\n        codes.push(nodeCode);\n        nodeData.code = nodeCode;\n      }\n      return nodeCode;\n    }\n  }, {\n    key: \"addFlowCode\",\n    value: function addFlowCode(code) {\n      this.flow.code += code;\n    }\n  }, {\n    key: \"getFlowData\",\n    value: function getFlowData(shaderStage, node) {\n      return this.flowsData.get(node);\n    }\n  }, {\n    key: \"flowNode\",\n    value: function flowNode(node) {\n      this.node = node;\n      var output = node.getNodeType(this);\n      var flowData = this.flowChildNode(node, output);\n      this.flowsData.set(node, flowData);\n      this.node = null;\n      return flowData;\n    }\n  }, {\n    key: \"flowChildNode\",\n    value: function flowChildNode(node) {\n      var output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var previousFlow = this.flow;\n      var flow = {\n        code: ''\n      };\n      this.flow = flow;\n      flow.result = node.build(this, output);\n      this.flow = previousFlow;\n      return flow;\n    }\n  }, {\n    key: \"flowNodeFromShaderStage\",\n    value: function flowNodeFromShaderStage(shaderStage, node) {\n      var output = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var propertyName = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n      var previousShaderStage = this.shaderStage;\n      this.setShaderStage(shaderStage);\n      var flowData = this.flowChildNode(node, output);\n      if (propertyName !== null) {\n        flowData.code += \"\".concat(propertyName, \" = \").concat(flowData.result, \";\\n\\t\");\n      }\n      this.flowCode[shaderStage] = this.flowCode[shaderStage] + flowData.code;\n      this.setShaderStage(previousShaderStage);\n      return flowData;\n    }\n  }, {\n    key: \"getAttributes\",\n    value: function getAttributes() {\n      console.warn('Abstract function.');\n    }\n  }, {\n    key: \"getVarys\",\n    value: function getVarys() {\n      console.warn('Abstract function.');\n    }\n  }, {\n    key: \"getVars\",\n    value: function getVars(shaderStage) {\n      var snippet = '';\n      var vars = this.vars[shaderStage];\n      for (var index = 0; index < vars.length; index++) {\n        var variable = vars[index];\n        snippet += \"\".concat(variable.type, \" \").concat(variable.name, \"; \");\n      }\n      return snippet;\n    }\n  }, {\n    key: \"getUniforms\",\n    value: function getUniforms() {\n      console.warn('Abstract function.');\n    }\n  }, {\n    key: \"getCodes\",\n    value: function getCodes(shaderStage) {\n      var codes = this.codes[shaderStage];\n      var code = '';\n      var _iterator2 = _createForOfIteratorHelper(codes),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var nodeCode = _step2.value;\n          code += nodeCode.code + '\\n';\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      return code;\n    }\n  }, {\n    key: \"getHash\",\n    value: function getHash() {\n      return this.vertexShader + this.fragmentShader;\n    }\n  }, {\n    key: \"getShaderStage\",\n    value: function getShaderStage() {\n      return this.shaderStage;\n    }\n  }, {\n    key: \"setShaderStage\",\n    value: function setShaderStage(shaderStage) {\n      this.shaderStage = shaderStage;\n    }\n  }, {\n    key: \"buildCode\",\n    value: function buildCode() {\n      console.warn('Abstract function.');\n    }\n  }, {\n    key: \"build\",\n    value: function build() {\n      // stage 1: analyze nodes to possible optimization and validation\n      for (var _i = 0, _shaderStages = shaderStages; _i < _shaderStages.length; _i++) {\n        var shaderStage = _shaderStages[_i];\n        this.setShaderStage(shaderStage);\n        var flowNodes = this.flowNodes[shaderStage];\n        var _iterator3 = _createForOfIteratorHelper(flowNodes),\n          _step3;\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var node = _step3.value;\n            node.analyze(this);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      } // stage 2: pre-build vertex code used in fragment shader\n\n      if (this.context.vertex && this.context.vertex.isNode) {\n        this.flowNodeFromShaderStage('vertex', this.context.vertex);\n      } // stage 3: generate shader\n\n      for (var _i2 = 0, _shaderStages2 = shaderStages; _i2 < _shaderStages2.length; _i2++) {\n        var _shaderStage = _shaderStages2[_i2];\n        this.setShaderStage(_shaderStage);\n        var _flowNodes = this.flowNodes[_shaderStage];\n        var _iterator4 = _createForOfIteratorHelper(_flowNodes),\n          _step4;\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var _node = _step4.value;\n            this.flowNode(_node, _shaderStage);\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      }\n      this.setShaderStage(null); // stage 4: build code for a specific output\n\n      this.buildCode();\n      return this;\n    }\n  }, {\n    key: \"format\",\n    value: function format(snippet, fromType, toType) {\n      fromType = this.getVectorType(fromType);\n      toType = this.getVectorType(toType);\n      if (fromType === toType || toType === null || this.isReference(toType)) {\n        return snippet;\n      }\n      var fromTypeLength = this.getTypeLength(fromType);\n      var toTypeLength = this.getTypeLength(toType);\n      if (fromTypeLength === 0) {\n        // fromType is matrix-like\n        var vectorType = this.getVectorFromMatrix(fromType);\n        return this.format(\"( \".concat(snippet, \" * \").concat(this.getType(vectorType), \"( 1.0 ) )\"), vectorType, toType);\n      }\n      if (toTypeLength === 0) {\n        // toType is matrix-like\n        // ignore for now\n        //return `${ this.getType( toType ) }( ${ snippet } )`;\n        return snippet;\n      }\n      if (fromTypeLength === toTypeLength) {\n        return \"\".concat(this.getType(toType), \"( \").concat(snippet, \" )\");\n      }\n      if (fromTypeLength > toTypeLength) {\n        return this.format(\"\".concat(snippet, \".\").concat('xyz'.slice(0, toTypeLength)), this.getTypeFromLength(toTypeLength), toType);\n      }\n      if (toTypeLength === 4) {\n        // toType is vec4-like\n        return \"\".concat(this.getType(toType), \"( \").concat(this.format(snippet, fromType, 'vec3'), \", 1.0 )\");\n      }\n      if (fromTypeLength === 2) {\n        // fromType is vec2-like and toType is vec3-like\n        return \"\".concat(this.getType(toType), \"( \").concat(this.format(snippet, fromType, 'vec2'), \", 0.0 )\");\n      }\n      return \"\".concat(this.getType(toType), \"( \").concat(snippet, \" )\"); // fromType is float-like\n    }\n  }, {\n    key: \"getSignature\",\n    value: function getSignature() {\n      return \"// Three.js r\".concat(REVISION, \" - NodeMaterial System\\n\");\n    }\n  }]);\n  return NodeBuilder;\n}();\nexport default NodeBuilder;\nexport { shaderStages, vector };","map":{"version":3,"names":["NodeUniform","NodeAttribute","NodeVary","NodeVar","NodeCode","NodeKeywords","NodeUpdateType","REVISION","LinearEncoding","shaderStages","vector","toFloat","value","Number","NodeBuilder","object","renderer","parser","_classCallCheck","material","nodes","updateNodes","hashNodes","vertexShader","fragmentShader","flowNodes","vertex","fragment","flowCode","uniforms","index","codes","attributes","varys","vars","flow","code","stack","context","keywords","nodesData","WeakMap","flowsData","shaderStage","node","_createClass","key","addStack","push","removeStack","lastStack","pop","Error","setHashNode","hash","addNode","indexOf","updateType","getUpdateType","None","getHash","getMethod","method","getNodeFromHash","addFlow","setContext","getContext","getTexture","console","warn","getTextureBias","getCubeTexture","getCubeTextureBias","getConst","type","_this","concat","Math","round","getType","r","g","b","typeLength","getTypeLength","componentType","getComponentType","x","y","z","w","generateMethod","getAttribute","name","_iterator","_createForOfIteratorHelper","_step","s","n","done","attribute","err","e","f","getPropertyName","isVector","test","isMatrix","isReference","isShaderStage","getTextureEncodingFromMap","map","encoding","isTexture","isWebGLRenderTarget","texture","getVectorType","exec","getTypeFromLength","vecType","vecNum","getVectorFromMatrix","replace","getDataFromNode","arguments","length","undefined","nodeData","get","set","getUniformFromNode","nodeUniform","uniform","getVarFromNode","nodeVar","variable","getVaryFromNode","nodeVary","vary","getCodeFromNode","nodeCode","addFlowCode","getFlowData","flowNode","output","getNodeType","flowData","flowChildNode","previousFlow","result","build","flowNodeFromShaderStage","propertyName","previousShaderStage","setShaderStage","getAttributes","getVarys","getVars","snippet","getUniforms","getCodes","_iterator2","_step2","getShaderStage","buildCode","_i","_shaderStages","_iterator3","_step3","analyze","isNode","_i2","_shaderStages2","_iterator4","_step4","format","fromType","toType","fromTypeLength","toTypeLength","vectorType","slice","getSignature"],"sources":["/home/samuel/experiment/3d/farm/frontend/node_modules/three-stdlib/nodes/core/NodeBuilder.js"],"sourcesContent":["import NodeUniform from './NodeUniform.js';\nimport NodeAttribute from './NodeAttribute.js';\nimport NodeVary from './NodeVary.js';\nimport NodeVar from './NodeVar.js';\nimport NodeCode from './NodeCode.js';\nimport NodeKeywords from './NodeKeywords.js';\nimport { NodeUpdateType } from './constants.js';\nimport { REVISION, LinearEncoding } from 'three';\n\nconst shaderStages = ['fragment', 'vertex'];\nconst vector = ['x', 'y', 'z', 'w'];\n\nconst toFloat = value => {\n  value = Number(value);\n  return value + (value % 1 ? '' : '.0');\n};\n\nclass NodeBuilder {\n  constructor(object, renderer, parser) {\n    this.object = object;\n    this.material = object.material;\n    this.renderer = renderer;\n    this.parser = parser;\n    this.nodes = [];\n    this.updateNodes = [];\n    this.hashNodes = {};\n    this.vertexShader = null;\n    this.fragmentShader = null;\n    this.flowNodes = {\n      vertex: [],\n      fragment: []\n    };\n    this.flowCode = {\n      vertex: '',\n      fragment: ''\n    };\n    this.uniforms = {\n      vertex: [],\n      fragment: [],\n      index: 0\n    };\n    this.codes = {\n      vertex: [],\n      fragment: []\n    };\n    this.attributes = [];\n    this.varys = [];\n    this.vars = {\n      vertex: [],\n      fragment: []\n    };\n    this.flow = {\n      code: ''\n    };\n    this.stack = [];\n    this.context = {\n      keywords: new NodeKeywords(),\n      material: object.material\n    };\n    this.nodesData = new WeakMap();\n    this.flowsData = new WeakMap();\n    this.shaderStage = null;\n    this.node = null;\n  }\n\n  addStack(node) {\n    /*\n    if ( this.stack.indexOf( node ) !== - 1 ) {\n    console.warn( 'Recursive node: ', node );\n    }\n    */\n    this.stack.push(node);\n  }\n\n  removeStack(node) {\n    const lastStack = this.stack.pop();\n\n    if (lastStack !== node) {\n      throw new Error('NodeBuilder: Invalid node stack!');\n    }\n  }\n\n  setHashNode(node, hash) {\n    this.hashNodes[hash] = node;\n  }\n\n  addNode(node) {\n    if (this.nodes.indexOf(node) === -1) {\n      const updateType = node.getUpdateType(this);\n\n      if (updateType !== NodeUpdateType.None) {\n        this.updateNodes.push(node);\n      }\n\n      this.nodes.push(node);\n      this.setHashNode(node, node.getHash(this));\n    }\n  }\n\n  getMethod(method) {\n    return method;\n  }\n\n  getNodeFromHash(hash) {\n    return this.hashNodes[hash];\n  }\n\n  addFlow(shaderStage, node) {\n    this.flowNodes[shaderStage].push(node);\n    return node;\n  }\n\n  setContext(context) {\n    this.context = context;\n  }\n\n  getContext() {\n    return this.context;\n  }\n\n  getTexture() {\n    console.warn('Abstract function.');\n  }\n\n  getTextureBias() {\n    console.warn('Abstract function.');\n  }\n\n  getCubeTexture() {\n    console.warn('Abstract function.');\n  }\n\n  getCubeTextureBias() {\n    console.warn('Abstract function.');\n  } // @TODO: rename to .generateConst()\n\n\n  getConst(type, value) {\n    if (type === 'float') return toFloat(value);\n    if (type === 'int') return `${Math.round(value)}`;\n    if (type === 'uint') return value >= 0 ? `${Math.round(value)}u` : '0u';\n    if (type === 'bool') return value ? 'true' : 'false';\n\n    if (type === 'color') {\n      return `${this.getType('vec3')}( ${toFloat(value.r)}, ${toFloat(value.g)}, ${toFloat(value.b)} )`;\n    }\n\n    const typeLength = this.getTypeLength(type);\n    const componentType = this.getComponentType(type);\n\n    const getConst = value => this.getConst(componentType, value);\n\n    if (typeLength === 2) {\n      return `${this.getType(type)}( ${getConst(value.x)}, ${getConst(value.y)} )`;\n    } else if (typeLength === 3) {\n      return `${this.getType(type)}( ${getConst(value.x)}, ${getConst(value.y)}, ${getConst(value.z)} )`;\n    } else if (typeLength === 4) {\n      return `${this.getType(type)}( ${getConst(value.x)}, ${getConst(value.y)}, ${getConst(value.z)}, ${getConst(value.w)} )`;\n    }\n\n    throw new Error(`NodeBuilder: Type '${type}' not found in generate constant attempt.`);\n  }\n\n  getType(type) {\n    return type;\n  }\n\n  generateMethod(method) {\n    return method;\n  }\n\n  getAttribute(name, type) {\n    const attributes = this.attributes; // find attribute\n\n    for (const attribute of attributes) {\n      if (attribute.name === name) {\n        return attribute;\n      }\n    } // create a new if no exist\n\n\n    const attribute = new NodeAttribute(name, type);\n    attributes.push(attribute);\n    return attribute;\n  }\n\n  getPropertyName(node\n  /*, shaderStage*/\n  ) {\n    return node.name;\n  }\n\n  isVector(type) {\n    return /vec\\d/.test(type);\n  }\n\n  isMatrix(type) {\n    return /mat\\d/.test(type);\n  }\n\n  isReference(type) {\n    return type === 'void' || type === 'property' || type === 'sampler';\n  }\n\n  isShaderStage(shaderStage) {\n    return this.shaderStage === shaderStage;\n  }\n\n  getTextureEncodingFromMap(map) {\n    let encoding;\n\n    if (map && map.isTexture) {\n      encoding = map.encoding;\n    } else if (map && map.isWebGLRenderTarget) {\n      encoding = map.texture.encoding;\n    } else {\n      encoding = LinearEncoding;\n    }\n\n    return encoding;\n  }\n\n  getComponentType(type) {\n    type = this.getVectorType(type);\n    const componentType = /(b|i|u|)(vec|mat)([2-4])/.exec(type);\n    if (componentType === null) return null;\n    if (componentType[1] === 'b') return 'bool';\n    if (componentType[1] === 'i') return 'int';\n    if (componentType[1] === 'u') return 'uint';\n    return 'float';\n  }\n\n  getVectorType(type) {\n    if (type === 'color') return 'vec3';\n    if (type === 'texture') return 'vec4';\n    return type;\n  }\n\n  getTypeFromLength(type) {\n    if (type === 1) return 'float';\n    if (type === 2) return 'vec2';\n    if (type === 3) return 'vec3';\n    if (type === 4) return 'vec4';\n    return 0;\n  }\n\n  getTypeLength(type) {\n    const vecType = this.getVectorType(type);\n    const vecNum = /vec([2-4])/.exec(vecType);\n    if (vecNum !== null) return Number(vecNum[1]);\n    if (vecType === 'float' || vecType === 'bool' || vecType === 'int' || vecType === 'uint') return 1;\n    return 0;\n  }\n\n  getVectorFromMatrix(type) {\n    return type.replace('mat', 'vec');\n  }\n\n  getDataFromNode(node, shaderStage = this.shaderStage) {\n    let nodeData = this.nodesData.get(node);\n\n    if (nodeData === undefined) {\n      nodeData = {\n        vertex: {},\n        fragment: {}\n      };\n      this.nodesData.set(node, nodeData);\n    }\n\n    return shaderStage !== null ? nodeData[shaderStage] : nodeData;\n  }\n\n  getUniformFromNode(node, shaderStage, type) {\n    const nodeData = this.getDataFromNode(node, shaderStage);\n    let nodeUniform = nodeData.uniform;\n\n    if (nodeUniform === undefined) {\n      const index = this.uniforms.index++;\n      nodeUniform = new NodeUniform('nodeUniform' + index, type, node);\n      this.uniforms[shaderStage].push(nodeUniform);\n      nodeData.uniform = nodeUniform;\n    }\n\n    return nodeUniform;\n  }\n\n  getVarFromNode(node, type, shaderStage = this.shaderStage) {\n    const nodeData = this.getDataFromNode(node, shaderStage);\n    let nodeVar = nodeData.variable;\n\n    if (nodeVar === undefined) {\n      const vars = this.vars[shaderStage];\n      const index = vars.length;\n      nodeVar = new NodeVar('nodeVar' + index, type);\n      vars.push(nodeVar);\n      nodeData.variable = nodeVar;\n    }\n\n    return nodeVar;\n  }\n\n  getVaryFromNode(node, type) {\n    const nodeData = this.getDataFromNode(node, null);\n    let nodeVary = nodeData.vary;\n\n    if (nodeVary === undefined) {\n      const varys = this.varys;\n      const index = varys.length;\n      nodeVary = new NodeVary('nodeVary' + index, type);\n      varys.push(nodeVary);\n      nodeData.vary = nodeVary;\n    }\n\n    return nodeVary;\n  }\n\n  getCodeFromNode(node, type, shaderStage = this.shaderStage) {\n    const nodeData = this.getDataFromNode(node);\n    let nodeCode = nodeData.code;\n\n    if (nodeCode === undefined) {\n      const codes = this.codes[shaderStage];\n      const index = codes.length;\n      nodeCode = new NodeCode('nodeCode' + index, type);\n      codes.push(nodeCode);\n      nodeData.code = nodeCode;\n    }\n\n    return nodeCode;\n  }\n\n  addFlowCode(code) {\n    this.flow.code += code;\n  }\n\n  getFlowData(shaderStage, node) {\n    return this.flowsData.get(node);\n  }\n\n  flowNode(node) {\n    this.node = node;\n    const output = node.getNodeType(this);\n    const flowData = this.flowChildNode(node, output);\n    this.flowsData.set(node, flowData);\n    this.node = null;\n    return flowData;\n  }\n\n  flowChildNode(node, output = null) {\n    const previousFlow = this.flow;\n    const flow = {\n      code: ''\n    };\n    this.flow = flow;\n    flow.result = node.build(this, output);\n    this.flow = previousFlow;\n    return flow;\n  }\n\n  flowNodeFromShaderStage(shaderStage, node, output = null, propertyName = null) {\n    const previousShaderStage = this.shaderStage;\n    this.setShaderStage(shaderStage);\n    const flowData = this.flowChildNode(node, output);\n\n    if (propertyName !== null) {\n      flowData.code += `${propertyName} = ${flowData.result};\\n\\t`;\n    }\n\n    this.flowCode[shaderStage] = this.flowCode[shaderStage] + flowData.code;\n    this.setShaderStage(previousShaderStage);\n    return flowData;\n  }\n\n  getAttributes() {\n    console.warn('Abstract function.');\n  }\n\n  getVarys() {\n    console.warn('Abstract function.');\n  }\n\n  getVars(shaderStage) {\n    let snippet = '';\n    const vars = this.vars[shaderStage];\n\n    for (let index = 0; index < vars.length; index++) {\n      const variable = vars[index];\n      snippet += `${variable.type} ${variable.name}; `;\n    }\n\n    return snippet;\n  }\n\n  getUniforms() {\n    console.warn('Abstract function.');\n  }\n\n  getCodes(shaderStage) {\n    const codes = this.codes[shaderStage];\n    let code = '';\n\n    for (const nodeCode of codes) {\n      code += nodeCode.code + '\\n';\n    }\n\n    return code;\n  }\n\n  getHash() {\n    return this.vertexShader + this.fragmentShader;\n  }\n\n  getShaderStage() {\n    return this.shaderStage;\n  }\n\n  setShaderStage(shaderStage) {\n    this.shaderStage = shaderStage;\n  }\n\n  buildCode() {\n    console.warn('Abstract function.');\n  }\n\n  build() {\n    // stage 1: analyze nodes to possible optimization and validation\n    for (const shaderStage of shaderStages) {\n      this.setShaderStage(shaderStage);\n      const flowNodes = this.flowNodes[shaderStage];\n\n      for (const node of flowNodes) {\n        node.analyze(this);\n      }\n    } // stage 2: pre-build vertex code used in fragment shader\n\n\n    if (this.context.vertex && this.context.vertex.isNode) {\n      this.flowNodeFromShaderStage('vertex', this.context.vertex);\n    } // stage 3: generate shader\n\n\n    for (const shaderStage of shaderStages) {\n      this.setShaderStage(shaderStage);\n      const flowNodes = this.flowNodes[shaderStage];\n\n      for (const node of flowNodes) {\n        this.flowNode(node, shaderStage);\n      }\n    }\n\n    this.setShaderStage(null); // stage 4: build code for a specific output\n\n    this.buildCode();\n    return this;\n  }\n\n  format(snippet, fromType, toType) {\n    fromType = this.getVectorType(fromType);\n    toType = this.getVectorType(toType);\n\n    if (fromType === toType || toType === null || this.isReference(toType)) {\n      return snippet;\n    }\n\n    const fromTypeLength = this.getTypeLength(fromType);\n    const toTypeLength = this.getTypeLength(toType);\n\n    if (fromTypeLength === 0) {\n      // fromType is matrix-like\n      const vectorType = this.getVectorFromMatrix(fromType);\n      return this.format(`( ${snippet} * ${this.getType(vectorType)}( 1.0 ) )`, vectorType, toType);\n    }\n\n    if (toTypeLength === 0) {\n      // toType is matrix-like\n      // ignore for now\n      //return `${ this.getType( toType ) }( ${ snippet } )`;\n      return snippet;\n    }\n\n    if (fromTypeLength === toTypeLength) {\n      return `${this.getType(toType)}( ${snippet} )`;\n    }\n\n    if (fromTypeLength > toTypeLength) {\n      return this.format(`${snippet}.${'xyz'.slice(0, toTypeLength)}`, this.getTypeFromLength(toTypeLength), toType);\n    }\n\n    if (toTypeLength === 4) {\n      // toType is vec4-like\n      return `${this.getType(toType)}( ${this.format(snippet, fromType, 'vec3')}, 1.0 )`;\n    }\n\n    if (fromTypeLength === 2) {\n      // fromType is vec2-like and toType is vec3-like\n      return `${this.getType(toType)}( ${this.format(snippet, fromType, 'vec2')}, 0.0 )`;\n    }\n\n    return `${this.getType(toType)}( ${snippet} )`; // fromType is float-like\n  }\n\n  getSignature() {\n    return `// Three.js r${REVISION} - NodeMaterial System\\n`;\n  }\n\n}\n\nexport default NodeBuilder;\nexport { shaderStages, vector };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}