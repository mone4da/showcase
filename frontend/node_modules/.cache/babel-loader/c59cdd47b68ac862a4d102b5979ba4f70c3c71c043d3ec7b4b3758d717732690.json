{"ast":null,"code":"import _createClass from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _assertThisInitialized from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Mesh, Color, Plane, Vector3, Matrix4, Vector4, PerspectiveCamera, WebGLRenderTarget, ShaderMaterial, UniformsUtils } from 'three';\nvar Reflector = /*#__PURE__*/function (_Mesh) {\n  _inherits(Reflector, _Mesh);\n  var _super = _createSuper(Reflector);\n  function Reflector(geometry) {\n    var _this;\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, Reflector);\n    _this = _super.call(this, geometry);\n    _this.type = 'Reflector';\n    var scope = _assertThisInitialized(_this);\n    var color = options.color !== undefined ? new Color(options.color) : new Color(0x7f7f7f);\n    var textureWidth = options.textureWidth || 512;\n    var textureHeight = options.textureHeight || 512;\n    var clipBias = options.clipBias || 0;\n    var shader = options.shader || Reflector.ReflectorShader; //\n\n    var reflectorPlane = new Plane();\n    var normal = new Vector3();\n    var reflectorWorldPosition = new Vector3();\n    var cameraWorldPosition = new Vector3();\n    var rotationMatrix = new Matrix4();\n    var lookAtPosition = new Vector3(0, 0, -1);\n    var clipPlane = new Vector4();\n    var view = new Vector3();\n    var target = new Vector3();\n    var q = new Vector4();\n    var textureMatrix = new Matrix4();\n    var virtualCamera = new PerspectiveCamera();\n    var renderTarget = new WebGLRenderTarget(textureWidth, textureHeight);\n    var material = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(shader.uniforms),\n      fragmentShader: shader.fragmentShader,\n      vertexShader: shader.vertexShader\n    });\n    material.uniforms['tDiffuse'].value = renderTarget.texture;\n    material.uniforms['color'].value = color;\n    material.uniforms['textureMatrix'].value = textureMatrix;\n    _this.material = material;\n    _this.onBeforeRender = function (renderer, scene, camera) {\n      reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n      rotationMatrix.extractRotation(scope.matrixWorld);\n      normal.set(0, 0, 1);\n      normal.applyMatrix4(rotationMatrix);\n      view.subVectors(reflectorWorldPosition, cameraWorldPosition); // Avoid rendering when reflector is facing away\n\n      if (view.dot(normal) > 0) return;\n      view.reflect(normal).negate();\n      view.add(reflectorWorldPosition);\n      rotationMatrix.extractRotation(camera.matrixWorld);\n      lookAtPosition.set(0, 0, -1);\n      lookAtPosition.applyMatrix4(rotationMatrix);\n      lookAtPosition.add(cameraWorldPosition);\n      target.subVectors(reflectorWorldPosition, lookAtPosition);\n      target.reflect(normal).negate();\n      target.add(reflectorWorldPosition);\n      virtualCamera.position.copy(view);\n      virtualCamera.up.set(0, 1, 0);\n      virtualCamera.up.applyMatrix4(rotationMatrix);\n      virtualCamera.up.reflect(normal);\n      virtualCamera.lookAt(target);\n      virtualCamera.far = camera.far; // Used in WebGLBackground\n\n      virtualCamera.updateMatrixWorld();\n      virtualCamera.projectionMatrix.copy(camera.projectionMatrix); // Update the texture matrix\n\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n      textureMatrix.multiply(virtualCamera.projectionMatrix);\n      textureMatrix.multiply(virtualCamera.matrixWorldInverse);\n      textureMatrix.multiply(scope.matrixWorld); // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n      // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\n      reflectorPlane.setFromNormalAndCoplanarPoint(normal, reflectorWorldPosition);\n      reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n      clipPlane.set(reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant);\n      var projectionMatrix = virtualCamera.projectionMatrix;\n      q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n      q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n      q.z = -1.0;\n      q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]; // Calculate the scaled plane vector\n\n      clipPlane.multiplyScalar(2.0 / clipPlane.dot(q)); // Replacing the third row of the projection matrix\n\n      projectionMatrix.elements[2] = clipPlane.x;\n      projectionMatrix.elements[6] = clipPlane.y;\n      projectionMatrix.elements[10] = clipPlane.z + 1.0 - clipBias;\n      projectionMatrix.elements[14] = clipPlane.w; // Render\n\n      renderTarget.texture.encoding = renderer.outputEncoding;\n      scope.visible = false;\n      var currentRenderTarget = renderer.getRenderTarget();\n      var currentXrEnabled = renderer.xr.enabled;\n      var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      renderer.xr.enabled = false; // Avoid camera modification\n\n      renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n      renderer.setRenderTarget(renderTarget);\n      renderer.state.buffers.depth.setMask(true); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n      if (renderer.autoClear === false) renderer.clear();\n      renderer.render(scene, virtualCamera);\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.setRenderTarget(currentRenderTarget); // Restore viewport\n\n      var viewport = camera.viewport;\n      if (viewport !== undefined) {\n        renderer.state.viewport(viewport);\n      }\n      scope.visible = true;\n    };\n    _this.getRenderTarget = function () {\n      return renderTarget;\n    };\n    _this.dispose = function () {\n      renderTarget.dispose();\n      scope.material.dispose();\n    };\n    return _this;\n  }\n  return _createClass(Reflector);\n}(Mesh);\nReflector.prototype.isReflector = true;\nReflector.ReflectorShader = {\n  uniforms: {\n    color: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    textureMatrix: {\n      value: null\n    }\n  },\n  vertexShader: /* glsl */\"\\n\\t\\tuniform mat4 textureMatrix;\\n\\t\\tvarying vec4 vUv;\\n\\n\\t\\t#include <common>\\n\\t\\t#include <logdepthbuf_pars_vertex>\\n\\n\\t\\tvoid main() {\\n\\n\\t\\t\\tvUv = textureMatrix * vec4( position, 1.0 );\\n\\n\\t\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\n\\t\\t\\t#include <logdepthbuf_vertex>\\n\\n\\t\\t}\",\n  fragmentShader: /* glsl */\"\\n\\t\\tuniform vec3 color;\\n\\t\\tuniform sampler2D tDiffuse;\\n\\t\\tvarying vec4 vUv;\\n\\n\\t\\t#include <logdepthbuf_pars_fragment>\\n\\n\\t\\tfloat blendOverlay( float base, float blend ) {\\n\\n\\t\\t\\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\\n\\n\\t\\t}\\n\\n\\t\\tvec3 blendOverlay( vec3 base, vec3 blend ) {\\n\\n\\t\\t\\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\\n\\n\\t\\t}\\n\\n\\t\\tvoid main() {\\n\\n\\t\\t\\t#include <logdepthbuf_fragment>\\n\\n\\t\\t\\tvec4 base = texture2DProj( tDiffuse, vUv );\\n\\t\\t\\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\\n\\n\\t\\t}\"\n};\nexport { Reflector };","map":{"version":3,"names":["Mesh","Color","Plane","Vector3","Matrix4","Vector4","PerspectiveCamera","WebGLRenderTarget","ShaderMaterial","UniformsUtils","Reflector","_Mesh","_inherits","_super","_createSuper","geometry","_this","options","arguments","length","undefined","_classCallCheck","call","type","scope","_assertThisInitialized","color","textureWidth","textureHeight","clipBias","shader","ReflectorShader","reflectorPlane","normal","reflectorWorldPosition","cameraWorldPosition","rotationMatrix","lookAtPosition","clipPlane","view","target","q","textureMatrix","virtualCamera","renderTarget","material","uniforms","clone","fragmentShader","vertexShader","value","texture","onBeforeRender","renderer","scene","camera","setFromMatrixPosition","matrixWorld","extractRotation","set","applyMatrix4","subVectors","dot","reflect","negate","add","position","copy","up","lookAt","far","updateMatrixWorld","projectionMatrix","multiply","matrixWorldInverse","setFromNormalAndCoplanarPoint","x","y","z","constant","Math","sign","elements","w","multiplyScalar","encoding","outputEncoding","visible","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","setRenderTarget","state","buffers","depth","setMask","autoClear","clear","render","viewport","dispose","_createClass","prototype","isReflector","tDiffuse"],"sources":["/home/samuel/experiment/3d/farm/frontend/node_modules/three-stdlib/objects/Reflector.js"],"sourcesContent":["import { Mesh, Color, Plane, Vector3, Matrix4, Vector4, PerspectiveCamera, WebGLRenderTarget, ShaderMaterial, UniformsUtils } from 'three';\n\nclass Reflector extends Mesh {\n  constructor(geometry, options = {}) {\n    super(geometry);\n    this.type = 'Reflector';\n    const scope = this;\n    const color = options.color !== undefined ? new Color(options.color) : new Color(0x7f7f7f);\n    const textureWidth = options.textureWidth || 512;\n    const textureHeight = options.textureHeight || 512;\n    const clipBias = options.clipBias || 0;\n    const shader = options.shader || Reflector.ReflectorShader; //\n\n    const reflectorPlane = new Plane();\n    const normal = new Vector3();\n    const reflectorWorldPosition = new Vector3();\n    const cameraWorldPosition = new Vector3();\n    const rotationMatrix = new Matrix4();\n    const lookAtPosition = new Vector3(0, 0, -1);\n    const clipPlane = new Vector4();\n    const view = new Vector3();\n    const target = new Vector3();\n    const q = new Vector4();\n    const textureMatrix = new Matrix4();\n    const virtualCamera = new PerspectiveCamera();\n    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight);\n    const material = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(shader.uniforms),\n      fragmentShader: shader.fragmentShader,\n      vertexShader: shader.vertexShader\n    });\n    material.uniforms['tDiffuse'].value = renderTarget.texture;\n    material.uniforms['color'].value = color;\n    material.uniforms['textureMatrix'].value = textureMatrix;\n    this.material = material;\n\n    this.onBeforeRender = function (renderer, scene, camera) {\n      reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n      rotationMatrix.extractRotation(scope.matrixWorld);\n      normal.set(0, 0, 1);\n      normal.applyMatrix4(rotationMatrix);\n      view.subVectors(reflectorWorldPosition, cameraWorldPosition); // Avoid rendering when reflector is facing away\n\n      if (view.dot(normal) > 0) return;\n      view.reflect(normal).negate();\n      view.add(reflectorWorldPosition);\n      rotationMatrix.extractRotation(camera.matrixWorld);\n      lookAtPosition.set(0, 0, -1);\n      lookAtPosition.applyMatrix4(rotationMatrix);\n      lookAtPosition.add(cameraWorldPosition);\n      target.subVectors(reflectorWorldPosition, lookAtPosition);\n      target.reflect(normal).negate();\n      target.add(reflectorWorldPosition);\n      virtualCamera.position.copy(view);\n      virtualCamera.up.set(0, 1, 0);\n      virtualCamera.up.applyMatrix4(rotationMatrix);\n      virtualCamera.up.reflect(normal);\n      virtualCamera.lookAt(target);\n      virtualCamera.far = camera.far; // Used in WebGLBackground\n\n      virtualCamera.updateMatrixWorld();\n      virtualCamera.projectionMatrix.copy(camera.projectionMatrix); // Update the texture matrix\n\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n      textureMatrix.multiply(virtualCamera.projectionMatrix);\n      textureMatrix.multiply(virtualCamera.matrixWorldInverse);\n      textureMatrix.multiply(scope.matrixWorld); // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n      // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\n      reflectorPlane.setFromNormalAndCoplanarPoint(normal, reflectorWorldPosition);\n      reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n      clipPlane.set(reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant);\n      const projectionMatrix = virtualCamera.projectionMatrix;\n      q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n      q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n      q.z = -1.0;\n      q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]; // Calculate the scaled plane vector\n\n      clipPlane.multiplyScalar(2.0 / clipPlane.dot(q)); // Replacing the third row of the projection matrix\n\n      projectionMatrix.elements[2] = clipPlane.x;\n      projectionMatrix.elements[6] = clipPlane.y;\n      projectionMatrix.elements[10] = clipPlane.z + 1.0 - clipBias;\n      projectionMatrix.elements[14] = clipPlane.w; // Render\n\n      renderTarget.texture.encoding = renderer.outputEncoding;\n      scope.visible = false;\n      const currentRenderTarget = renderer.getRenderTarget();\n      const currentXrEnabled = renderer.xr.enabled;\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      renderer.xr.enabled = false; // Avoid camera modification\n\n      renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n      renderer.setRenderTarget(renderTarget);\n      renderer.state.buffers.depth.setMask(true); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n      if (renderer.autoClear === false) renderer.clear();\n      renderer.render(scene, virtualCamera);\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.setRenderTarget(currentRenderTarget); // Restore viewport\n\n      const viewport = camera.viewport;\n\n      if (viewport !== undefined) {\n        renderer.state.viewport(viewport);\n      }\n\n      scope.visible = true;\n    };\n\n    this.getRenderTarget = function () {\n      return renderTarget;\n    };\n\n    this.dispose = function () {\n      renderTarget.dispose();\n      scope.material.dispose();\n    };\n  }\n\n}\n\nReflector.prototype.isReflector = true;\nReflector.ReflectorShader = {\n  uniforms: {\n    color: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    textureMatrix: {\n      value: null\n    }\n  },\n  vertexShader:\n  /* glsl */\n  `\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\t#include <common>\n\t\t#include <logdepthbuf_pars_vertex>\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t#include <logdepthbuf_vertex>\n\n\t\t}`,\n  fragmentShader:\n  /* glsl */\n  `\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tvarying vec4 vUv;\n\n\t\t#include <logdepthbuf_pars_fragment>\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t}`\n};\n\nexport { Reflector };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}