{"ast":null,"code":"import _classCallCheck from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Loader, FileLoader, TextureLoader, Points, LineSegments, Mesh, PointsMaterial, LineBasicMaterial, BufferAttribute, MeshPhongMaterial, BackSide, DoubleSide, FrontSide, Vector2, Color, AddOperation, EquirectangularRefractionMapping, EquirectangularReflectionMapping, ClampToEdgeWrapping, MirroredRepeatWrapping, RepeatWrapping, MeshPhysicalMaterial, MeshStandardMaterial, BufferGeometry, Float32BufferAttribute } from 'three';\nimport { IFFParser } from './lwo/IFFParser.js';\n\n/**\n * @version 1.1.1\n *\n * @desc Load files in LWO3 and LWO2 format on Three.js\n *\n * LWO3 format specification:\n * \thttp://static.lightwave3d.com/sdk/2018/html/filefmts/lwo3.html\n *\n * LWO2 format specification:\n * \thttp://static.lightwave3d.com/sdk/2018/html/filefmts/lwo2.html\n *\n **/\n\nvar _lwoTree;\nvar LWOLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(LWOLoader, _Loader);\n  var _super = _createSuper(LWOLoader);\n  function LWOLoader(manager) {\n    var _this;\n    var parameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, LWOLoader);\n    _this = _super.call(this, manager);\n    _this.resourcePath = parameters.resourcePath !== undefined ? parameters.resourcePath : '';\n    return _this;\n  }\n  _createClass(LWOLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var path = scope.path === '' ? extractParentUrl(url, 'Objects') : scope.path; // give the mesh a default name based on the filename\n\n      var modelName = url.split(path).pop().split('.')[0];\n      var loader = new FileLoader(this.manager);\n      loader.setPath(scope.path);\n      loader.setResponseType('arraybuffer');\n      loader.load(url, function (buffer) {\n        // console.time( 'Total parsing: ' );\n        try {\n          onLoad(scope.parse(buffer, path, modelName));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        } // console.timeEnd( 'Total parsing: ' );\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(iffBuffer, path, modelName) {\n      _lwoTree = new IFFParser().parse(iffBuffer); // console.log( 'lwoTree', lwoTree );\n\n      var textureLoader = new TextureLoader(this.manager).setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n      return new LWOTreeParser(textureLoader).parse(modelName);\n    }\n  }]);\n  return LWOLoader;\n}(Loader); // Parse the lwoTree object\nvar LWOTreeParser = /*#__PURE__*/function () {\n  function LWOTreeParser(textureLoader) {\n    _classCallCheck(this, LWOTreeParser);\n    this.textureLoader = textureLoader;\n  }\n  _createClass(LWOTreeParser, [{\n    key: \"parse\",\n    value: function parse(modelName) {\n      this.materials = new MaterialParser(this.textureLoader).parse();\n      this.defaultLayerName = modelName;\n      this.meshes = this.parseLayers();\n      return {\n        materials: this.materials,\n        meshes: this.meshes\n      };\n    }\n  }, {\n    key: \"parseLayers\",\n    value: function parseLayers() {\n      // array of all meshes for building hierarchy\n      var meshes = []; // final array containing meshes with scene graph hierarchy set up\n\n      var finalMeshes = [];\n      var geometryParser = new GeometryParser();\n      var scope = this;\n      _lwoTree.layers.forEach(function (layer) {\n        var geometry = geometryParser.parse(layer.geometry, layer);\n        var mesh = scope.parseMesh(geometry, layer);\n        meshes[layer.number] = mesh;\n        if (layer.parent === -1) finalMeshes.push(mesh);else meshes[layer.parent].add(mesh);\n      });\n      this.applyPivots(finalMeshes);\n      return finalMeshes;\n    }\n  }, {\n    key: \"parseMesh\",\n    value: function parseMesh(geometry, layer) {\n      var mesh;\n      var materials = this.getMaterials(geometry.userData.matNames, layer.geometry.type);\n      this.duplicateUVs(geometry, materials);\n      if (layer.geometry.type === 'points') mesh = new Points(geometry, materials);else if (layer.geometry.type === 'lines') mesh = new LineSegments(geometry, materials);else mesh = new Mesh(geometry, materials);\n      if (layer.name) mesh.name = layer.name;else mesh.name = this.defaultLayerName + '_layer_' + layer.number;\n      mesh.userData.pivot = layer.pivot;\n      return mesh;\n    } // TODO: may need to be reversed in z to convert LWO to three.js coordinates\n  }, {\n    key: \"applyPivots\",\n    value: function applyPivots(meshes) {\n      meshes.forEach(function (mesh) {\n        mesh.traverse(function (child) {\n          var pivot = child.userData.pivot;\n          child.position.x += pivot[0];\n          child.position.y += pivot[1];\n          child.position.z += pivot[2];\n          if (child.parent) {\n            var parentPivot = child.parent.userData.pivot;\n            child.position.x -= parentPivot[0];\n            child.position.y -= parentPivot[1];\n            child.position.z -= parentPivot[2];\n          }\n        });\n      });\n    }\n  }, {\n    key: \"getMaterials\",\n    value: function getMaterials(namesArray, type) {\n      var materials = [];\n      var scope = this;\n      namesArray.forEach(function (name, i) {\n        materials[i] = scope.getMaterialByName(name);\n      }); // convert materials to line or point mats if required\n\n      if (type === 'points' || type === 'lines') {\n        materials.forEach(function (mat, i) {\n          var spec = {\n            color: mat.color\n          };\n          if (type === 'points') {\n            spec.size = 0.1;\n            spec.map = mat.map;\n            spec.morphTargets = mat.morphTargets;\n            materials[i] = new PointsMaterial(spec);\n          } else if (type === 'lines') {\n            materials[i] = new LineBasicMaterial(spec);\n          }\n        });\n      } // if there is only one material, return that directly instead of array\n\n      var filtered = materials.filter(Boolean);\n      if (filtered.length === 1) return filtered[0];\n      return materials;\n    }\n  }, {\n    key: \"getMaterialByName\",\n    value: function getMaterialByName(name) {\n      return this.materials.filter(function (m) {\n        return m.name === name;\n      })[0];\n    } // If the material has an aoMap, duplicate UVs\n  }, {\n    key: \"duplicateUVs\",\n    value: function duplicateUVs(geometry, materials) {\n      var duplicateUVs = false;\n      if (!Array.isArray(materials)) {\n        if (materials.aoMap) duplicateUVs = true;\n      } else {\n        materials.forEach(function (material) {\n          if (material.aoMap) duplicateUVs = true;\n        });\n      }\n      if (!duplicateUVs) return;\n      geometry.setAttribute('uv2', new BufferAttribute(geometry.attributes.uv.array, 2));\n    }\n  }]);\n  return LWOTreeParser;\n}();\nvar MaterialParser = /*#__PURE__*/function () {\n  function MaterialParser(textureLoader) {\n    _classCallCheck(this, MaterialParser);\n    this.textureLoader = textureLoader;\n  }\n  _createClass(MaterialParser, [{\n    key: \"parse\",\n    value: function parse() {\n      var materials = [];\n      this.textures = {};\n      for (var name in _lwoTree.materials) {\n        if (_lwoTree.format === 'LWO3') {\n          materials.push(this.parseMaterial(_lwoTree.materials[name], name, _lwoTree.textures));\n        } else if (_lwoTree.format === 'LWO2') {\n          materials.push(this.parseMaterialLwo2(_lwoTree.materials[name], name, _lwoTree.textures));\n        }\n      }\n      return materials;\n    }\n  }, {\n    key: \"parseMaterial\",\n    value: function parseMaterial(materialData, name, textures) {\n      var params = {\n        name: name,\n        side: this.getSide(materialData.attributes),\n        flatShading: this.getSmooth(materialData.attributes)\n      };\n      var connections = this.parseConnections(materialData.connections, materialData.nodes);\n      var maps = this.parseTextureNodes(connections.maps);\n      this.parseAttributeImageMaps(connections.attributes, textures, maps, materialData.maps);\n      var attributes = this.parseAttributes(connections.attributes, maps);\n      this.parseEnvMap(connections, maps, attributes);\n      params = Object.assign(maps, params);\n      params = Object.assign(params, attributes);\n      var materialType = this.getMaterialType(connections.attributes);\n      return new materialType(params);\n    }\n  }, {\n    key: \"parseMaterialLwo2\",\n    value: function parseMaterialLwo2(materialData, name\n    /*, textures*/) {\n      var params = {\n        name: name,\n        side: this.getSide(materialData.attributes),\n        flatShading: this.getSmooth(materialData.attributes)\n      };\n      var attributes = this.parseAttributes(materialData.attributes, {});\n      params = Object.assign(params, attributes);\n      return new MeshPhongMaterial(params);\n    } // Note: converting from left to right handed coords by switching x -> -x in vertices, and\n    // then switching mat FrontSide -> BackSide\n    // NB: this means that FrontSide and BackSide have been switched!\n  }, {\n    key: \"getSide\",\n    value: function getSide(attributes) {\n      if (!attributes.side) return BackSide;\n      switch (attributes.side) {\n        case 0:\n        case 1:\n          return BackSide;\n        case 2:\n          return FrontSide;\n        case 3:\n          return DoubleSide;\n      }\n    }\n  }, {\n    key: \"getSmooth\",\n    value: function getSmooth(attributes) {\n      if (!attributes.smooth) return true;\n      return !attributes.smooth;\n    }\n  }, {\n    key: \"parseConnections\",\n    value: function parseConnections(connections, nodes) {\n      var materialConnections = {\n        maps: {}\n      };\n      var inputName = connections.inputName;\n      var inputNodeName = connections.inputNodeName;\n      var nodeName = connections.nodeName;\n      var scope = this;\n      inputName.forEach(function (name, index) {\n        if (name === 'Material') {\n          var matNode = scope.getNodeByRefName(inputNodeName[index], nodes);\n          materialConnections.attributes = matNode.attributes;\n          materialConnections.envMap = matNode.fileName;\n          materialConnections.name = inputNodeName[index];\n        }\n      });\n      nodeName.forEach(function (name, index) {\n        if (name === materialConnections.name) {\n          materialConnections.maps[inputName[index]] = scope.getNodeByRefName(inputNodeName[index], nodes);\n        }\n      });\n      return materialConnections;\n    }\n  }, {\n    key: \"getNodeByRefName\",\n    value: function getNodeByRefName(refName, nodes) {\n      for (var name in nodes) {\n        if (nodes[name].refName === refName) return nodes[name];\n      }\n    }\n  }, {\n    key: \"parseTextureNodes\",\n    value: function parseTextureNodes(textureNodes) {\n      var maps = {};\n      for (var name in textureNodes) {\n        var node = textureNodes[name];\n        var path = node.fileName;\n        if (!path) return;\n        var texture = this.loadTexture(path);\n        if (node.widthWrappingMode !== undefined) texture.wrapS = this.getWrappingType(node.widthWrappingMode);\n        if (node.heightWrappingMode !== undefined) texture.wrapT = this.getWrappingType(node.heightWrappingMode);\n        switch (name) {\n          case 'Color':\n            maps.map = texture;\n            break;\n          case 'Roughness':\n            maps.roughnessMap = texture;\n            maps.roughness = 0.5;\n            break;\n          case 'Specular':\n            maps.specularMap = texture;\n            maps.specular = 0xffffff;\n            break;\n          case 'Luminous':\n            maps.emissiveMap = texture;\n            maps.emissive = 0x808080;\n            break;\n          case 'Luminous Color':\n            maps.emissive = 0x808080;\n            break;\n          case 'Metallic':\n            maps.metalnessMap = texture;\n            maps.metalness = 0.5;\n            break;\n          case 'Transparency':\n          case 'Alpha':\n            maps.alphaMap = texture;\n            maps.transparent = true;\n            break;\n          case 'Normal':\n            maps.normalMap = texture;\n            if (node.amplitude !== undefined) maps.normalScale = new Vector2(node.amplitude, node.amplitude);\n            break;\n          case 'Bump':\n            maps.bumpMap = texture;\n            break;\n        }\n      } // LWO BSDF materials can have both spec and rough, but this is not valid in three\n\n      if (maps.roughnessMap && maps.specularMap) delete maps.specularMap;\n      return maps;\n    } // maps can also be defined on individual material attributes, parse those here\n    // This occurs on Standard (Phong) surfaces\n  }, {\n    key: \"parseAttributeImageMaps\",\n    value: function parseAttributeImageMaps(attributes, textures, maps) {\n      for (var name in attributes) {\n        var attribute = attributes[name];\n        if (attribute.maps) {\n          var mapData = attribute.maps[0];\n          var path = this.getTexturePathByIndex(mapData.imageIndex, textures);\n          if (!path) return;\n          var texture = this.loadTexture(path);\n          if (mapData.wrap !== undefined) texture.wrapS = this.getWrappingType(mapData.wrap.w);\n          if (mapData.wrap !== undefined) texture.wrapT = this.getWrappingType(mapData.wrap.h);\n          switch (name) {\n            case 'Color':\n              maps.map = texture;\n              break;\n            case 'Diffuse':\n              maps.aoMap = texture;\n              break;\n            case 'Roughness':\n              maps.roughnessMap = texture;\n              maps.roughness = 1;\n              break;\n            case 'Specular':\n              maps.specularMap = texture;\n              maps.specular = 0xffffff;\n              break;\n            case 'Luminosity':\n              maps.emissiveMap = texture;\n              maps.emissive = 0x808080;\n              break;\n            case 'Metallic':\n              maps.metalnessMap = texture;\n              maps.metalness = 1;\n              break;\n            case 'Transparency':\n            case 'Alpha':\n              maps.alphaMap = texture;\n              maps.transparent = true;\n              break;\n            case 'Normal':\n              maps.normalMap = texture;\n              break;\n            case 'Bump':\n              maps.bumpMap = texture;\n              break;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"parseAttributes\",\n    value: function parseAttributes(attributes, maps) {\n      var params = {}; // don't use color data if color map is present\n\n      if (attributes.Color && !maps.map) {\n        params.color = new Color().fromArray(attributes.Color.value);\n      } else {\n        params.color = new Color();\n      }\n      if (attributes.Transparency && attributes.Transparency.value !== 0) {\n        params.opacity = 1 - attributes.Transparency.value;\n        params.transparent = true;\n      }\n      if (attributes['Bump Height']) params.bumpScale = attributes['Bump Height'].value * 0.1;\n      if (attributes['Refraction Index']) params.refractionRatio = 1 / attributes['Refraction Index'].value;\n      this.parsePhysicalAttributes(params, attributes, maps);\n      this.parseStandardAttributes(params, attributes, maps);\n      this.parsePhongAttributes(params, attributes, maps);\n      return params;\n    }\n  }, {\n    key: \"parsePhysicalAttributes\",\n    value: function parsePhysicalAttributes(params, attributes\n    /*, maps*/) {\n      if (attributes.Clearcoat && attributes.Clearcoat.value > 0) {\n        params.clearcoat = attributes.Clearcoat.value;\n        if (attributes['Clearcoat Gloss']) {\n          params.clearcoatRoughness = 0.5 * (1 - attributes['Clearcoat Gloss'].value);\n        }\n      }\n    }\n  }, {\n    key: \"parseStandardAttributes\",\n    value: function parseStandardAttributes(params, attributes, maps) {\n      if (attributes.Luminous) {\n        params.emissiveIntensity = attributes.Luminous.value;\n        if (attributes['Luminous Color'] && !maps.emissive) {\n          params.emissive = new Color().fromArray(attributes['Luminous Color'].value);\n        } else {\n          params.emissive = new Color(0x808080);\n        }\n      }\n      if (attributes.Roughness && !maps.roughnessMap) params.roughness = attributes.Roughness.value;\n      if (attributes.Metallic && !maps.metalnessMap) params.metalness = attributes.Metallic.value;\n    }\n  }, {\n    key: \"parsePhongAttributes\",\n    value: function parsePhongAttributes(params, attributes, maps) {\n      if (attributes.Diffuse) params.color.multiplyScalar(attributes.Diffuse.value);\n      if (attributes.Reflection) {\n        params.reflectivity = attributes.Reflection.value;\n        params.combine = AddOperation;\n      }\n      if (attributes.Luminosity) {\n        params.emissiveIntensity = attributes.Luminosity.value;\n        if (!maps.emissiveMap && !maps.map) {\n          params.emissive = params.color;\n        } else {\n          params.emissive = new Color(0x808080);\n        }\n      } // parse specular if there is no roughness - we will interpret the material as 'Phong' in this case\n\n      if (!attributes.Roughness && attributes.Specular && !maps.specularMap) {\n        if (attributes['Color Highlight']) {\n          params.specular = new Color().setScalar(attributes.Specular.value).lerp(params.color.clone().multiplyScalar(attributes.Specular.value), attributes['Color Highlight'].value);\n        } else {\n          params.specular = new Color().setScalar(attributes.Specular.value);\n        }\n      }\n      if (params.specular && attributes.Glossiness) {\n        params.shininess = 7 + Math.pow(2, attributes.Glossiness.value * 12 + 2);\n      }\n    }\n  }, {\n    key: \"parseEnvMap\",\n    value: function parseEnvMap(connections, maps, attributes) {\n      if (connections.envMap) {\n        var envMap = this.loadTexture(connections.envMap);\n        if (attributes.transparent && attributes.opacity < 0.999) {\n          envMap.mapping = EquirectangularRefractionMapping; // Reflectivity and refraction mapping don't work well together in Phong materials\n\n          if (attributes.reflectivity !== undefined) {\n            delete attributes.reflectivity;\n            delete attributes.combine;\n          }\n          if (attributes.metalness !== undefined) {\n            delete attributes.metalness;\n          }\n        } else {\n          envMap.mapping = EquirectangularReflectionMapping;\n        }\n        maps.envMap = envMap;\n      }\n    } // get texture defined at top level by its index\n  }, {\n    key: \"getTexturePathByIndex\",\n    value: function getTexturePathByIndex(index) {\n      var fileName = '';\n      if (!_lwoTree.textures) return fileName;\n      _lwoTree.textures.forEach(function (texture) {\n        if (texture.index === index) fileName = texture.fileName;\n      });\n      return fileName;\n    }\n  }, {\n    key: \"loadTexture\",\n    value: function loadTexture(path) {\n      if (!path) return null;\n      var texture = this.textureLoader.load(path, undefined, undefined, function () {\n        console.warn('LWOLoader: non-standard resource hierarchy. Use `resourcePath` parameter to specify root content directory.');\n      });\n      return texture;\n    } // 0 = Reset, 1 = Repeat, 2 = Mirror, 3 = Edge\n  }, {\n    key: \"getWrappingType\",\n    value: function getWrappingType(num) {\n      switch (num) {\n        case 0:\n          console.warn('LWOLoader: \"Reset\" texture wrapping type is not supported in three.js');\n          return ClampToEdgeWrapping;\n        case 1:\n          return RepeatWrapping;\n        case 2:\n          return MirroredRepeatWrapping;\n        case 3:\n          return ClampToEdgeWrapping;\n      }\n    }\n  }, {\n    key: \"getMaterialType\",\n    value: function getMaterialType(nodeData) {\n      if (nodeData.Clearcoat && nodeData.Clearcoat.value > 0) return MeshPhysicalMaterial;\n      if (nodeData.Roughness) return MeshStandardMaterial;\n      return MeshPhongMaterial;\n    }\n  }]);\n  return MaterialParser;\n}();\nvar GeometryParser = /*#__PURE__*/function () {\n  function GeometryParser() {\n    _classCallCheck(this, GeometryParser);\n  }\n  _createClass(GeometryParser, [{\n    key: \"parse\",\n    value: function parse(geoData, layer) {\n      var geometry = new BufferGeometry();\n      geometry.setAttribute('position', new Float32BufferAttribute(geoData.points, 3));\n      var indices = this.splitIndices(geoData.vertexIndices, geoData.polygonDimensions);\n      geometry.setIndex(indices);\n      this.parseGroups(geometry, geoData);\n      geometry.computeVertexNormals();\n      this.parseUVs(geometry, layer, indices);\n      this.parseMorphTargets(geometry, layer, indices); // TODO: z may need to be reversed to account for coordinate system change\n\n      geometry.translate(-layer.pivot[0], -layer.pivot[1], -layer.pivot[2]); // let userData = geometry.userData;\n      // geometry = geometry.toNonIndexed()\n      // geometry.userData = userData;\n\n      return geometry;\n    } // split quads into tris\n  }, {\n    key: \"splitIndices\",\n    value: function splitIndices(indices, polygonDimensions) {\n      var remappedIndices = [];\n      var i = 0;\n      polygonDimensions.forEach(function (dim) {\n        if (dim < 4) {\n          for (var k = 0; k < dim; k++) remappedIndices.push(indices[i + k]);\n        } else if (dim === 4) {\n          remappedIndices.push(indices[i], indices[i + 1], indices[i + 2], indices[i], indices[i + 2], indices[i + 3]);\n        } else if (dim > 4) {\n          for (var _k = 1; _k < dim - 1; _k++) {\n            remappedIndices.push(indices[i], indices[i + _k], indices[i + _k + 1]);\n          }\n          console.warn('LWOLoader: polygons with greater than 4 sides are not supported');\n        }\n        i += dim;\n      });\n      return remappedIndices;\n    } // NOTE: currently ignoring poly indices and assuming that they are intelligently ordered\n  }, {\n    key: \"parseGroups\",\n    value: function parseGroups(geometry, geoData) {\n      var tags = _lwoTree.tags;\n      var matNames = [];\n      var elemSize = 3;\n      if (geoData.type === 'lines') elemSize = 2;\n      if (geoData.type === 'points') elemSize = 1;\n      var remappedIndices = this.splitMaterialIndices(geoData.polygonDimensions, geoData.materialIndices);\n      var indexNum = 0; // create new indices in numerical order\n\n      var indexPairs = {}; // original indices mapped to numerical indices\n\n      var prevMaterialIndex;\n      var materialIndex;\n      var prevStart = 0;\n      var currentCount = 0;\n      for (var i = 0; i < remappedIndices.length; i += 2) {\n        materialIndex = remappedIndices[i + 1];\n        if (i === 0) matNames[indexNum] = tags[materialIndex];\n        if (prevMaterialIndex === undefined) prevMaterialIndex = materialIndex;\n        if (materialIndex !== prevMaterialIndex) {\n          var currentIndex = void 0;\n          if (indexPairs[tags[prevMaterialIndex]]) {\n            currentIndex = indexPairs[tags[prevMaterialIndex]];\n          } else {\n            currentIndex = indexNum;\n            indexPairs[tags[prevMaterialIndex]] = indexNum;\n            matNames[indexNum] = tags[prevMaterialIndex];\n            indexNum++;\n          }\n          geometry.addGroup(prevStart, currentCount, currentIndex);\n          prevStart += currentCount;\n          prevMaterialIndex = materialIndex;\n          currentCount = 0;\n        }\n        currentCount += elemSize;\n      } // the loop above doesn't add the last group, do that here.\n\n      if (geometry.groups.length > 0) {\n        var _currentIndex;\n        if (indexPairs[tags[materialIndex]]) {\n          _currentIndex = indexPairs[tags[materialIndex]];\n        } else {\n          _currentIndex = indexNum;\n          indexPairs[tags[materialIndex]] = indexNum;\n          matNames[indexNum] = tags[materialIndex];\n        }\n        geometry.addGroup(prevStart, currentCount, _currentIndex);\n      } // Mat names from TAGS chunk, used to build up an array of materials for this geometry\n\n      geometry.userData.matNames = matNames;\n    }\n  }, {\n    key: \"splitMaterialIndices\",\n    value: function splitMaterialIndices(polygonDimensions, indices) {\n      var remappedIndices = [];\n      polygonDimensions.forEach(function (dim, i) {\n        if (dim <= 3) {\n          remappedIndices.push(indices[i * 2], indices[i * 2 + 1]);\n        } else if (dim === 4) {\n          remappedIndices.push(indices[i * 2], indices[i * 2 + 1], indices[i * 2], indices[i * 2 + 1]);\n        } else {\n          // ignore > 4 for now\n          for (var k = 0; k < dim - 2; k++) {\n            remappedIndices.push(indices[i * 2], indices[i * 2 + 1]);\n          }\n        }\n      });\n      return remappedIndices;\n    } // UV maps:\n    // 1: are defined via index into an array of points, not into a geometry\n    // - the geometry is also defined by an index into this array, but the indexes may not match\n    // 2: there can be any number of UV maps for a single geometry. Here these are combined,\n    // \twith preference given to the first map encountered\n    // 3: UV maps can be partial - that is, defined for only a part of the geometry\n    // 4: UV maps can be VMAP or VMAD (discontinuous, to allow for seams). In practice, most\n    // UV maps are defined as partially VMAP and partially VMAD\n    // VMADs are currently not supported\n  }, {\n    key: \"parseUVs\",\n    value: function parseUVs(geometry, layer) {\n      // start by creating a UV map set to zero for the whole geometry\n      var remappedUVs = Array.from(Array(geometry.attributes.position.count * 2), function () {\n        return 0;\n      });\n      var _loop = function _loop() {\n        var uvs = layer.uvs[name].uvs;\n        var uvIndices = layer.uvs[name].uvIndices;\n        uvIndices.forEach(function (i, j) {\n          remappedUVs[i * 2] = uvs[j * 2];\n          remappedUVs[i * 2 + 1] = uvs[j * 2 + 1];\n        });\n      };\n      for (var name in layer.uvs) {\n        _loop();\n      }\n      geometry.setAttribute('uv', new Float32BufferAttribute(remappedUVs, 2));\n    }\n  }, {\n    key: \"parseMorphTargets\",\n    value: function parseMorphTargets(geometry, layer) {\n      var num = 0;\n      var _loop2 = function _loop2() {\n        var remappedPoints = geometry.attributes.position.array.slice();\n        if (!geometry.morphAttributes.position) geometry.morphAttributes.position = [];\n        var morphPoints = layer.morphTargets[name].points;\n        var morphIndices = layer.morphTargets[name].indices;\n        var type = layer.morphTargets[name].type;\n        morphIndices.forEach(function (i, j) {\n          if (type === 'relative') {\n            remappedPoints[i * 3] += morphPoints[j * 3];\n            remappedPoints[i * 3 + 1] += morphPoints[j * 3 + 1];\n            remappedPoints[i * 3 + 2] += morphPoints[j * 3 + 2];\n          } else {\n            remappedPoints[i * 3] = morphPoints[j * 3];\n            remappedPoints[i * 3 + 1] = morphPoints[j * 3 + 1];\n            remappedPoints[i * 3 + 2] = morphPoints[j * 3 + 2];\n          }\n        });\n        geometry.morphAttributes.position[num] = new Float32BufferAttribute(remappedPoints, 3);\n        geometry.morphAttributes.position[num].name = name;\n        num++;\n      };\n      for (var name in layer.morphTargets) {\n        _loop2();\n      }\n      geometry.morphTargetsRelative = false;\n    }\n  }]);\n  return GeometryParser;\n}(); // ************** UTILITY FUNCTIONS **************\nfunction extractParentUrl(url, dir) {\n  var index = url.indexOf(dir);\n  if (index === -1) return './';\n  return url.substr(0, index);\n}\nexport { LWOLoader };","map":{"version":3,"names":["Loader","FileLoader","TextureLoader","Points","LineSegments","Mesh","PointsMaterial","LineBasicMaterial","BufferAttribute","MeshPhongMaterial","BackSide","DoubleSide","FrontSide","Vector2","Color","AddOperation","EquirectangularRefractionMapping","EquirectangularReflectionMapping","ClampToEdgeWrapping","MirroredRepeatWrapping","RepeatWrapping","MeshPhysicalMaterial","MeshStandardMaterial","BufferGeometry","Float32BufferAttribute","IFFParser","_lwoTree","LWOLoader","_Loader","_inherits","_super","_createSuper","manager","_this","parameters","arguments","length","undefined","_classCallCheck","call","resourcePath","_createClass","key","value","load","url","onLoad","onProgress","onError","scope","path","extractParentUrl","modelName","split","pop","loader","setPath","setResponseType","buffer","parse","e","console","error","itemError","iffBuffer","textureLoader","setCrossOrigin","crossOrigin","LWOTreeParser","materials","MaterialParser","defaultLayerName","meshes","parseLayers","finalMeshes","geometryParser","GeometryParser","layers","forEach","layer","geometry","mesh","parseMesh","number","parent","push","add","applyPivots","getMaterials","userData","matNames","type","duplicateUVs","name","pivot","traverse","child","position","x","y","z","parentPivot","namesArray","i","getMaterialByName","mat","spec","color","size","map","morphTargets","filtered","filter","Boolean","m","Array","isArray","aoMap","material","setAttribute","attributes","uv","array","textures","format","parseMaterial","parseMaterialLwo2","materialData","params","side","getSide","flatShading","getSmooth","connections","parseConnections","nodes","maps","parseTextureNodes","parseAttributeImageMaps","parseAttributes","parseEnvMap","Object","assign","materialType","getMaterialType","smooth","materialConnections","inputName","inputNodeName","nodeName","index","matNode","getNodeByRefName","envMap","fileName","refName","textureNodes","node","texture","loadTexture","widthWrappingMode","wrapS","getWrappingType","heightWrappingMode","wrapT","roughnessMap","roughness","specularMap","specular","emissiveMap","emissive","metalnessMap","metalness","alphaMap","transparent","normalMap","amplitude","normalScale","bumpMap","attribute","mapData","getTexturePathByIndex","imageIndex","wrap","w","h","fromArray","Transparency","opacity","bumpScale","refractionRatio","parsePhysicalAttributes","parseStandardAttributes","parsePhongAttributes","Clearcoat","clearcoat","clearcoatRoughness","Luminous","emissiveIntensity","Roughness","Metallic","Diffuse","multiplyScalar","Reflection","reflectivity","combine","Luminosity","Specular","setScalar","lerp","clone","Glossiness","shininess","Math","pow","mapping","warn","num","nodeData","geoData","points","indices","splitIndices","vertexIndices","polygonDimensions","setIndex","parseGroups","computeVertexNormals","parseUVs","parseMorphTargets","translate","remappedIndices","dim","k","tags","elemSize","splitMaterialIndices","materialIndices","indexNum","indexPairs","prevMaterialIndex","materialIndex","prevStart","currentCount","currentIndex","addGroup","groups","remappedUVs","from","count","_loop","uvs","uvIndices","j","_loop2","remappedPoints","slice","morphAttributes","morphPoints","morphIndices","morphTargetsRelative","dir","indexOf","substr"],"sources":["/home/samuel/experiment/3d/farm/frontend/node_modules/three-stdlib/loaders/LWOLoader.js"],"sourcesContent":["import { Loader, FileLoader, TextureLoader, Points, LineSegments, Mesh, PointsMaterial, LineBasicMaterial, BufferAttribute, MeshPhongMaterial, BackSide, DoubleSide, FrontSide, Vector2, Color, AddOperation, EquirectangularRefractionMapping, EquirectangularReflectionMapping, ClampToEdgeWrapping, MirroredRepeatWrapping, RepeatWrapping, MeshPhysicalMaterial, MeshStandardMaterial, BufferGeometry, Float32BufferAttribute } from 'three';\nimport { IFFParser } from './lwo/IFFParser.js';\n\n/**\n * @version 1.1.1\n *\n * @desc Load files in LWO3 and LWO2 format on Three.js\n *\n * LWO3 format specification:\n * \thttp://static.lightwave3d.com/sdk/2018/html/filefmts/lwo3.html\n *\n * LWO2 format specification:\n * \thttp://static.lightwave3d.com/sdk/2018/html/filefmts/lwo2.html\n *\n **/\n\nlet _lwoTree;\n\nclass LWOLoader extends Loader {\n  constructor(manager, parameters = {}) {\n    super(manager);\n    this.resourcePath = parameters.resourcePath !== undefined ? parameters.resourcePath : '';\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const path = scope.path === '' ? extractParentUrl(url, 'Objects') : scope.path; // give the mesh a default name based on the filename\n\n    const modelName = url.split(path).pop().split('.')[0];\n    const loader = new FileLoader(this.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType('arraybuffer');\n    loader.load(url, function (buffer) {\n      // console.time( 'Total parsing: ' );\n      try {\n        onLoad(scope.parse(buffer, path, modelName));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n      } // console.timeEnd( 'Total parsing: ' );\n\n    }, onProgress, onError);\n  }\n\n  parse(iffBuffer, path, modelName) {\n    _lwoTree = new IFFParser().parse(iffBuffer); // console.log( 'lwoTree', lwoTree );\n\n    const textureLoader = new TextureLoader(this.manager).setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n    return new LWOTreeParser(textureLoader).parse(modelName);\n  }\n\n} // Parse the lwoTree object\n\n\nclass LWOTreeParser {\n  constructor(textureLoader) {\n    this.textureLoader = textureLoader;\n  }\n\n  parse(modelName) {\n    this.materials = new MaterialParser(this.textureLoader).parse();\n    this.defaultLayerName = modelName;\n    this.meshes = this.parseLayers();\n    return {\n      materials: this.materials,\n      meshes: this.meshes\n    };\n  }\n\n  parseLayers() {\n    // array of all meshes for building hierarchy\n    const meshes = []; // final array containing meshes with scene graph hierarchy set up\n\n    const finalMeshes = [];\n    const geometryParser = new GeometryParser();\n    const scope = this;\n\n    _lwoTree.layers.forEach(function (layer) {\n      const geometry = geometryParser.parse(layer.geometry, layer);\n      const mesh = scope.parseMesh(geometry, layer);\n      meshes[layer.number] = mesh;\n      if (layer.parent === -1) finalMeshes.push(mesh);else meshes[layer.parent].add(mesh);\n    });\n\n    this.applyPivots(finalMeshes);\n    return finalMeshes;\n  }\n\n  parseMesh(geometry, layer) {\n    let mesh;\n    const materials = this.getMaterials(geometry.userData.matNames, layer.geometry.type);\n    this.duplicateUVs(geometry, materials);\n    if (layer.geometry.type === 'points') mesh = new Points(geometry, materials);else if (layer.geometry.type === 'lines') mesh = new LineSegments(geometry, materials);else mesh = new Mesh(geometry, materials);\n    if (layer.name) mesh.name = layer.name;else mesh.name = this.defaultLayerName + '_layer_' + layer.number;\n    mesh.userData.pivot = layer.pivot;\n    return mesh;\n  } // TODO: may need to be reversed in z to convert LWO to three.js coordinates\n\n\n  applyPivots(meshes) {\n    meshes.forEach(function (mesh) {\n      mesh.traverse(function (child) {\n        const pivot = child.userData.pivot;\n        child.position.x += pivot[0];\n        child.position.y += pivot[1];\n        child.position.z += pivot[2];\n\n        if (child.parent) {\n          const parentPivot = child.parent.userData.pivot;\n          child.position.x -= parentPivot[0];\n          child.position.y -= parentPivot[1];\n          child.position.z -= parentPivot[2];\n        }\n      });\n    });\n  }\n\n  getMaterials(namesArray, type) {\n    const materials = [];\n    const scope = this;\n    namesArray.forEach(function (name, i) {\n      materials[i] = scope.getMaterialByName(name);\n    }); // convert materials to line or point mats if required\n\n    if (type === 'points' || type === 'lines') {\n      materials.forEach(function (mat, i) {\n        const spec = {\n          color: mat.color\n        };\n\n        if (type === 'points') {\n          spec.size = 0.1;\n          spec.map = mat.map;\n          spec.morphTargets = mat.morphTargets;\n          materials[i] = new PointsMaterial(spec);\n        } else if (type === 'lines') {\n          materials[i] = new LineBasicMaterial(spec);\n        }\n      });\n    } // if there is only one material, return that directly instead of array\n\n\n    const filtered = materials.filter(Boolean);\n    if (filtered.length === 1) return filtered[0];\n    return materials;\n  }\n\n  getMaterialByName(name) {\n    return this.materials.filter(function (m) {\n      return m.name === name;\n    })[0];\n  } // If the material has an aoMap, duplicate UVs\n\n\n  duplicateUVs(geometry, materials) {\n    let duplicateUVs = false;\n\n    if (!Array.isArray(materials)) {\n      if (materials.aoMap) duplicateUVs = true;\n    } else {\n      materials.forEach(function (material) {\n        if (material.aoMap) duplicateUVs = true;\n      });\n    }\n\n    if (!duplicateUVs) return;\n    geometry.setAttribute('uv2', new BufferAttribute(geometry.attributes.uv.array, 2));\n  }\n\n}\n\nclass MaterialParser {\n  constructor(textureLoader) {\n    this.textureLoader = textureLoader;\n  }\n\n  parse() {\n    const materials = [];\n    this.textures = {};\n\n    for (const name in _lwoTree.materials) {\n      if (_lwoTree.format === 'LWO3') {\n        materials.push(this.parseMaterial(_lwoTree.materials[name], name, _lwoTree.textures));\n      } else if (_lwoTree.format === 'LWO2') {\n        materials.push(this.parseMaterialLwo2(_lwoTree.materials[name], name, _lwoTree.textures));\n      }\n    }\n\n    return materials;\n  }\n\n  parseMaterial(materialData, name, textures) {\n    let params = {\n      name: name,\n      side: this.getSide(materialData.attributes),\n      flatShading: this.getSmooth(materialData.attributes)\n    };\n    const connections = this.parseConnections(materialData.connections, materialData.nodes);\n    const maps = this.parseTextureNodes(connections.maps);\n    this.parseAttributeImageMaps(connections.attributes, textures, maps, materialData.maps);\n    const attributes = this.parseAttributes(connections.attributes, maps);\n    this.parseEnvMap(connections, maps, attributes);\n    params = Object.assign(maps, params);\n    params = Object.assign(params, attributes);\n    const materialType = this.getMaterialType(connections.attributes);\n    return new materialType(params);\n  }\n\n  parseMaterialLwo2(materialData, name\n  /*, textures*/\n  ) {\n    let params = {\n      name: name,\n      side: this.getSide(materialData.attributes),\n      flatShading: this.getSmooth(materialData.attributes)\n    };\n    const attributes = this.parseAttributes(materialData.attributes, {});\n    params = Object.assign(params, attributes);\n    return new MeshPhongMaterial(params);\n  } // Note: converting from left to right handed coords by switching x -> -x in vertices, and\n  // then switching mat FrontSide -> BackSide\n  // NB: this means that FrontSide and BackSide have been switched!\n\n\n  getSide(attributes) {\n    if (!attributes.side) return BackSide;\n\n    switch (attributes.side) {\n      case 0:\n      case 1:\n        return BackSide;\n\n      case 2:\n        return FrontSide;\n\n      case 3:\n        return DoubleSide;\n    }\n  }\n\n  getSmooth(attributes) {\n    if (!attributes.smooth) return true;\n    return !attributes.smooth;\n  }\n\n  parseConnections(connections, nodes) {\n    const materialConnections = {\n      maps: {}\n    };\n    const inputName = connections.inputName;\n    const inputNodeName = connections.inputNodeName;\n    const nodeName = connections.nodeName;\n    const scope = this;\n    inputName.forEach(function (name, index) {\n      if (name === 'Material') {\n        const matNode = scope.getNodeByRefName(inputNodeName[index], nodes);\n        materialConnections.attributes = matNode.attributes;\n        materialConnections.envMap = matNode.fileName;\n        materialConnections.name = inputNodeName[index];\n      }\n    });\n    nodeName.forEach(function (name, index) {\n      if (name === materialConnections.name) {\n        materialConnections.maps[inputName[index]] = scope.getNodeByRefName(inputNodeName[index], nodes);\n      }\n    });\n    return materialConnections;\n  }\n\n  getNodeByRefName(refName, nodes) {\n    for (const name in nodes) {\n      if (nodes[name].refName === refName) return nodes[name];\n    }\n  }\n\n  parseTextureNodes(textureNodes) {\n    const maps = {};\n\n    for (const name in textureNodes) {\n      const node = textureNodes[name];\n      const path = node.fileName;\n      if (!path) return;\n      const texture = this.loadTexture(path);\n      if (node.widthWrappingMode !== undefined) texture.wrapS = this.getWrappingType(node.widthWrappingMode);\n      if (node.heightWrappingMode !== undefined) texture.wrapT = this.getWrappingType(node.heightWrappingMode);\n\n      switch (name) {\n        case 'Color':\n          maps.map = texture;\n          break;\n\n        case 'Roughness':\n          maps.roughnessMap = texture;\n          maps.roughness = 0.5;\n          break;\n\n        case 'Specular':\n          maps.specularMap = texture;\n          maps.specular = 0xffffff;\n          break;\n\n        case 'Luminous':\n          maps.emissiveMap = texture;\n          maps.emissive = 0x808080;\n          break;\n\n        case 'Luminous Color':\n          maps.emissive = 0x808080;\n          break;\n\n        case 'Metallic':\n          maps.metalnessMap = texture;\n          maps.metalness = 0.5;\n          break;\n\n        case 'Transparency':\n        case 'Alpha':\n          maps.alphaMap = texture;\n          maps.transparent = true;\n          break;\n\n        case 'Normal':\n          maps.normalMap = texture;\n          if (node.amplitude !== undefined) maps.normalScale = new Vector2(node.amplitude, node.amplitude);\n          break;\n\n        case 'Bump':\n          maps.bumpMap = texture;\n          break;\n      }\n    } // LWO BSDF materials can have both spec and rough, but this is not valid in three\n\n\n    if (maps.roughnessMap && maps.specularMap) delete maps.specularMap;\n    return maps;\n  } // maps can also be defined on individual material attributes, parse those here\n  // This occurs on Standard (Phong) surfaces\n\n\n  parseAttributeImageMaps(attributes, textures, maps) {\n    for (const name in attributes) {\n      const attribute = attributes[name];\n\n      if (attribute.maps) {\n        const mapData = attribute.maps[0];\n        const path = this.getTexturePathByIndex(mapData.imageIndex, textures);\n        if (!path) return;\n        const texture = this.loadTexture(path);\n        if (mapData.wrap !== undefined) texture.wrapS = this.getWrappingType(mapData.wrap.w);\n        if (mapData.wrap !== undefined) texture.wrapT = this.getWrappingType(mapData.wrap.h);\n\n        switch (name) {\n          case 'Color':\n            maps.map = texture;\n            break;\n\n          case 'Diffuse':\n            maps.aoMap = texture;\n            break;\n\n          case 'Roughness':\n            maps.roughnessMap = texture;\n            maps.roughness = 1;\n            break;\n\n          case 'Specular':\n            maps.specularMap = texture;\n            maps.specular = 0xffffff;\n            break;\n\n          case 'Luminosity':\n            maps.emissiveMap = texture;\n            maps.emissive = 0x808080;\n            break;\n\n          case 'Metallic':\n            maps.metalnessMap = texture;\n            maps.metalness = 1;\n            break;\n\n          case 'Transparency':\n          case 'Alpha':\n            maps.alphaMap = texture;\n            maps.transparent = true;\n            break;\n\n          case 'Normal':\n            maps.normalMap = texture;\n            break;\n\n          case 'Bump':\n            maps.bumpMap = texture;\n            break;\n        }\n      }\n    }\n  }\n\n  parseAttributes(attributes, maps) {\n    const params = {}; // don't use color data if color map is present\n\n    if (attributes.Color && !maps.map) {\n      params.color = new Color().fromArray(attributes.Color.value);\n    } else {\n      params.color = new Color();\n    }\n\n    if (attributes.Transparency && attributes.Transparency.value !== 0) {\n      params.opacity = 1 - attributes.Transparency.value;\n      params.transparent = true;\n    }\n\n    if (attributes['Bump Height']) params.bumpScale = attributes['Bump Height'].value * 0.1;\n    if (attributes['Refraction Index']) params.refractionRatio = 1 / attributes['Refraction Index'].value;\n    this.parsePhysicalAttributes(params, attributes, maps);\n    this.parseStandardAttributes(params, attributes, maps);\n    this.parsePhongAttributes(params, attributes, maps);\n    return params;\n  }\n\n  parsePhysicalAttributes(params, attributes\n  /*, maps*/\n  ) {\n    if (attributes.Clearcoat && attributes.Clearcoat.value > 0) {\n      params.clearcoat = attributes.Clearcoat.value;\n\n      if (attributes['Clearcoat Gloss']) {\n        params.clearcoatRoughness = 0.5 * (1 - attributes['Clearcoat Gloss'].value);\n      }\n    }\n  }\n\n  parseStandardAttributes(params, attributes, maps) {\n    if (attributes.Luminous) {\n      params.emissiveIntensity = attributes.Luminous.value;\n\n      if (attributes['Luminous Color'] && !maps.emissive) {\n        params.emissive = new Color().fromArray(attributes['Luminous Color'].value);\n      } else {\n        params.emissive = new Color(0x808080);\n      }\n    }\n\n    if (attributes.Roughness && !maps.roughnessMap) params.roughness = attributes.Roughness.value;\n    if (attributes.Metallic && !maps.metalnessMap) params.metalness = attributes.Metallic.value;\n  }\n\n  parsePhongAttributes(params, attributes, maps) {\n    if (attributes.Diffuse) params.color.multiplyScalar(attributes.Diffuse.value);\n\n    if (attributes.Reflection) {\n      params.reflectivity = attributes.Reflection.value;\n      params.combine = AddOperation;\n    }\n\n    if (attributes.Luminosity) {\n      params.emissiveIntensity = attributes.Luminosity.value;\n\n      if (!maps.emissiveMap && !maps.map) {\n        params.emissive = params.color;\n      } else {\n        params.emissive = new Color(0x808080);\n      }\n    } // parse specular if there is no roughness - we will interpret the material as 'Phong' in this case\n\n\n    if (!attributes.Roughness && attributes.Specular && !maps.specularMap) {\n      if (attributes['Color Highlight']) {\n        params.specular = new Color().setScalar(attributes.Specular.value).lerp(params.color.clone().multiplyScalar(attributes.Specular.value), attributes['Color Highlight'].value);\n      } else {\n        params.specular = new Color().setScalar(attributes.Specular.value);\n      }\n    }\n\n    if (params.specular && attributes.Glossiness) {\n      params.shininess = 7 + Math.pow(2, attributes.Glossiness.value * 12 + 2);\n    }\n  }\n\n  parseEnvMap(connections, maps, attributes) {\n    if (connections.envMap) {\n      const envMap = this.loadTexture(connections.envMap);\n\n      if (attributes.transparent && attributes.opacity < 0.999) {\n        envMap.mapping = EquirectangularRefractionMapping; // Reflectivity and refraction mapping don't work well together in Phong materials\n\n        if (attributes.reflectivity !== undefined) {\n          delete attributes.reflectivity;\n          delete attributes.combine;\n        }\n\n        if (attributes.metalness !== undefined) {\n          delete attributes.metalness;\n        }\n      } else {\n        envMap.mapping = EquirectangularReflectionMapping;\n      }\n\n      maps.envMap = envMap;\n    }\n  } // get texture defined at top level by its index\n\n\n  getTexturePathByIndex(index) {\n    let fileName = '';\n    if (!_lwoTree.textures) return fileName;\n\n    _lwoTree.textures.forEach(function (texture) {\n      if (texture.index === index) fileName = texture.fileName;\n    });\n\n    return fileName;\n  }\n\n  loadTexture(path) {\n    if (!path) return null;\n    const texture = this.textureLoader.load(path, undefined, undefined, function () {\n      console.warn('LWOLoader: non-standard resource hierarchy. Use `resourcePath` parameter to specify root content directory.');\n    });\n    return texture;\n  } // 0 = Reset, 1 = Repeat, 2 = Mirror, 3 = Edge\n\n\n  getWrappingType(num) {\n    switch (num) {\n      case 0:\n        console.warn('LWOLoader: \"Reset\" texture wrapping type is not supported in three.js');\n        return ClampToEdgeWrapping;\n\n      case 1:\n        return RepeatWrapping;\n\n      case 2:\n        return MirroredRepeatWrapping;\n\n      case 3:\n        return ClampToEdgeWrapping;\n    }\n  }\n\n  getMaterialType(nodeData) {\n    if (nodeData.Clearcoat && nodeData.Clearcoat.value > 0) return MeshPhysicalMaterial;\n    if (nodeData.Roughness) return MeshStandardMaterial;\n    return MeshPhongMaterial;\n  }\n\n}\n\nclass GeometryParser {\n  parse(geoData, layer) {\n    const geometry = new BufferGeometry();\n    geometry.setAttribute('position', new Float32BufferAttribute(geoData.points, 3));\n    const indices = this.splitIndices(geoData.vertexIndices, geoData.polygonDimensions);\n    geometry.setIndex(indices);\n    this.parseGroups(geometry, geoData);\n    geometry.computeVertexNormals();\n    this.parseUVs(geometry, layer, indices);\n    this.parseMorphTargets(geometry, layer, indices); // TODO: z may need to be reversed to account for coordinate system change\n\n    geometry.translate(-layer.pivot[0], -layer.pivot[1], -layer.pivot[2]); // let userData = geometry.userData;\n    // geometry = geometry.toNonIndexed()\n    // geometry.userData = userData;\n\n    return geometry;\n  } // split quads into tris\n\n\n  splitIndices(indices, polygonDimensions) {\n    const remappedIndices = [];\n    let i = 0;\n    polygonDimensions.forEach(function (dim) {\n      if (dim < 4) {\n        for (let k = 0; k < dim; k++) remappedIndices.push(indices[i + k]);\n      } else if (dim === 4) {\n        remappedIndices.push(indices[i], indices[i + 1], indices[i + 2], indices[i], indices[i + 2], indices[i + 3]);\n      } else if (dim > 4) {\n        for (let k = 1; k < dim - 1; k++) {\n          remappedIndices.push(indices[i], indices[i + k], indices[i + k + 1]);\n        }\n\n        console.warn('LWOLoader: polygons with greater than 4 sides are not supported');\n      }\n\n      i += dim;\n    });\n    return remappedIndices;\n  } // NOTE: currently ignoring poly indices and assuming that they are intelligently ordered\n\n\n  parseGroups(geometry, geoData) {\n    const tags = _lwoTree.tags;\n    const matNames = [];\n    let elemSize = 3;\n    if (geoData.type === 'lines') elemSize = 2;\n    if (geoData.type === 'points') elemSize = 1;\n    const remappedIndices = this.splitMaterialIndices(geoData.polygonDimensions, geoData.materialIndices);\n    let indexNum = 0; // create new indices in numerical order\n\n    const indexPairs = {}; // original indices mapped to numerical indices\n\n    let prevMaterialIndex;\n    let materialIndex;\n    let prevStart = 0;\n    let currentCount = 0;\n\n    for (let i = 0; i < remappedIndices.length; i += 2) {\n      materialIndex = remappedIndices[i + 1];\n      if (i === 0) matNames[indexNum] = tags[materialIndex];\n      if (prevMaterialIndex === undefined) prevMaterialIndex = materialIndex;\n\n      if (materialIndex !== prevMaterialIndex) {\n        let currentIndex;\n\n        if (indexPairs[tags[prevMaterialIndex]]) {\n          currentIndex = indexPairs[tags[prevMaterialIndex]];\n        } else {\n          currentIndex = indexNum;\n          indexPairs[tags[prevMaterialIndex]] = indexNum;\n          matNames[indexNum] = tags[prevMaterialIndex];\n          indexNum++;\n        }\n\n        geometry.addGroup(prevStart, currentCount, currentIndex);\n        prevStart += currentCount;\n        prevMaterialIndex = materialIndex;\n        currentCount = 0;\n      }\n\n      currentCount += elemSize;\n    } // the loop above doesn't add the last group, do that here.\n\n\n    if (geometry.groups.length > 0) {\n      let currentIndex;\n\n      if (indexPairs[tags[materialIndex]]) {\n        currentIndex = indexPairs[tags[materialIndex]];\n      } else {\n        currentIndex = indexNum;\n        indexPairs[tags[materialIndex]] = indexNum;\n        matNames[indexNum] = tags[materialIndex];\n      }\n\n      geometry.addGroup(prevStart, currentCount, currentIndex);\n    } // Mat names from TAGS chunk, used to build up an array of materials for this geometry\n\n\n    geometry.userData.matNames = matNames;\n  }\n\n  splitMaterialIndices(polygonDimensions, indices) {\n    const remappedIndices = [];\n    polygonDimensions.forEach(function (dim, i) {\n      if (dim <= 3) {\n        remappedIndices.push(indices[i * 2], indices[i * 2 + 1]);\n      } else if (dim === 4) {\n        remappedIndices.push(indices[i * 2], indices[i * 2 + 1], indices[i * 2], indices[i * 2 + 1]);\n      } else {\n        // ignore > 4 for now\n        for (let k = 0; k < dim - 2; k++) {\n          remappedIndices.push(indices[i * 2], indices[i * 2 + 1]);\n        }\n      }\n    });\n    return remappedIndices;\n  } // UV maps:\n  // 1: are defined via index into an array of points, not into a geometry\n  // - the geometry is also defined by an index into this array, but the indexes may not match\n  // 2: there can be any number of UV maps for a single geometry. Here these are combined,\n  // \twith preference given to the first map encountered\n  // 3: UV maps can be partial - that is, defined for only a part of the geometry\n  // 4: UV maps can be VMAP or VMAD (discontinuous, to allow for seams). In practice, most\n  // UV maps are defined as partially VMAP and partially VMAD\n  // VMADs are currently not supported\n\n\n  parseUVs(geometry, layer) {\n    // start by creating a UV map set to zero for the whole geometry\n    const remappedUVs = Array.from(Array(geometry.attributes.position.count * 2), function () {\n      return 0;\n    });\n\n    for (const name in layer.uvs) {\n      const uvs = layer.uvs[name].uvs;\n      const uvIndices = layer.uvs[name].uvIndices;\n      uvIndices.forEach(function (i, j) {\n        remappedUVs[i * 2] = uvs[j * 2];\n        remappedUVs[i * 2 + 1] = uvs[j * 2 + 1];\n      });\n    }\n\n    geometry.setAttribute('uv', new Float32BufferAttribute(remappedUVs, 2));\n  }\n\n  parseMorphTargets(geometry, layer) {\n    let num = 0;\n\n    for (const name in layer.morphTargets) {\n      const remappedPoints = geometry.attributes.position.array.slice();\n      if (!geometry.morphAttributes.position) geometry.morphAttributes.position = [];\n      const morphPoints = layer.morphTargets[name].points;\n      const morphIndices = layer.morphTargets[name].indices;\n      const type = layer.morphTargets[name].type;\n      morphIndices.forEach(function (i, j) {\n        if (type === 'relative') {\n          remappedPoints[i * 3] += morphPoints[j * 3];\n          remappedPoints[i * 3 + 1] += morphPoints[j * 3 + 1];\n          remappedPoints[i * 3 + 2] += morphPoints[j * 3 + 2];\n        } else {\n          remappedPoints[i * 3] = morphPoints[j * 3];\n          remappedPoints[i * 3 + 1] = morphPoints[j * 3 + 1];\n          remappedPoints[i * 3 + 2] = morphPoints[j * 3 + 2];\n        }\n      });\n      geometry.morphAttributes.position[num] = new Float32BufferAttribute(remappedPoints, 3);\n      geometry.morphAttributes.position[num].name = name;\n      num++;\n    }\n\n    geometry.morphTargetsRelative = false;\n  }\n\n} // ************** UTILITY FUNCTIONS **************\n\n\nfunction extractParentUrl(url, dir) {\n  const index = url.indexOf(dir);\n  if (index === -1) return './';\n  return url.substr(0, index);\n}\n\nexport { LWOLoader };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}