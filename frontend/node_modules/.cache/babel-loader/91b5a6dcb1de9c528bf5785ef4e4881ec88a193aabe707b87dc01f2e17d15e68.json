{"ast":null,"code":"import _classCallCheck from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { DataTextureLoader, HalfFloatType, FloatType, RGBAFormat, LinearEncoding, RedFormat, LinearFilter, DataUtils } from 'three';\nimport { unzlibSync } from 'fflate';\n\n/**\n * OpenEXR loader currently supports uncompressed, ZIP(S), RLE, PIZ and DWA/B compression.\n * Supports reading as UnsignedByte, HalfFloat and Float type data texture.\n *\n * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita\n * implementation, so I have preserved their copyright notices.\n */\n// /*\n// Copyright (c) 2014 - 2017, Syoyo Fujita\n// All rights reserved.\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//     * Redistributions of source code must retain the above copyright\n//       notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//     * Neither the name of the Syoyo Fujita nor the\n//       names of its contributors may be used to endorse or promote products\n//       derived from this software without specific prior written permission.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// */\n// // TinyEXR contains some OpenEXR code, which is licensed under ------------\n// ///////////////////////////////////////////////////////////////////////////\n// //\n// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas\n// // Digital Ltd. LLC\n// //\n// // All rights reserved.\n// //\n// // Redistribution and use in source and binary forms, with or without\n// // modification, are permitted provided that the following conditions are\n// // met:\n// // *       Redistributions of source code must retain the above copyright\n// // notice, this list of conditions and the following disclaimer.\n// // *       Redistributions in binary form must reproduce the above\n// // copyright notice, this list of conditions and the following disclaimer\n// // in the documentation and/or other materials provided with the\n// // distribution.\n// // *       Neither the name of Industrial Light & Magic nor the names of\n// // its contributors may be used to endorse or promote products derived\n// // from this software without specific prior written permission.\n// //\n// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// //\n// ///////////////////////////////////////////////////////////////////////////\n// // End of OpenEXR license -------------------------------------------------\nvar EXRLoader = /*#__PURE__*/function (_DataTextureLoader) {\n  _inherits(EXRLoader, _DataTextureLoader);\n  var _super = _createSuper(EXRLoader);\n  function EXRLoader(manager) {\n    var _this;\n    _classCallCheck(this, EXRLoader);\n    _this = _super.call(this, manager);\n    _this.type = HalfFloatType;\n    return _this;\n  }\n  _createClass(EXRLoader, [{\n    key: \"parse\",\n    value: function parse(buffer) {\n      var USHORT_RANGE = 1 << 16;\n      var BITMAP_SIZE = USHORT_RANGE >> 3;\n      var HUF_ENCBITS = 16; // literal (value) bit length\n\n      var HUF_DECBITS = 14; // decoding bit size (>= 8)\n\n      var HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1; // encoding table size\n\n      var HUF_DECSIZE = 1 << HUF_DECBITS; // decoding table size\n\n      var HUF_DECMASK = HUF_DECSIZE - 1;\n      var NBITS = 16;\n      var A_OFFSET = 1 << NBITS - 1;\n      var MOD_MASK = (1 << NBITS) - 1;\n      var SHORT_ZEROCODE_RUN = 59;\n      var LONG_ZEROCODE_RUN = 63;\n      var SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;\n      var ULONG_SIZE = 8;\n      var FLOAT32_SIZE = 4;\n      var INT32_SIZE = 4;\n      var INT16_SIZE = 2;\n      var INT8_SIZE = 1;\n      var STATIC_HUFFMAN = 0;\n      var DEFLATE = 1;\n      var UNKNOWN = 0;\n      var LOSSY_DCT = 1;\n      var RLE = 2;\n      var logBase = Math.pow(2.7182818, 2.2);\n      function reverseLutFromBitmap(bitmap, lut) {\n        var k = 0;\n        for (var i = 0; i < USHORT_RANGE; ++i) {\n          if (i == 0 || bitmap[i >> 3] & 1 << (i & 7)) {\n            lut[k++] = i;\n          }\n        }\n        var n = k - 1;\n        while (k < USHORT_RANGE) lut[k++] = 0;\n        return n;\n      }\n      function hufClearDecTable(hdec) {\n        for (var i = 0; i < HUF_DECSIZE; i++) {\n          hdec[i] = {};\n          hdec[i].len = 0;\n          hdec[i].lit = 0;\n          hdec[i].p = null;\n        }\n      }\n      var getBitsReturn = {\n        l: 0,\n        c: 0,\n        lc: 0\n      };\n      function getBits(nBits, c, lc, uInt8Array, inOffset) {\n        while (lc < nBits) {\n          c = c << 8 | parseUint8Array(uInt8Array, inOffset);\n          lc += 8;\n        }\n        lc -= nBits;\n        getBitsReturn.l = c >> lc & (1 << nBits) - 1;\n        getBitsReturn.c = c;\n        getBitsReturn.lc = lc;\n      }\n      var hufTableBuffer = new Array(59);\n      function hufCanonicalCodeTable(hcode) {\n        for (var i = 0; i <= 58; ++i) hufTableBuffer[i] = 0;\n        for (var i = 0; i < HUF_ENCSIZE; ++i) hufTableBuffer[hcode[i]] += 1;\n        var c = 0;\n        for (var i = 58; i > 0; --i) {\n          var nc = c + hufTableBuffer[i] >> 1;\n          hufTableBuffer[i] = c;\n          c = nc;\n        }\n        for (var i = 0; i < HUF_ENCSIZE; ++i) {\n          var l = hcode[i];\n          if (l > 0) hcode[i] = l | hufTableBuffer[l]++ << 6;\n        }\n      }\n      function hufUnpackEncTable(uInt8Array, inDataView, inOffset, ni, im, iM, hcode) {\n        var p = inOffset;\n        var c = 0;\n        var lc = 0;\n        for (; im <= iM; im++) {\n          if (p.value - inOffset.value > ni) return false;\n          getBits(6, c, lc, uInt8Array, p);\n          var l = getBitsReturn.l;\n          c = getBitsReturn.c;\n          lc = getBitsReturn.lc;\n          hcode[im] = l;\n          if (l == LONG_ZEROCODE_RUN) {\n            if (p.value - inOffset.value > ni) {\n              throw 'Something wrong with hufUnpackEncTable';\n            }\n            getBits(8, c, lc, uInt8Array, p);\n            var zerun = getBitsReturn.l + SHORTEST_LONG_RUN;\n            c = getBitsReturn.c;\n            lc = getBitsReturn.lc;\n            if (im + zerun > iM + 1) {\n              throw 'Something wrong with hufUnpackEncTable';\n            }\n            while (zerun--) hcode[im++] = 0;\n            im--;\n          } else if (l >= SHORT_ZEROCODE_RUN) {\n            var zerun = l - SHORT_ZEROCODE_RUN + 2;\n            if (im + zerun > iM + 1) {\n              throw 'Something wrong with hufUnpackEncTable';\n            }\n            while (zerun--) hcode[im++] = 0;\n            im--;\n          }\n        }\n        hufCanonicalCodeTable(hcode);\n      }\n      function hufLength(code) {\n        return code & 63;\n      }\n      function hufCode(code) {\n        return code >> 6;\n      }\n      function hufBuildDecTable(hcode, im, iM, hdecod) {\n        for (; im <= iM; im++) {\n          var c = hufCode(hcode[im]);\n          var l = hufLength(hcode[im]);\n          if (c >> l) {\n            throw 'Invalid table entry';\n          }\n          if (l > HUF_DECBITS) {\n            var pl = hdecod[c >> l - HUF_DECBITS];\n            if (pl.len) {\n              throw 'Invalid table entry';\n            }\n            pl.lit++;\n            if (pl.p) {\n              var p = pl.p;\n              pl.p = new Array(pl.lit);\n              for (var i = 0; i < pl.lit - 1; ++i) {\n                pl.p[i] = p[i];\n              }\n            } else {\n              pl.p = new Array(1);\n            }\n            pl.p[pl.lit - 1] = im;\n          } else if (l) {\n            var plOffset = 0;\n            for (var i = 1 << HUF_DECBITS - l; i > 0; i--) {\n              var pl = hdecod[(c << HUF_DECBITS - l) + plOffset];\n              if (pl.len || pl.p) {\n                throw 'Invalid table entry';\n              }\n              pl.len = l;\n              pl.lit = im;\n              plOffset++;\n            }\n          }\n        }\n        return true;\n      }\n      var getCharReturn = {\n        c: 0,\n        lc: 0\n      };\n      function getChar(c, lc, uInt8Array, inOffset) {\n        c = c << 8 | parseUint8Array(uInt8Array, inOffset);\n        lc += 8;\n        getCharReturn.c = c;\n        getCharReturn.lc = lc;\n      }\n      var getCodeReturn = {\n        c: 0,\n        lc: 0\n      };\n      function getCode(po, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outBufferOffset, outBufferEndOffset) {\n        if (po == rlc) {\n          if (lc < 8) {\n            getChar(c, lc, uInt8Array, inOffset);\n            c = getCharReturn.c;\n            lc = getCharReturn.lc;\n          }\n          lc -= 8;\n          var cs = c >> lc;\n          var cs = new Uint8Array([cs])[0];\n          if (outBufferOffset.value + cs > outBufferEndOffset) {\n            return false;\n          }\n          var s = outBuffer[outBufferOffset.value - 1];\n          while (cs-- > 0) {\n            outBuffer[outBufferOffset.value++] = s;\n          }\n        } else if (outBufferOffset.value < outBufferEndOffset) {\n          outBuffer[outBufferOffset.value++] = po;\n        } else {\n          return false;\n        }\n        getCodeReturn.c = c;\n        getCodeReturn.lc = lc;\n      }\n      function UInt16(value) {\n        return value & 0xffff;\n      }\n      function Int16(value) {\n        var ref = UInt16(value);\n        return ref > 0x7fff ? ref - 0x10000 : ref;\n      }\n      var wdec14Return = {\n        a: 0,\n        b: 0\n      };\n      function wdec14(l, h) {\n        var ls = Int16(l);\n        var hs = Int16(h);\n        var hi = hs;\n        var ai = ls + (hi & 1) + (hi >> 1);\n        var as = ai;\n        var bs = ai - hi;\n        wdec14Return.a = as;\n        wdec14Return.b = bs;\n      }\n      function wdec16(l, h) {\n        var m = UInt16(l);\n        var d = UInt16(h);\n        var bb = m - (d >> 1) & MOD_MASK;\n        var aa = d + bb - A_OFFSET & MOD_MASK;\n        wdec14Return.a = aa;\n        wdec14Return.b = bb;\n      }\n      function wav2Decode(buffer, j, nx, ox, ny, oy, mx) {\n        var w14 = mx < 1 << 14;\n        var n = nx > ny ? ny : nx;\n        var p = 1;\n        var p2;\n        while (p <= n) p <<= 1;\n        p >>= 1;\n        p2 = p;\n        p >>= 1;\n        while (p >= 1) {\n          var py = 0;\n          var ey = py + oy * (ny - p2);\n          var oy1 = oy * p;\n          var oy2 = oy * p2;\n          var ox1 = ox * p;\n          var ox2 = ox * p2;\n          var i00, i01, i10, i11;\n          for (; py <= ey; py += oy2) {\n            var px = py;\n            var ex = py + ox * (nx - p2);\n            for (; px <= ex; px += ox2) {\n              var p01 = px + ox1;\n              var p10 = px + oy1;\n              var p11 = p10 + ox1;\n              if (w14) {\n                wdec14(buffer[px + j], buffer[p10 + j]);\n                i00 = wdec14Return.a;\n                i10 = wdec14Return.b;\n                wdec14(buffer[p01 + j], buffer[p11 + j]);\n                i01 = wdec14Return.a;\n                i11 = wdec14Return.b;\n                wdec14(i00, i01);\n                buffer[px + j] = wdec14Return.a;\n                buffer[p01 + j] = wdec14Return.b;\n                wdec14(i10, i11);\n                buffer[p10 + j] = wdec14Return.a;\n                buffer[p11 + j] = wdec14Return.b;\n              } else {\n                wdec16(buffer[px + j], buffer[p10 + j]);\n                i00 = wdec14Return.a;\n                i10 = wdec14Return.b;\n                wdec16(buffer[p01 + j], buffer[p11 + j]);\n                i01 = wdec14Return.a;\n                i11 = wdec14Return.b;\n                wdec16(i00, i01);\n                buffer[px + j] = wdec14Return.a;\n                buffer[p01 + j] = wdec14Return.b;\n                wdec16(i10, i11);\n                buffer[p10 + j] = wdec14Return.a;\n                buffer[p11 + j] = wdec14Return.b;\n              }\n            }\n            if (nx & p) {\n              var p10 = px + oy1;\n              if (w14) wdec14(buffer[px + j], buffer[p10 + j]);else wdec16(buffer[px + j], buffer[p10 + j]);\n              i00 = wdec14Return.a;\n              buffer[p10 + j] = wdec14Return.b;\n              buffer[px + j] = i00;\n            }\n          }\n          if (ny & p) {\n            var px = py;\n            var ex = py + ox * (nx - p2);\n            for (; px <= ex; px += ox2) {\n              var p01 = px + ox1;\n              if (w14) wdec14(buffer[px + j], buffer[p01 + j]);else wdec16(buffer[px + j], buffer[p01 + j]);\n              i00 = wdec14Return.a;\n              buffer[p01 + j] = wdec14Return.b;\n              buffer[px + j] = i00;\n            }\n          }\n          p2 = p;\n          p >>= 1;\n        }\n        return py;\n      }\n      function hufDecode(encodingTable, decodingTable, uInt8Array, inDataView, inOffset, ni, rlc, no, outBuffer, outOffset) {\n        var c = 0;\n        var lc = 0;\n        var outBufferEndOffset = no;\n        var inOffsetEnd = Math.trunc(inOffset.value + (ni + 7) / 8);\n        while (inOffset.value < inOffsetEnd) {\n          getChar(c, lc, uInt8Array, inOffset);\n          c = getCharReturn.c;\n          lc = getCharReturn.lc;\n          while (lc >= HUF_DECBITS) {\n            var index = c >> lc - HUF_DECBITS & HUF_DECMASK;\n            var pl = decodingTable[index];\n            if (pl.len) {\n              lc -= pl.len;\n              getCode(pl.lit, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n              c = getCodeReturn.c;\n              lc = getCodeReturn.lc;\n            } else {\n              if (!pl.p) {\n                throw 'hufDecode issues';\n              }\n              var j;\n              for (j = 0; j < pl.lit; j++) {\n                var l = hufLength(encodingTable[pl.p[j]]);\n                while (lc < l && inOffset.value < inOffsetEnd) {\n                  getChar(c, lc, uInt8Array, inOffset);\n                  c = getCharReturn.c;\n                  lc = getCharReturn.lc;\n                }\n                if (lc >= l) {\n                  if (hufCode(encodingTable[pl.p[j]]) == (c >> lc - l & (1 << l) - 1)) {\n                    lc -= l;\n                    getCode(pl.p[j], rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n                    c = getCodeReturn.c;\n                    lc = getCodeReturn.lc;\n                    break;\n                  }\n                }\n              }\n              if (j == pl.lit) {\n                throw 'hufDecode issues';\n              }\n            }\n          }\n        }\n        var i = 8 - ni & 7;\n        c >>= i;\n        lc -= i;\n        while (lc > 0) {\n          var pl = decodingTable[c << HUF_DECBITS - lc & HUF_DECMASK];\n          if (pl.len) {\n            lc -= pl.len;\n            getCode(pl.lit, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n            c = getCodeReturn.c;\n            lc = getCodeReturn.lc;\n          } else {\n            throw 'hufDecode issues';\n          }\n        }\n        return true;\n      }\n      function hufUncompress(uInt8Array, inDataView, inOffset, nCompressed, outBuffer, nRaw) {\n        var outOffset = {\n          value: 0\n        };\n        var initialInOffset = inOffset.value;\n        var im = parseUint32(inDataView, inOffset);\n        var iM = parseUint32(inDataView, inOffset);\n        inOffset.value += 4;\n        var nBits = parseUint32(inDataView, inOffset);\n        inOffset.value += 4;\n        if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE) {\n          throw 'Something wrong with HUF_ENCSIZE';\n        }\n        var freq = new Array(HUF_ENCSIZE);\n        var hdec = new Array(HUF_DECSIZE);\n        hufClearDecTable(hdec);\n        var ni = nCompressed - (inOffset.value - initialInOffset);\n        hufUnpackEncTable(uInt8Array, inDataView, inOffset, ni, im, iM, freq);\n        if (nBits > 8 * (nCompressed - (inOffset.value - initialInOffset))) {\n          throw 'Something wrong with hufUncompress';\n        }\n        hufBuildDecTable(freq, im, iM, hdec);\n        hufDecode(freq, hdec, uInt8Array, inDataView, inOffset, nBits, iM, nRaw, outBuffer, outOffset);\n      }\n      function applyLut(lut, data, nData) {\n        for (var i = 0; i < nData; ++i) {\n          data[i] = lut[data[i]];\n        }\n      }\n      function predictor(source) {\n        for (var t = 1; t < source.length; t++) {\n          var d = source[t - 1] + source[t] - 128;\n          source[t] = d;\n        }\n      }\n      function interleaveScalar(source, out) {\n        var t1 = 0;\n        var t2 = Math.floor((source.length + 1) / 2);\n        var s = 0;\n        var stop = source.length - 1;\n        while (true) {\n          if (s > stop) break;\n          out[s++] = source[t1++];\n          if (s > stop) break;\n          out[s++] = source[t2++];\n        }\n      }\n      function decodeRunLength(source) {\n        var size = source.byteLength;\n        var out = new Array();\n        var p = 0;\n        var reader = new DataView(source);\n        while (size > 0) {\n          var l = reader.getInt8(p++);\n          if (l < 0) {\n            var count = -l;\n            size -= count + 1;\n            for (var i = 0; i < count; i++) {\n              out.push(reader.getUint8(p++));\n            }\n          } else {\n            var count = l;\n            size -= 2;\n            var value = reader.getUint8(p++);\n            for (var i = 0; i < count + 1; i++) {\n              out.push(value);\n            }\n          }\n        }\n        return out;\n      }\n      function lossyDctDecode(cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer) {\n        var dataView = new DataView(outBuffer.buffer);\n        var width = channelData[cscSet.idx[0]].width;\n        var height = channelData[cscSet.idx[0]].height;\n        var numComp = 3;\n        var numFullBlocksX = Math.floor(width / 8.0);\n        var numBlocksX = Math.ceil(width / 8.0);\n        var numBlocksY = Math.ceil(height / 8.0);\n        var leftoverX = width - (numBlocksX - 1) * 8;\n        var leftoverY = height - (numBlocksY - 1) * 8;\n        var currAcComp = {\n          value: 0\n        };\n        var currDcComp = new Array(numComp);\n        var dctData = new Array(numComp);\n        var halfZigBlock = new Array(numComp);\n        var rowBlock = new Array(numComp);\n        var rowOffsets = new Array(numComp);\n        for (var _comp = 0; _comp < numComp; ++_comp) {\n          rowOffsets[_comp] = rowPtrs[cscSet.idx[_comp]];\n          currDcComp[_comp] = _comp < 1 ? 0 : currDcComp[_comp - 1] + numBlocksX * numBlocksY;\n          dctData[_comp] = new Float32Array(64);\n          halfZigBlock[_comp] = new Uint16Array(64);\n          rowBlock[_comp] = new Uint16Array(numBlocksX * 64);\n        }\n        for (var blocky = 0; blocky < numBlocksY; ++blocky) {\n          var maxY = 8;\n          if (blocky == numBlocksY - 1) maxY = leftoverY;\n          var maxX = 8;\n          for (var blockx = 0; blockx < numBlocksX; ++blockx) {\n            if (blockx == numBlocksX - 1) maxX = leftoverX;\n            for (var _comp2 = 0; _comp2 < numComp; ++_comp2) {\n              halfZigBlock[_comp2].fill(0); // set block DC component\n\n              halfZigBlock[_comp2][0] = dcBuffer[currDcComp[_comp2]++]; // set block AC components\n\n              unRleAC(currAcComp, acBuffer, halfZigBlock[_comp2]); // UnZigZag block to float\n\n              unZigZag(halfZigBlock[_comp2], dctData[_comp2]); // decode float dct\n\n              dctInverse(dctData[_comp2]);\n            }\n            {\n              csc709Inverse(dctData);\n            }\n            for (var _comp3 = 0; _comp3 < numComp; ++_comp3) {\n              convertToHalf(dctData[_comp3], rowBlock[_comp3], blockx * 64);\n            }\n          } // blockx\n\n          var _offset = 0;\n          for (var _comp4 = 0; _comp4 < numComp; ++_comp4) {\n            var _type = channelData[cscSet.idx[_comp4]].type;\n            for (var _y = 8 * blocky; _y < 8 * blocky + maxY; ++_y) {\n              _offset = rowOffsets[_comp4][_y];\n              for (var _blockx = 0; _blockx < numFullBlocksX; ++_blockx) {\n                var src = _blockx * 64 + (_y & 0x7) * 8;\n                dataView.setUint16(_offset + 0 * INT16_SIZE * _type, rowBlock[_comp4][src + 0], true);\n                dataView.setUint16(_offset + 1 * INT16_SIZE * _type, rowBlock[_comp4][src + 1], true);\n                dataView.setUint16(_offset + 2 * INT16_SIZE * _type, rowBlock[_comp4][src + 2], true);\n                dataView.setUint16(_offset + 3 * INT16_SIZE * _type, rowBlock[_comp4][src + 3], true);\n                dataView.setUint16(_offset + 4 * INT16_SIZE * _type, rowBlock[_comp4][src + 4], true);\n                dataView.setUint16(_offset + 5 * INT16_SIZE * _type, rowBlock[_comp4][src + 5], true);\n                dataView.setUint16(_offset + 6 * INT16_SIZE * _type, rowBlock[_comp4][src + 6], true);\n                dataView.setUint16(_offset + 7 * INT16_SIZE * _type, rowBlock[_comp4][src + 7], true);\n                _offset += 8 * INT16_SIZE * _type;\n              }\n            } // handle partial X blocks\n\n            if (numFullBlocksX != numBlocksX) {\n              for (var _y2 = 8 * blocky; _y2 < 8 * blocky + maxY; ++_y2) {\n                var _offset2 = rowOffsets[_comp4][_y2] + 8 * numFullBlocksX * INT16_SIZE * _type;\n                var _src = numFullBlocksX * 64 + (_y2 & 0x7) * 8;\n                for (var _x = 0; _x < maxX; ++_x) {\n                  dataView.setUint16(_offset2 + _x * INT16_SIZE * _type, rowBlock[_comp4][_src + _x], true);\n                }\n              }\n            }\n          } // comp\n        } // blocky\n\n        var halfRow = new Uint16Array(width);\n        var dataView = new DataView(outBuffer.buffer); // convert channels back to float, if needed\n\n        for (var comp = 0; comp < numComp; ++comp) {\n          channelData[cscSet.idx[comp]].decoded = true;\n          var type = channelData[cscSet.idx[comp]].type;\n          if (channelData[comp].type != 2) continue;\n          for (var y = 0; y < height; ++y) {\n            var _offset3 = rowOffsets[comp][y];\n            for (var x = 0; x < width; ++x) {\n              halfRow[x] = dataView.getUint16(_offset3 + x * INT16_SIZE * type, true);\n            }\n            for (var x = 0; x < width; ++x) {\n              dataView.setFloat32(_offset3 + x * INT16_SIZE * type, decodeFloat16(halfRow[x]), true);\n            }\n          }\n        }\n      }\n      function unRleAC(currAcComp, acBuffer, halfZigBlock) {\n        var acValue;\n        var dctComp = 1;\n        while (dctComp < 64) {\n          acValue = acBuffer[currAcComp.value];\n          if (acValue == 0xff00) {\n            dctComp = 64;\n          } else if (acValue >> 8 == 0xff) {\n            dctComp += acValue & 0xff;\n          } else {\n            halfZigBlock[dctComp] = acValue;\n            dctComp++;\n          }\n          currAcComp.value++;\n        }\n      }\n      function unZigZag(src, dst) {\n        dst[0] = decodeFloat16(src[0]);\n        dst[1] = decodeFloat16(src[1]);\n        dst[2] = decodeFloat16(src[5]);\n        dst[3] = decodeFloat16(src[6]);\n        dst[4] = decodeFloat16(src[14]);\n        dst[5] = decodeFloat16(src[15]);\n        dst[6] = decodeFloat16(src[27]);\n        dst[7] = decodeFloat16(src[28]);\n        dst[8] = decodeFloat16(src[2]);\n        dst[9] = decodeFloat16(src[4]);\n        dst[10] = decodeFloat16(src[7]);\n        dst[11] = decodeFloat16(src[13]);\n        dst[12] = decodeFloat16(src[16]);\n        dst[13] = decodeFloat16(src[26]);\n        dst[14] = decodeFloat16(src[29]);\n        dst[15] = decodeFloat16(src[42]);\n        dst[16] = decodeFloat16(src[3]);\n        dst[17] = decodeFloat16(src[8]);\n        dst[18] = decodeFloat16(src[12]);\n        dst[19] = decodeFloat16(src[17]);\n        dst[20] = decodeFloat16(src[25]);\n        dst[21] = decodeFloat16(src[30]);\n        dst[22] = decodeFloat16(src[41]);\n        dst[23] = decodeFloat16(src[43]);\n        dst[24] = decodeFloat16(src[9]);\n        dst[25] = decodeFloat16(src[11]);\n        dst[26] = decodeFloat16(src[18]);\n        dst[27] = decodeFloat16(src[24]);\n        dst[28] = decodeFloat16(src[31]);\n        dst[29] = decodeFloat16(src[40]);\n        dst[30] = decodeFloat16(src[44]);\n        dst[31] = decodeFloat16(src[53]);\n        dst[32] = decodeFloat16(src[10]);\n        dst[33] = decodeFloat16(src[19]);\n        dst[34] = decodeFloat16(src[23]);\n        dst[35] = decodeFloat16(src[32]);\n        dst[36] = decodeFloat16(src[39]);\n        dst[37] = decodeFloat16(src[45]);\n        dst[38] = decodeFloat16(src[52]);\n        dst[39] = decodeFloat16(src[54]);\n        dst[40] = decodeFloat16(src[20]);\n        dst[41] = decodeFloat16(src[22]);\n        dst[42] = decodeFloat16(src[33]);\n        dst[43] = decodeFloat16(src[38]);\n        dst[44] = decodeFloat16(src[46]);\n        dst[45] = decodeFloat16(src[51]);\n        dst[46] = decodeFloat16(src[55]);\n        dst[47] = decodeFloat16(src[60]);\n        dst[48] = decodeFloat16(src[21]);\n        dst[49] = decodeFloat16(src[34]);\n        dst[50] = decodeFloat16(src[37]);\n        dst[51] = decodeFloat16(src[47]);\n        dst[52] = decodeFloat16(src[50]);\n        dst[53] = decodeFloat16(src[56]);\n        dst[54] = decodeFloat16(src[59]);\n        dst[55] = decodeFloat16(src[61]);\n        dst[56] = decodeFloat16(src[35]);\n        dst[57] = decodeFloat16(src[36]);\n        dst[58] = decodeFloat16(src[48]);\n        dst[59] = decodeFloat16(src[49]);\n        dst[60] = decodeFloat16(src[57]);\n        dst[61] = decodeFloat16(src[58]);\n        dst[62] = decodeFloat16(src[62]);\n        dst[63] = decodeFloat16(src[63]);\n      }\n      function dctInverse(data) {\n        var a = 0.5 * Math.cos(3.14159 / 4.0);\n        var b = 0.5 * Math.cos(3.14159 / 16.0);\n        var c = 0.5 * Math.cos(3.14159 / 8.0);\n        var d = 0.5 * Math.cos(3.0 * 3.14159 / 16.0);\n        var e = 0.5 * Math.cos(5.0 * 3.14159 / 16.0);\n        var f = 0.5 * Math.cos(3.0 * 3.14159 / 8.0);\n        var g = 0.5 * Math.cos(7.0 * 3.14159 / 16.0);\n        var alpha = new Array(4);\n        var beta = new Array(4);\n        var theta = new Array(4);\n        var gamma = new Array(4);\n        for (var row = 0; row < 8; ++row) {\n          var rowPtr = row * 8;\n          alpha[0] = c * data[rowPtr + 2];\n          alpha[1] = f * data[rowPtr + 2];\n          alpha[2] = c * data[rowPtr + 6];\n          alpha[3] = f * data[rowPtr + 6];\n          beta[0] = b * data[rowPtr + 1] + d * data[rowPtr + 3] + e * data[rowPtr + 5] + g * data[rowPtr + 7];\n          beta[1] = d * data[rowPtr + 1] - g * data[rowPtr + 3] - b * data[rowPtr + 5] - e * data[rowPtr + 7];\n          beta[2] = e * data[rowPtr + 1] - b * data[rowPtr + 3] + g * data[rowPtr + 5] + d * data[rowPtr + 7];\n          beta[3] = g * data[rowPtr + 1] - e * data[rowPtr + 3] + d * data[rowPtr + 5] - b * data[rowPtr + 7];\n          theta[0] = a * (data[rowPtr + 0] + data[rowPtr + 4]);\n          theta[3] = a * (data[rowPtr + 0] - data[rowPtr + 4]);\n          theta[1] = alpha[0] + alpha[3];\n          theta[2] = alpha[1] - alpha[2];\n          gamma[0] = theta[0] + theta[1];\n          gamma[1] = theta[3] + theta[2];\n          gamma[2] = theta[3] - theta[2];\n          gamma[3] = theta[0] - theta[1];\n          data[rowPtr + 0] = gamma[0] + beta[0];\n          data[rowPtr + 1] = gamma[1] + beta[1];\n          data[rowPtr + 2] = gamma[2] + beta[2];\n          data[rowPtr + 3] = gamma[3] + beta[3];\n          data[rowPtr + 4] = gamma[3] - beta[3];\n          data[rowPtr + 5] = gamma[2] - beta[2];\n          data[rowPtr + 6] = gamma[1] - beta[1];\n          data[rowPtr + 7] = gamma[0] - beta[0];\n        }\n        for (var column = 0; column < 8; ++column) {\n          alpha[0] = c * data[16 + column];\n          alpha[1] = f * data[16 + column];\n          alpha[2] = c * data[48 + column];\n          alpha[3] = f * data[48 + column];\n          beta[0] = b * data[8 + column] + d * data[24 + column] + e * data[40 + column] + g * data[56 + column];\n          beta[1] = d * data[8 + column] - g * data[24 + column] - b * data[40 + column] - e * data[56 + column];\n          beta[2] = e * data[8 + column] - b * data[24 + column] + g * data[40 + column] + d * data[56 + column];\n          beta[3] = g * data[8 + column] - e * data[24 + column] + d * data[40 + column] - b * data[56 + column];\n          theta[0] = a * (data[column] + data[32 + column]);\n          theta[3] = a * (data[column] - data[32 + column]);\n          theta[1] = alpha[0] + alpha[3];\n          theta[2] = alpha[1] - alpha[2];\n          gamma[0] = theta[0] + theta[1];\n          gamma[1] = theta[3] + theta[2];\n          gamma[2] = theta[3] - theta[2];\n          gamma[3] = theta[0] - theta[1];\n          data[0 + column] = gamma[0] + beta[0];\n          data[8 + column] = gamma[1] + beta[1];\n          data[16 + column] = gamma[2] + beta[2];\n          data[24 + column] = gamma[3] + beta[3];\n          data[32 + column] = gamma[3] - beta[3];\n          data[40 + column] = gamma[2] - beta[2];\n          data[48 + column] = gamma[1] - beta[1];\n          data[56 + column] = gamma[0] - beta[0];\n        }\n      }\n      function csc709Inverse(data) {\n        for (var i = 0; i < 64; ++i) {\n          var y = data[0][i];\n          var cb = data[1][i];\n          var cr = data[2][i];\n          data[0][i] = y + 1.5747 * cr;\n          data[1][i] = y - 0.1873 * cb - 0.4682 * cr;\n          data[2][i] = y + 1.8556 * cb;\n        }\n      }\n      function convertToHalf(src, dst, idx) {\n        for (var i = 0; i < 64; ++i) {\n          dst[idx + i] = DataUtils.toHalfFloat(toLinear(src[i]));\n        }\n      }\n      function toLinear(float) {\n        if (float <= 1) {\n          return Math.sign(float) * Math.pow(Math.abs(float), 2.2);\n        } else {\n          return Math.sign(float) * Math.pow(logBase, Math.abs(float) - 1.0);\n        }\n      }\n      function uncompressRAW(info) {\n        return new DataView(info.array.buffer, info.offset.value, info.size);\n      }\n      function uncompressRLE(info) {\n        var compressed = info.viewer.buffer.slice(info.offset.value, info.offset.value + info.size);\n        var rawBuffer = new Uint8Array(decodeRunLength(compressed));\n        var tmpBuffer = new Uint8Array(rawBuffer.length);\n        predictor(rawBuffer); // revert predictor\n\n        interleaveScalar(rawBuffer, tmpBuffer); // interleave pixels\n\n        return new DataView(tmpBuffer.buffer);\n      }\n      function uncompressZIP(info) {\n        var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n        var rawBuffer = unzlibSync(compressed); // eslint-disable-line no-undef\n\n        var tmpBuffer = new Uint8Array(rawBuffer.length);\n        predictor(rawBuffer); // revert predictor\n\n        interleaveScalar(rawBuffer, tmpBuffer); // interleave pixels\n\n        return new DataView(tmpBuffer.buffer);\n      }\n      function uncompressPIZ(info) {\n        var inDataView = info.viewer;\n        var inOffset = {\n          value: info.offset.value\n        };\n        var outBuffer = new Uint16Array(info.width * info.scanlineBlockSize * (info.channels * info.type));\n        var bitmap = new Uint8Array(BITMAP_SIZE); // Setup channel info\n\n        var outBufferEnd = 0;\n        var pizChannelData = new Array(info.channels);\n        for (var i = 0; i < info.channels; i++) {\n          pizChannelData[i] = {};\n          pizChannelData[i]['start'] = outBufferEnd;\n          pizChannelData[i]['end'] = pizChannelData[i]['start'];\n          pizChannelData[i]['nx'] = info.width;\n          pizChannelData[i]['ny'] = info.lines;\n          pizChannelData[i]['size'] = info.type;\n          outBufferEnd += pizChannelData[i].nx * pizChannelData[i].ny * pizChannelData[i].size;\n        } // Read range compression data\n\n        var minNonZero = parseUint16(inDataView, inOffset);\n        var maxNonZero = parseUint16(inDataView, inOffset);\n        if (maxNonZero >= BITMAP_SIZE) {\n          throw 'Something is wrong with PIZ_COMPRESSION BITMAP_SIZE';\n        }\n        if (minNonZero <= maxNonZero) {\n          for (var i = 0; i < maxNonZero - minNonZero + 1; i++) {\n            bitmap[i + minNonZero] = parseUint8(inDataView, inOffset);\n          }\n        } // Reverse LUT\n\n        var lut = new Uint16Array(USHORT_RANGE);\n        var maxValue = reverseLutFromBitmap(bitmap, lut);\n        var length = parseUint32(inDataView, inOffset); // Huffman decoding\n\n        hufUncompress(info.array, inDataView, inOffset, length, outBuffer, outBufferEnd); // Wavelet decoding\n\n        for (var i = 0; i < info.channels; ++i) {\n          var cd = pizChannelData[i];\n          for (var j = 0; j < pizChannelData[i].size; ++j) {\n            wav2Decode(outBuffer, cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size, maxValue);\n          }\n        } // Expand the pixel data to their original range\n\n        applyLut(lut, outBuffer, outBufferEnd); // Rearrange the pixel data into the format expected by the caller.\n\n        var tmpOffset = 0;\n        var tmpBuffer = new Uint8Array(outBuffer.buffer.byteLength);\n        for (var y = 0; y < info.lines; y++) {\n          for (var c = 0; c < info.channels; c++) {\n            var cd = pizChannelData[c];\n            var n = cd.nx * cd.size;\n            var cp = new Uint8Array(outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE);\n            tmpBuffer.set(cp, tmpOffset);\n            tmpOffset += n * INT16_SIZE;\n            cd.end += n;\n          }\n        }\n        return new DataView(tmpBuffer.buffer);\n      }\n      function uncompressPXR(info) {\n        var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n        var rawBuffer = unzlibSync(compressed); // eslint-disable-line no-undef\n\n        var sz = info.lines * info.channels * info.width;\n        var tmpBuffer = info.type == 1 ? new Uint16Array(sz) : new Uint32Array(sz);\n        var tmpBufferEnd = 0;\n        var writePtr = 0;\n        var ptr = new Array(4);\n        for (var y = 0; y < info.lines; y++) {\n          for (var c = 0; c < info.channels; c++) {\n            var pixel = 0;\n            switch (info.type) {\n              case 1:\n                ptr[0] = tmpBufferEnd;\n                ptr[1] = ptr[0] + info.width;\n                tmpBufferEnd = ptr[1] + info.width;\n                for (var j = 0; j < info.width; ++j) {\n                  var diff = rawBuffer[ptr[0]++] << 8 | rawBuffer[ptr[1]++];\n                  pixel += diff;\n                  tmpBuffer[writePtr] = pixel;\n                  writePtr++;\n                }\n                break;\n              case 2:\n                ptr[0] = tmpBufferEnd;\n                ptr[1] = ptr[0] + info.width;\n                ptr[2] = ptr[1] + info.width;\n                tmpBufferEnd = ptr[2] + info.width;\n                for (var _j = 0; _j < info.width; ++_j) {\n                  var _diff = rawBuffer[ptr[0]++] << 24 | rawBuffer[ptr[1]++] << 16 | rawBuffer[ptr[2]++] << 8;\n                  pixel += _diff;\n                  tmpBuffer[writePtr] = pixel;\n                  writePtr++;\n                }\n                break;\n            }\n          }\n        }\n        return new DataView(tmpBuffer.buffer);\n      }\n      function uncompressDWA(info) {\n        var inDataView = info.viewer;\n        var inOffset = {\n          value: info.offset.value\n        };\n        var outBuffer = new Uint8Array(info.width * info.lines * (info.channels * info.type * INT16_SIZE)); // Read compression header information\n\n        var dwaHeader = {\n          version: parseInt64(inDataView, inOffset),\n          unknownUncompressedSize: parseInt64(inDataView, inOffset),\n          unknownCompressedSize: parseInt64(inDataView, inOffset),\n          acCompressedSize: parseInt64(inDataView, inOffset),\n          dcCompressedSize: parseInt64(inDataView, inOffset),\n          rleCompressedSize: parseInt64(inDataView, inOffset),\n          rleUncompressedSize: parseInt64(inDataView, inOffset),\n          rleRawSize: parseInt64(inDataView, inOffset),\n          totalAcUncompressedCount: parseInt64(inDataView, inOffset),\n          totalDcUncompressedCount: parseInt64(inDataView, inOffset),\n          acCompression: parseInt64(inDataView, inOffset)\n        };\n        if (dwaHeader.version < 2) {\n          throw 'EXRLoader.parse: ' + EXRHeader.compression + ' version ' + dwaHeader.version + ' is unsupported';\n        } // Read channel ruleset information\n\n        var channelRules = new Array();\n        var ruleSize = parseUint16(inDataView, inOffset) - INT16_SIZE;\n        while (ruleSize > 0) {\n          var name = parseNullTerminatedString(inDataView.buffer, inOffset);\n          var value = parseUint8(inDataView, inOffset);\n          var compression = value >> 2 & 3;\n          var csc = (value >> 4) - 1;\n          var index = new Int8Array([csc])[0];\n          var type = parseUint8(inDataView, inOffset);\n          channelRules.push({\n            name: name,\n            index: index,\n            type: type,\n            compression: compression\n          });\n          ruleSize -= name.length + 3;\n        } // Classify channels\n\n        var channels = EXRHeader.channels;\n        var channelData = new Array(info.channels);\n        for (var i = 0; i < info.channels; ++i) {\n          var cd = channelData[i] = {};\n          var channel = channels[i];\n          cd.name = channel.name;\n          cd.compression = UNKNOWN;\n          cd.decoded = false;\n          cd.type = channel.pixelType;\n          cd.pLinear = channel.pLinear;\n          cd.width = info.width;\n          cd.height = info.lines;\n        }\n        var cscSet = {\n          idx: new Array(3)\n        };\n        for (var offset = 0; offset < info.channels; ++offset) {\n          var cd = channelData[offset];\n          for (var i = 0; i < channelRules.length; ++i) {\n            var rule = channelRules[i];\n            if (cd.name == rule.name) {\n              cd.compression = rule.compression;\n              if (rule.index >= 0) {\n                cscSet.idx[rule.index] = offset;\n              }\n              cd.offset = offset;\n            }\n          }\n        } // Read DCT - AC component data\n\n        if (dwaHeader.acCompressedSize > 0) {\n          switch (dwaHeader.acCompression) {\n            case STATIC_HUFFMAN:\n              var acBuffer = new Uint16Array(dwaHeader.totalAcUncompressedCount);\n              hufUncompress(info.array, inDataView, inOffset, dwaHeader.acCompressedSize, acBuffer, dwaHeader.totalAcUncompressedCount);\n              break;\n            case DEFLATE:\n              var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount);\n              var data = unzlibSync(compressed); // eslint-disable-line no-undef\n\n              var acBuffer = new Uint16Array(data.buffer);\n              inOffset.value += dwaHeader.totalAcUncompressedCount;\n              break;\n          }\n        } // Read DCT - DC component data\n\n        if (dwaHeader.dcCompressedSize > 0) {\n          var zlibInfo = {\n            array: info.array,\n            offset: inOffset,\n            size: dwaHeader.dcCompressedSize\n          };\n          var dcBuffer = new Uint16Array(uncompressZIP(zlibInfo).buffer);\n          inOffset.value += dwaHeader.dcCompressedSize;\n        } // Read RLE compressed data\n\n        if (dwaHeader.rleRawSize > 0) {\n          var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.rleCompressedSize);\n          var data = unzlibSync(compressed); // eslint-disable-line no-undef\n\n          var rleBuffer = decodeRunLength(data.buffer);\n          inOffset.value += dwaHeader.rleCompressedSize;\n        } // Prepare outbuffer data offset\n\n        var outBufferEnd = 0;\n        var rowOffsets = new Array(channelData.length);\n        for (var i = 0; i < rowOffsets.length; ++i) {\n          rowOffsets[i] = new Array();\n        }\n        for (var y = 0; y < info.lines; ++y) {\n          for (var chan = 0; chan < channelData.length; ++chan) {\n            rowOffsets[chan].push(outBufferEnd);\n            outBufferEnd += channelData[chan].width * info.type * INT16_SIZE;\n          }\n        } // Lossy DCT decode RGB channels\n\n        lossyDctDecode(cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer); // Decode other channels\n\n        for (var i = 0; i < channelData.length; ++i) {\n          var cd = channelData[i];\n          if (cd.decoded) continue;\n          switch (cd.compression) {\n            case RLE:\n              var row = 0;\n              var rleOffset = 0;\n              for (var y = 0; y < info.lines; ++y) {\n                var rowOffsetBytes = rowOffsets[i][row];\n                for (var x = 0; x < cd.width; ++x) {\n                  for (var byte = 0; byte < INT16_SIZE * cd.type; ++byte) {\n                    outBuffer[rowOffsetBytes++] = rleBuffer[rleOffset + byte * cd.width * cd.height];\n                  }\n                  rleOffset++;\n                }\n                row++;\n              }\n              break;\n            case LOSSY_DCT: // skip\n\n            default:\n              throw 'EXRLoader.parse: unsupported channel compression';\n          }\n        }\n        return new DataView(outBuffer.buffer);\n      }\n      function parseNullTerminatedString(buffer, offset) {\n        var uintBuffer = new Uint8Array(buffer);\n        var endOffset = 0;\n        while (uintBuffer[offset.value + endOffset] != 0) {\n          endOffset += 1;\n        }\n        var stringValue = new TextDecoder().decode(uintBuffer.slice(offset.value, offset.value + endOffset));\n        offset.value = offset.value + endOffset + 1;\n        return stringValue;\n      }\n      function parseFixedLengthString(buffer, offset, size) {\n        var stringValue = new TextDecoder().decode(new Uint8Array(buffer).slice(offset.value, offset.value + size));\n        offset.value = offset.value + size;\n        return stringValue;\n      }\n      function parseRational(dataView, offset) {\n        var x = parseInt32(dataView, offset);\n        var y = parseUint32(dataView, offset);\n        return [x, y];\n      }\n      function parseTimecode(dataView, offset) {\n        var x = parseUint32(dataView, offset);\n        var y = parseUint32(dataView, offset);\n        return [x, y];\n      }\n      function parseInt32(dataView, offset) {\n        var Int32 = dataView.getInt32(offset.value, true);\n        offset.value = offset.value + INT32_SIZE;\n        return Int32;\n      }\n      function parseUint32(dataView, offset) {\n        var Uint32 = dataView.getUint32(offset.value, true);\n        offset.value = offset.value + INT32_SIZE;\n        return Uint32;\n      }\n      function parseUint8Array(uInt8Array, offset) {\n        var Uint8 = uInt8Array[offset.value];\n        offset.value = offset.value + INT8_SIZE;\n        return Uint8;\n      }\n      function parseUint8(dataView, offset) {\n        var Uint8 = dataView.getUint8(offset.value);\n        offset.value = offset.value + INT8_SIZE;\n        return Uint8;\n      }\n      var parseInt64 = function parseInt64(dataView, offset) {\n        var int;\n        if ('getBigInt64' in DataView.prototype) {\n          int = Number(dataView.getBigInt64(offset.value, true));\n        } else {\n          int = dataView.getUint32(offset.value + 4, true) + Number(dataView.getUint32(offset.value, true) << 32);\n        }\n        offset.value += ULONG_SIZE;\n        return int;\n      };\n      function parseFloat32(dataView, offset) {\n        var float = dataView.getFloat32(offset.value, true);\n        offset.value += FLOAT32_SIZE;\n        return float;\n      }\n      function decodeFloat32(dataView, offset) {\n        return DataUtils.toHalfFloat(parseFloat32(dataView, offset));\n      } // https://stackoverflow.com/questions/5678432/decompressing-half-precision-floats-in-javascript\n\n      function decodeFloat16(binary) {\n        var exponent = (binary & 0x7c00) >> 10,\n          fraction = binary & 0x03ff;\n        return (binary >> 15 ? -1 : 1) * (exponent ? exponent === 0x1f ? fraction ? NaN : Infinity : Math.pow(2, exponent - 15) * (1 + fraction / 0x400) : 6.103515625e-5 * (fraction / 0x400));\n      }\n      function parseUint16(dataView, offset) {\n        var Uint16 = dataView.getUint16(offset.value, true);\n        offset.value += INT16_SIZE;\n        return Uint16;\n      }\n      function parseFloat16(buffer, offset) {\n        return decodeFloat16(parseUint16(buffer, offset));\n      }\n      function parseChlist(dataView, buffer, offset, size) {\n        var startOffset = offset.value;\n        var channels = [];\n        while (offset.value < startOffset + size - 1) {\n          var name = parseNullTerminatedString(buffer, offset);\n          var pixelType = parseInt32(dataView, offset);\n          var pLinear = parseUint8(dataView, offset);\n          offset.value += 3; // reserved, three chars\n\n          var xSampling = parseInt32(dataView, offset);\n          var ySampling = parseInt32(dataView, offset);\n          channels.push({\n            name: name,\n            pixelType: pixelType,\n            pLinear: pLinear,\n            xSampling: xSampling,\n            ySampling: ySampling\n          });\n        }\n        offset.value += 1;\n        return channels;\n      }\n      function parseChromaticities(dataView, offset) {\n        var redX = parseFloat32(dataView, offset);\n        var redY = parseFloat32(dataView, offset);\n        var greenX = parseFloat32(dataView, offset);\n        var greenY = parseFloat32(dataView, offset);\n        var blueX = parseFloat32(dataView, offset);\n        var blueY = parseFloat32(dataView, offset);\n        var whiteX = parseFloat32(dataView, offset);\n        var whiteY = parseFloat32(dataView, offset);\n        return {\n          redX: redX,\n          redY: redY,\n          greenX: greenX,\n          greenY: greenY,\n          blueX: blueX,\n          blueY: blueY,\n          whiteX: whiteX,\n          whiteY: whiteY\n        };\n      }\n      function parseCompression(dataView, offset) {\n        var compressionCodes = ['NO_COMPRESSION', 'RLE_COMPRESSION', 'ZIPS_COMPRESSION', 'ZIP_COMPRESSION', 'PIZ_COMPRESSION', 'PXR24_COMPRESSION', 'B44_COMPRESSION', 'B44A_COMPRESSION', 'DWAA_COMPRESSION', 'DWAB_COMPRESSION'];\n        var compression = parseUint8(dataView, offset);\n        return compressionCodes[compression];\n      }\n      function parseBox2i(dataView, offset) {\n        var xMin = parseUint32(dataView, offset);\n        var yMin = parseUint32(dataView, offset);\n        var xMax = parseUint32(dataView, offset);\n        var yMax = parseUint32(dataView, offset);\n        return {\n          xMin: xMin,\n          yMin: yMin,\n          xMax: xMax,\n          yMax: yMax\n        };\n      }\n      function parseLineOrder(dataView, offset) {\n        var lineOrders = ['INCREASING_Y'];\n        var lineOrder = parseUint8(dataView, offset);\n        return lineOrders[lineOrder];\n      }\n      function parseV2f(dataView, offset) {\n        var x = parseFloat32(dataView, offset);\n        var y = parseFloat32(dataView, offset);\n        return [x, y];\n      }\n      function parseV3f(dataView, offset) {\n        var x = parseFloat32(dataView, offset);\n        var y = parseFloat32(dataView, offset);\n        var z = parseFloat32(dataView, offset);\n        return [x, y, z];\n      }\n      function parseValue(dataView, buffer, offset, type, size) {\n        if (type === 'string' || type === 'stringvector' || type === 'iccProfile') {\n          return parseFixedLengthString(buffer, offset, size);\n        } else if (type === 'chlist') {\n          return parseChlist(dataView, buffer, offset, size);\n        } else if (type === 'chromaticities') {\n          return parseChromaticities(dataView, offset);\n        } else if (type === 'compression') {\n          return parseCompression(dataView, offset);\n        } else if (type === 'box2i') {\n          return parseBox2i(dataView, offset);\n        } else if (type === 'lineOrder') {\n          return parseLineOrder(dataView, offset);\n        } else if (type === 'float') {\n          return parseFloat32(dataView, offset);\n        } else if (type === 'v2f') {\n          return parseV2f(dataView, offset);\n        } else if (type === 'v3f') {\n          return parseV3f(dataView, offset);\n        } else if (type === 'int') {\n          return parseInt32(dataView, offset);\n        } else if (type === 'rational') {\n          return parseRational(dataView, offset);\n        } else if (type === 'timecode') {\n          return parseTimecode(dataView, offset);\n        } else if (type === 'preview') {\n          offset.value += size;\n          return 'skipped';\n        } else {\n          offset.value += size;\n          return undefined;\n        }\n      }\n      function parseHeader(dataView, buffer, offset) {\n        var EXRHeader = {};\n        if (dataView.getUint32(0, true) != 20000630) {\n          // magic\n          throw \"THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.\";\n        }\n        EXRHeader.version = dataView.getUint8(4);\n        var spec = dataView.getUint8(5); // fullMask\n\n        EXRHeader.spec = {\n          singleTile: !!(spec & 2),\n          longName: !!(spec & 4),\n          deepFormat: !!(spec & 8),\n          multiPart: !!(spec & 16)\n        }; // start of header\n\n        offset.value = 8; // start at 8 - after pre-amble\n\n        var keepReading = true;\n        while (keepReading) {\n          var attributeName = parseNullTerminatedString(buffer, offset);\n          if (attributeName == 0) {\n            keepReading = false;\n          } else {\n            var attributeType = parseNullTerminatedString(buffer, offset);\n            var attributeSize = parseUint32(dataView, offset);\n            var attributeValue = parseValue(dataView, buffer, offset, attributeType, attributeSize);\n            if (attributeValue === undefined) {\n              console.warn(\"EXRLoader.parse: skipped unknown header attribute type '\".concat(attributeType, \"'.\"));\n            } else {\n              EXRHeader[attributeName] = attributeValue;\n            }\n          }\n        }\n        if (spec != 0) {\n          console.error('EXRHeader:', EXRHeader);\n          throw 'THREE.EXRLoader: provided file is currently unsupported.';\n        }\n        return EXRHeader;\n      }\n      function setupDecoder(EXRHeader, dataView, uInt8Array, offset, outputType) {\n        var EXRDecoder = {\n          size: 0,\n          viewer: dataView,\n          array: uInt8Array,\n          offset: offset,\n          width: EXRHeader.dataWindow.xMax - EXRHeader.dataWindow.xMin + 1,\n          height: EXRHeader.dataWindow.yMax - EXRHeader.dataWindow.yMin + 1,\n          channels: EXRHeader.channels.length,\n          bytesPerLine: null,\n          lines: null,\n          inputSize: null,\n          type: EXRHeader.channels[0].pixelType,\n          uncompress: null,\n          getter: null,\n          format: null,\n          encoding: null\n        };\n        switch (EXRHeader.compression) {\n          case 'NO_COMPRESSION':\n            EXRDecoder.lines = 1;\n            EXRDecoder.uncompress = uncompressRAW;\n            break;\n          case 'RLE_COMPRESSION':\n            EXRDecoder.lines = 1;\n            EXRDecoder.uncompress = uncompressRLE;\n            break;\n          case 'ZIPS_COMPRESSION':\n            EXRDecoder.lines = 1;\n            EXRDecoder.uncompress = uncompressZIP;\n            break;\n          case 'ZIP_COMPRESSION':\n            EXRDecoder.lines = 16;\n            EXRDecoder.uncompress = uncompressZIP;\n            break;\n          case 'PIZ_COMPRESSION':\n            EXRDecoder.lines = 32;\n            EXRDecoder.uncompress = uncompressPIZ;\n            break;\n          case 'PXR24_COMPRESSION':\n            EXRDecoder.lines = 16;\n            EXRDecoder.uncompress = uncompressPXR;\n            break;\n          case 'DWAA_COMPRESSION':\n            EXRDecoder.lines = 32;\n            EXRDecoder.uncompress = uncompressDWA;\n            break;\n          case 'DWAB_COMPRESSION':\n            EXRDecoder.lines = 256;\n            EXRDecoder.uncompress = uncompressDWA;\n            break;\n          default:\n            throw 'EXRLoader.parse: ' + EXRHeader.compression + ' is unsupported';\n        }\n        EXRDecoder.scanlineBlockSize = EXRDecoder.lines;\n        if (EXRDecoder.type == 1) {\n          // half\n          switch (outputType) {\n            case FloatType:\n              EXRDecoder.getter = parseFloat16;\n              EXRDecoder.inputSize = INT16_SIZE;\n              break;\n            case HalfFloatType:\n              EXRDecoder.getter = parseUint16;\n              EXRDecoder.inputSize = INT16_SIZE;\n              break;\n          }\n        } else if (EXRDecoder.type == 2) {\n          // float\n          switch (outputType) {\n            case FloatType:\n              EXRDecoder.getter = parseFloat32;\n              EXRDecoder.inputSize = FLOAT32_SIZE;\n              break;\n            case HalfFloatType:\n              EXRDecoder.getter = decodeFloat32;\n              EXRDecoder.inputSize = FLOAT32_SIZE;\n          }\n        } else {\n          throw 'EXRLoader.parse: unsupported pixelType ' + EXRDecoder.type + ' for ' + EXRHeader.compression + '.';\n        }\n        EXRDecoder.blockCount = (EXRHeader.dataWindow.yMax + 1) / EXRDecoder.scanlineBlockSize;\n        for (var i = 0; i < EXRDecoder.blockCount; i++) parseInt64(dataView, offset); // scanlineOffset\n        // we should be passed the scanline offset table, ready to start reading pixel data.\n        // RGB images will be converted to RGBA format, preventing software emulation in select devices.\n\n        EXRDecoder.outputChannels = EXRDecoder.channels == 3 ? 4 : EXRDecoder.channels;\n        var size = EXRDecoder.width * EXRDecoder.height * EXRDecoder.outputChannels;\n        switch (outputType) {\n          case FloatType:\n            EXRDecoder.byteArray = new Float32Array(size); // Fill initially with 1s for the alpha value if the texture is not RGBA, RGB values will be overwritten\n\n            if (EXRDecoder.channels < EXRDecoder.outputChannels) EXRDecoder.byteArray.fill(1, 0, size);\n            break;\n          case HalfFloatType:\n            EXRDecoder.byteArray = new Uint16Array(size);\n            if (EXRDecoder.channels < EXRDecoder.outputChannels) EXRDecoder.byteArray.fill(0x3c00, 0, size); // Uint16Array holds half float data, 0x3C00 is 1\n\n            break;\n          default:\n            console.error('THREE.EXRLoader: unsupported type: ', outputType);\n            break;\n        }\n        EXRDecoder.bytesPerLine = EXRDecoder.width * EXRDecoder.inputSize * EXRDecoder.channels;\n        if (EXRDecoder.outputChannels == 4) {\n          EXRDecoder.format = RGBAFormat;\n          EXRDecoder.encoding = LinearEncoding;\n        } else {\n          EXRDecoder.format = RedFormat;\n          EXRDecoder.encoding = LinearEncoding;\n        }\n        return EXRDecoder;\n      } // start parsing file [START]\n\n      var bufferDataView = new DataView(buffer);\n      var uInt8Array = new Uint8Array(buffer);\n      var offset = {\n        value: 0\n      }; // get header information and validate format.\n\n      var EXRHeader = parseHeader(bufferDataView, buffer, offset); // get input compression information and prepare decoding.\n\n      var EXRDecoder = setupDecoder(EXRHeader, bufferDataView, uInt8Array, offset, this.type);\n      var tmpOffset = {\n        value: 0\n      };\n      var channelOffsets = {\n        R: 0,\n        G: 1,\n        B: 2,\n        A: 3,\n        Y: 0\n      };\n      for (var scanlineBlockIdx = 0; scanlineBlockIdx < EXRDecoder.height / EXRDecoder.scanlineBlockSize; scanlineBlockIdx++) {\n        var line = parseUint32(bufferDataView, offset); // line_no\n\n        EXRDecoder.size = parseUint32(bufferDataView, offset); // data_len\n\n        EXRDecoder.lines = line + EXRDecoder.scanlineBlockSize > EXRDecoder.height ? EXRDecoder.height - line : EXRDecoder.scanlineBlockSize;\n        var isCompressed = EXRDecoder.size < EXRDecoder.lines * EXRDecoder.bytesPerLine;\n        var viewer = isCompressed ? EXRDecoder.uncompress(EXRDecoder) : uncompressRAW(EXRDecoder);\n        offset.value += EXRDecoder.size;\n        for (var line_y = 0; line_y < EXRDecoder.scanlineBlockSize; line_y++) {\n          var true_y = line_y + scanlineBlockIdx * EXRDecoder.scanlineBlockSize;\n          if (true_y >= EXRDecoder.height) break;\n          for (var channelID = 0; channelID < EXRDecoder.channels; channelID++) {\n            var cOff = channelOffsets[EXRHeader.channels[channelID].name];\n            for (var x = 0; x < EXRDecoder.width; x++) {\n              tmpOffset.value = (line_y * (EXRDecoder.channels * EXRDecoder.width) + channelID * EXRDecoder.width + x) * EXRDecoder.inputSize;\n              var outIndex = (EXRDecoder.height - 1 - true_y) * (EXRDecoder.width * EXRDecoder.outputChannels) + x * EXRDecoder.outputChannels + cOff;\n              EXRDecoder.byteArray[outIndex] = EXRDecoder.getter(viewer, tmpOffset);\n            }\n          }\n        }\n      }\n      return {\n        header: EXRHeader,\n        width: EXRDecoder.width,\n        height: EXRDecoder.height,\n        data: EXRDecoder.byteArray,\n        format: EXRDecoder.format,\n        encoding: EXRDecoder.encoding,\n        type: this.type\n      };\n    }\n  }, {\n    key: \"setDataType\",\n    value: function setDataType(value) {\n      this.type = value;\n      return this;\n    }\n  }, {\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      function onLoadCallback(texture, texData) {\n        texture.encoding = texData.encoding;\n        texture.minFilter = LinearFilter;\n        texture.magFilter = LinearFilter;\n        texture.generateMipmaps = false;\n        texture.flipY = false;\n        if (onLoad) onLoad(texture, texData);\n      }\n      return _get(_getPrototypeOf(EXRLoader.prototype), \"load\", this).call(this, url, onLoadCallback, onProgress, onError);\n    }\n  }]);\n  return EXRLoader;\n}(DataTextureLoader);\nexport { EXRLoader };","map":{"version":3,"names":["DataTextureLoader","HalfFloatType","FloatType","RGBAFormat","LinearEncoding","RedFormat","LinearFilter","DataUtils","unzlibSync","EXRLoader","_DataTextureLoader","_inherits","_super","_createSuper","manager","_this","_classCallCheck","call","type","_createClass","key","value","parse","buffer","USHORT_RANGE","BITMAP_SIZE","HUF_ENCBITS","HUF_DECBITS","HUF_ENCSIZE","HUF_DECSIZE","HUF_DECMASK","NBITS","A_OFFSET","MOD_MASK","SHORT_ZEROCODE_RUN","LONG_ZEROCODE_RUN","SHORTEST_LONG_RUN","ULONG_SIZE","FLOAT32_SIZE","INT32_SIZE","INT16_SIZE","INT8_SIZE","STATIC_HUFFMAN","DEFLATE","UNKNOWN","LOSSY_DCT","RLE","logBase","Math","pow","reverseLutFromBitmap","bitmap","lut","k","i","n","hufClearDecTable","hdec","len","lit","p","getBitsReturn","l","c","lc","getBits","nBits","uInt8Array","inOffset","parseUint8Array","hufTableBuffer","Array","hufCanonicalCodeTable","hcode","nc","hufUnpackEncTable","inDataView","ni","im","iM","zerun","hufLength","code","hufCode","hufBuildDecTable","hdecod","pl","plOffset","getCharReturn","getChar","getCodeReturn","getCode","po","rlc","outBuffer","outBufferOffset","outBufferEndOffset","cs","Uint8Array","s","UInt16","Int16","ref","wdec14Return","a","b","wdec14","h","ls","hs","hi","ai","as","bs","wdec16","m","d","bb","aa","wav2Decode","j","nx","ox","ny","oy","mx","w14","p2","py","ey","oy1","oy2","ox1","ox2","i00","i01","i10","i11","px","ex","p01","p10","p11","hufDecode","encodingTable","decodingTable","no","outOffset","inOffsetEnd","trunc","index","hufUncompress","nCompressed","nRaw","initialInOffset","parseUint32","freq","applyLut","data","nData","predictor","source","t","length","interleaveScalar","out","t1","t2","floor","stop","decodeRunLength","size","byteLength","reader","DataView","getInt8","count","push","getUint8","lossyDctDecode","cscSet","rowPtrs","channelData","acBuffer","dcBuffer","dataView","width","idx","height","numComp","numFullBlocksX","numBlocksX","ceil","numBlocksY","leftoverX","leftoverY","currAcComp","currDcComp","dctData","halfZigBlock","rowBlock","rowOffsets","comp","Float32Array","Uint16Array","blocky","maxY","maxX","blockx","fill","unRleAC","unZigZag","dctInverse","csc709Inverse","convertToHalf","offset","y","src","setUint16","x","halfRow","decoded","getUint16","setFloat32","decodeFloat16","acValue","dctComp","dst","cos","e","f","g","alpha","beta","theta","gamma","row","rowPtr","column","cb","cr","toHalfFloat","toLinear","float","sign","abs","uncompressRAW","info","array","uncompressRLE","compressed","viewer","slice","rawBuffer","tmpBuffer","uncompressZIP","uncompressPIZ","scanlineBlockSize","channels","outBufferEnd","pizChannelData","lines","minNonZero","parseUint16","maxNonZero","parseUint8","maxValue","cd","start","tmpOffset","cp","end","set","uncompressPXR","sz","Uint32Array","tmpBufferEnd","writePtr","ptr","pixel","diff","uncompressDWA","dwaHeader","version","parseInt64","unknownUncompressedSize","unknownCompressedSize","acCompressedSize","dcCompressedSize","rleCompressedSize","rleUncompressedSize","rleRawSize","totalAcUncompressedCount","totalDcUncompressedCount","acCompression","EXRHeader","compression","channelRules","ruleSize","name","parseNullTerminatedString","csc","Int8Array","channel","pixelType","pLinear","rule","zlibInfo","rleBuffer","chan","rleOffset","rowOffsetBytes","byte","uintBuffer","endOffset","stringValue","TextDecoder","decode","parseFixedLengthString","parseRational","parseInt32","parseTimecode","Int32","getInt32","Uint32","getUint32","Uint8","int","prototype","Number","getBigInt64","parseFloat32","getFloat32","decodeFloat32","binary","exponent","fraction","NaN","Infinity","Uint16","parseFloat16","parseChlist","startOffset","xSampling","ySampling","parseChromaticities","redX","redY","greenX","greenY","blueX","blueY","whiteX","whiteY","parseCompression","compressionCodes","parseBox2i","xMin","yMin","xMax","yMax","parseLineOrder","lineOrders","lineOrder","parseV2f","parseV3f","z","parseValue","undefined","parseHeader","spec","singleTile","longName","deepFormat","multiPart","keepReading","attributeName","attributeType","attributeSize","attributeValue","console","warn","concat","error","setupDecoder","outputType","EXRDecoder","dataWindow","bytesPerLine","inputSize","uncompress","getter","format","encoding","blockCount","outputChannels","byteArray","bufferDataView","channelOffsets","R","G","B","A","Y","scanlineBlockIdx","line","isCompressed","line_y","true_y","channelID","cOff","outIndex","header","setDataType","load","url","onLoad","onProgress","onError","onLoadCallback","texture","texData","minFilter","magFilter","generateMipmaps","flipY","_get","_getPrototypeOf"],"sources":["/home/samuel/experiment/3d/farm/frontend/node_modules/three-stdlib/loaders/EXRLoader.js"],"sourcesContent":["import { DataTextureLoader, HalfFloatType, FloatType, RGBAFormat, LinearEncoding, RedFormat, LinearFilter, DataUtils } from 'three';\nimport { unzlibSync } from 'fflate';\n\n/**\n * OpenEXR loader currently supports uncompressed, ZIP(S), RLE, PIZ and DWA/B compression.\n * Supports reading as UnsignedByte, HalfFloat and Float type data texture.\n *\n * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita\n * implementation, so I have preserved their copyright notices.\n */\n// /*\n// Copyright (c) 2014 - 2017, Syoyo Fujita\n// All rights reserved.\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//     * Redistributions of source code must retain the above copyright\n//       notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//     * Neither the name of the Syoyo Fujita nor the\n//       names of its contributors may be used to endorse or promote products\n//       derived from this software without specific prior written permission.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// */\n// // TinyEXR contains some OpenEXR code, which is licensed under ------------\n// ///////////////////////////////////////////////////////////////////////////\n// //\n// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas\n// // Digital Ltd. LLC\n// //\n// // All rights reserved.\n// //\n// // Redistribution and use in source and binary forms, with or without\n// // modification, are permitted provided that the following conditions are\n// // met:\n// // *       Redistributions of source code must retain the above copyright\n// // notice, this list of conditions and the following disclaimer.\n// // *       Redistributions in binary form must reproduce the above\n// // copyright notice, this list of conditions and the following disclaimer\n// // in the documentation and/or other materials provided with the\n// // distribution.\n// // *       Neither the name of Industrial Light & Magic nor the names of\n// // its contributors may be used to endorse or promote products derived\n// // from this software without specific prior written permission.\n// //\n// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// //\n// ///////////////////////////////////////////////////////////////////////////\n// // End of OpenEXR license -------------------------------------------------\n\nclass EXRLoader extends DataTextureLoader {\n  constructor(manager) {\n    super(manager);\n    this.type = HalfFloatType;\n  }\n\n  parse(buffer) {\n    const USHORT_RANGE = 1 << 16;\n    const BITMAP_SIZE = USHORT_RANGE >> 3;\n    const HUF_ENCBITS = 16; // literal (value) bit length\n\n    const HUF_DECBITS = 14; // decoding bit size (>= 8)\n\n    const HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1; // encoding table size\n\n    const HUF_DECSIZE = 1 << HUF_DECBITS; // decoding table size\n\n    const HUF_DECMASK = HUF_DECSIZE - 1;\n    const NBITS = 16;\n    const A_OFFSET = 1 << NBITS - 1;\n    const MOD_MASK = (1 << NBITS) - 1;\n    const SHORT_ZEROCODE_RUN = 59;\n    const LONG_ZEROCODE_RUN = 63;\n    const SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;\n    const ULONG_SIZE = 8;\n    const FLOAT32_SIZE = 4;\n    const INT32_SIZE = 4;\n    const INT16_SIZE = 2;\n    const INT8_SIZE = 1;\n    const STATIC_HUFFMAN = 0;\n    const DEFLATE = 1;\n    const UNKNOWN = 0;\n    const LOSSY_DCT = 1;\n    const RLE = 2;\n    const logBase = Math.pow(2.7182818, 2.2);\n\n    function reverseLutFromBitmap(bitmap, lut) {\n      var k = 0;\n\n      for (var i = 0; i < USHORT_RANGE; ++i) {\n        if (i == 0 || bitmap[i >> 3] & 1 << (i & 7)) {\n          lut[k++] = i;\n        }\n      }\n\n      var n = k - 1;\n\n      while (k < USHORT_RANGE) lut[k++] = 0;\n\n      return n;\n    }\n\n    function hufClearDecTable(hdec) {\n      for (var i = 0; i < HUF_DECSIZE; i++) {\n        hdec[i] = {};\n        hdec[i].len = 0;\n        hdec[i].lit = 0;\n        hdec[i].p = null;\n      }\n    }\n\n    const getBitsReturn = {\n      l: 0,\n      c: 0,\n      lc: 0\n    };\n\n    function getBits(nBits, c, lc, uInt8Array, inOffset) {\n      while (lc < nBits) {\n        c = c << 8 | parseUint8Array(uInt8Array, inOffset);\n        lc += 8;\n      }\n\n      lc -= nBits;\n      getBitsReturn.l = c >> lc & (1 << nBits) - 1;\n      getBitsReturn.c = c;\n      getBitsReturn.lc = lc;\n    }\n\n    const hufTableBuffer = new Array(59);\n\n    function hufCanonicalCodeTable(hcode) {\n      for (var i = 0; i <= 58; ++i) hufTableBuffer[i] = 0;\n\n      for (var i = 0; i < HUF_ENCSIZE; ++i) hufTableBuffer[hcode[i]] += 1;\n\n      var c = 0;\n\n      for (var i = 58; i > 0; --i) {\n        var nc = c + hufTableBuffer[i] >> 1;\n        hufTableBuffer[i] = c;\n        c = nc;\n      }\n\n      for (var i = 0; i < HUF_ENCSIZE; ++i) {\n        var l = hcode[i];\n        if (l > 0) hcode[i] = l | hufTableBuffer[l]++ << 6;\n      }\n    }\n\n    function hufUnpackEncTable(uInt8Array, inDataView, inOffset, ni, im, iM, hcode) {\n      var p = inOffset;\n      var c = 0;\n      var lc = 0;\n\n      for (; im <= iM; im++) {\n        if (p.value - inOffset.value > ni) return false;\n        getBits(6, c, lc, uInt8Array, p);\n        var l = getBitsReturn.l;\n        c = getBitsReturn.c;\n        lc = getBitsReturn.lc;\n        hcode[im] = l;\n\n        if (l == LONG_ZEROCODE_RUN) {\n          if (p.value - inOffset.value > ni) {\n            throw 'Something wrong with hufUnpackEncTable';\n          }\n\n          getBits(8, c, lc, uInt8Array, p);\n          var zerun = getBitsReturn.l + SHORTEST_LONG_RUN;\n          c = getBitsReturn.c;\n          lc = getBitsReturn.lc;\n\n          if (im + zerun > iM + 1) {\n            throw 'Something wrong with hufUnpackEncTable';\n          }\n\n          while (zerun--) hcode[im++] = 0;\n\n          im--;\n        } else if (l >= SHORT_ZEROCODE_RUN) {\n          var zerun = l - SHORT_ZEROCODE_RUN + 2;\n\n          if (im + zerun > iM + 1) {\n            throw 'Something wrong with hufUnpackEncTable';\n          }\n\n          while (zerun--) hcode[im++] = 0;\n\n          im--;\n        }\n      }\n\n      hufCanonicalCodeTable(hcode);\n    }\n\n    function hufLength(code) {\n      return code & 63;\n    }\n\n    function hufCode(code) {\n      return code >> 6;\n    }\n\n    function hufBuildDecTable(hcode, im, iM, hdecod) {\n      for (; im <= iM; im++) {\n        var c = hufCode(hcode[im]);\n        var l = hufLength(hcode[im]);\n\n        if (c >> l) {\n          throw 'Invalid table entry';\n        }\n\n        if (l > HUF_DECBITS) {\n          var pl = hdecod[c >> l - HUF_DECBITS];\n\n          if (pl.len) {\n            throw 'Invalid table entry';\n          }\n\n          pl.lit++;\n\n          if (pl.p) {\n            var p = pl.p;\n            pl.p = new Array(pl.lit);\n\n            for (var i = 0; i < pl.lit - 1; ++i) {\n              pl.p[i] = p[i];\n            }\n          } else {\n            pl.p = new Array(1);\n          }\n\n          pl.p[pl.lit - 1] = im;\n        } else if (l) {\n          var plOffset = 0;\n\n          for (var i = 1 << HUF_DECBITS - l; i > 0; i--) {\n            var pl = hdecod[(c << HUF_DECBITS - l) + plOffset];\n\n            if (pl.len || pl.p) {\n              throw 'Invalid table entry';\n            }\n\n            pl.len = l;\n            pl.lit = im;\n            plOffset++;\n          }\n        }\n      }\n\n      return true;\n    }\n\n    const getCharReturn = {\n      c: 0,\n      lc: 0\n    };\n\n    function getChar(c, lc, uInt8Array, inOffset) {\n      c = c << 8 | parseUint8Array(uInt8Array, inOffset);\n      lc += 8;\n      getCharReturn.c = c;\n      getCharReturn.lc = lc;\n    }\n\n    const getCodeReturn = {\n      c: 0,\n      lc: 0\n    };\n\n    function getCode(po, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outBufferOffset, outBufferEndOffset) {\n      if (po == rlc) {\n        if (lc < 8) {\n          getChar(c, lc, uInt8Array, inOffset);\n          c = getCharReturn.c;\n          lc = getCharReturn.lc;\n        }\n\n        lc -= 8;\n        var cs = c >> lc;\n        var cs = new Uint8Array([cs])[0];\n\n        if (outBufferOffset.value + cs > outBufferEndOffset) {\n          return false;\n        }\n\n        var s = outBuffer[outBufferOffset.value - 1];\n\n        while (cs-- > 0) {\n          outBuffer[outBufferOffset.value++] = s;\n        }\n      } else if (outBufferOffset.value < outBufferEndOffset) {\n        outBuffer[outBufferOffset.value++] = po;\n      } else {\n        return false;\n      }\n\n      getCodeReturn.c = c;\n      getCodeReturn.lc = lc;\n    }\n\n    function UInt16(value) {\n      return value & 0xffff;\n    }\n\n    function Int16(value) {\n      var ref = UInt16(value);\n      return ref > 0x7fff ? ref - 0x10000 : ref;\n    }\n\n    const wdec14Return = {\n      a: 0,\n      b: 0\n    };\n\n    function wdec14(l, h) {\n      var ls = Int16(l);\n      var hs = Int16(h);\n      var hi = hs;\n      var ai = ls + (hi & 1) + (hi >> 1);\n      var as = ai;\n      var bs = ai - hi;\n      wdec14Return.a = as;\n      wdec14Return.b = bs;\n    }\n\n    function wdec16(l, h) {\n      var m = UInt16(l);\n      var d = UInt16(h);\n      var bb = m - (d >> 1) & MOD_MASK;\n      var aa = d + bb - A_OFFSET & MOD_MASK;\n      wdec14Return.a = aa;\n      wdec14Return.b = bb;\n    }\n\n    function wav2Decode(buffer, j, nx, ox, ny, oy, mx) {\n      var w14 = mx < 1 << 14;\n      var n = nx > ny ? ny : nx;\n      var p = 1;\n      var p2;\n\n      while (p <= n) p <<= 1;\n\n      p >>= 1;\n      p2 = p;\n      p >>= 1;\n\n      while (p >= 1) {\n        var py = 0;\n        var ey = py + oy * (ny - p2);\n        var oy1 = oy * p;\n        var oy2 = oy * p2;\n        var ox1 = ox * p;\n        var ox2 = ox * p2;\n        var i00, i01, i10, i11;\n\n        for (; py <= ey; py += oy2) {\n          var px = py;\n          var ex = py + ox * (nx - p2);\n\n          for (; px <= ex; px += ox2) {\n            var p01 = px + ox1;\n            var p10 = px + oy1;\n            var p11 = p10 + ox1;\n\n            if (w14) {\n              wdec14(buffer[px + j], buffer[p10 + j]);\n              i00 = wdec14Return.a;\n              i10 = wdec14Return.b;\n              wdec14(buffer[p01 + j], buffer[p11 + j]);\n              i01 = wdec14Return.a;\n              i11 = wdec14Return.b;\n              wdec14(i00, i01);\n              buffer[px + j] = wdec14Return.a;\n              buffer[p01 + j] = wdec14Return.b;\n              wdec14(i10, i11);\n              buffer[p10 + j] = wdec14Return.a;\n              buffer[p11 + j] = wdec14Return.b;\n            } else {\n              wdec16(buffer[px + j], buffer[p10 + j]);\n              i00 = wdec14Return.a;\n              i10 = wdec14Return.b;\n              wdec16(buffer[p01 + j], buffer[p11 + j]);\n              i01 = wdec14Return.a;\n              i11 = wdec14Return.b;\n              wdec16(i00, i01);\n              buffer[px + j] = wdec14Return.a;\n              buffer[p01 + j] = wdec14Return.b;\n              wdec16(i10, i11);\n              buffer[p10 + j] = wdec14Return.a;\n              buffer[p11 + j] = wdec14Return.b;\n            }\n          }\n\n          if (nx & p) {\n            var p10 = px + oy1;\n            if (w14) wdec14(buffer[px + j], buffer[p10 + j]);else wdec16(buffer[px + j], buffer[p10 + j]);\n            i00 = wdec14Return.a;\n            buffer[p10 + j] = wdec14Return.b;\n            buffer[px + j] = i00;\n          }\n        }\n\n        if (ny & p) {\n          var px = py;\n          var ex = py + ox * (nx - p2);\n\n          for (; px <= ex; px += ox2) {\n            var p01 = px + ox1;\n            if (w14) wdec14(buffer[px + j], buffer[p01 + j]);else wdec16(buffer[px + j], buffer[p01 + j]);\n            i00 = wdec14Return.a;\n            buffer[p01 + j] = wdec14Return.b;\n            buffer[px + j] = i00;\n          }\n        }\n\n        p2 = p;\n        p >>= 1;\n      }\n\n      return py;\n    }\n\n    function hufDecode(encodingTable, decodingTable, uInt8Array, inDataView, inOffset, ni, rlc, no, outBuffer, outOffset) {\n      var c = 0;\n      var lc = 0;\n      var outBufferEndOffset = no;\n      var inOffsetEnd = Math.trunc(inOffset.value + (ni + 7) / 8);\n\n      while (inOffset.value < inOffsetEnd) {\n        getChar(c, lc, uInt8Array, inOffset);\n        c = getCharReturn.c;\n        lc = getCharReturn.lc;\n\n        while (lc >= HUF_DECBITS) {\n          var index = c >> lc - HUF_DECBITS & HUF_DECMASK;\n          var pl = decodingTable[index];\n\n          if (pl.len) {\n            lc -= pl.len;\n            getCode(pl.lit, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n            c = getCodeReturn.c;\n            lc = getCodeReturn.lc;\n          } else {\n            if (!pl.p) {\n              throw 'hufDecode issues';\n            }\n\n            var j;\n\n            for (j = 0; j < pl.lit; j++) {\n              var l = hufLength(encodingTable[pl.p[j]]);\n\n              while (lc < l && inOffset.value < inOffsetEnd) {\n                getChar(c, lc, uInt8Array, inOffset);\n                c = getCharReturn.c;\n                lc = getCharReturn.lc;\n              }\n\n              if (lc >= l) {\n                if (hufCode(encodingTable[pl.p[j]]) == (c >> lc - l & (1 << l) - 1)) {\n                  lc -= l;\n                  getCode(pl.p[j], rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n                  c = getCodeReturn.c;\n                  lc = getCodeReturn.lc;\n                  break;\n                }\n              }\n            }\n\n            if (j == pl.lit) {\n              throw 'hufDecode issues';\n            }\n          }\n        }\n      }\n\n      var i = 8 - ni & 7;\n      c >>= i;\n      lc -= i;\n\n      while (lc > 0) {\n        var pl = decodingTable[c << HUF_DECBITS - lc & HUF_DECMASK];\n\n        if (pl.len) {\n          lc -= pl.len;\n          getCode(pl.lit, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n          c = getCodeReturn.c;\n          lc = getCodeReturn.lc;\n        } else {\n          throw 'hufDecode issues';\n        }\n      }\n\n      return true;\n    }\n\n    function hufUncompress(uInt8Array, inDataView, inOffset, nCompressed, outBuffer, nRaw) {\n      var outOffset = {\n        value: 0\n      };\n      var initialInOffset = inOffset.value;\n      var im = parseUint32(inDataView, inOffset);\n      var iM = parseUint32(inDataView, inOffset);\n      inOffset.value += 4;\n      var nBits = parseUint32(inDataView, inOffset);\n      inOffset.value += 4;\n\n      if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE) {\n        throw 'Something wrong with HUF_ENCSIZE';\n      }\n\n      var freq = new Array(HUF_ENCSIZE);\n      var hdec = new Array(HUF_DECSIZE);\n      hufClearDecTable(hdec);\n      var ni = nCompressed - (inOffset.value - initialInOffset);\n      hufUnpackEncTable(uInt8Array, inDataView, inOffset, ni, im, iM, freq);\n\n      if (nBits > 8 * (nCompressed - (inOffset.value - initialInOffset))) {\n        throw 'Something wrong with hufUncompress';\n      }\n\n      hufBuildDecTable(freq, im, iM, hdec);\n      hufDecode(freq, hdec, uInt8Array, inDataView, inOffset, nBits, iM, nRaw, outBuffer, outOffset);\n    }\n\n    function applyLut(lut, data, nData) {\n      for (var i = 0; i < nData; ++i) {\n        data[i] = lut[data[i]];\n      }\n    }\n\n    function predictor(source) {\n      for (var t = 1; t < source.length; t++) {\n        var d = source[t - 1] + source[t] - 128;\n        source[t] = d;\n      }\n    }\n\n    function interleaveScalar(source, out) {\n      var t1 = 0;\n      var t2 = Math.floor((source.length + 1) / 2);\n      var s = 0;\n      var stop = source.length - 1;\n\n      while (true) {\n        if (s > stop) break;\n        out[s++] = source[t1++];\n        if (s > stop) break;\n        out[s++] = source[t2++];\n      }\n    }\n\n    function decodeRunLength(source) {\n      var size = source.byteLength;\n      var out = new Array();\n      var p = 0;\n      var reader = new DataView(source);\n\n      while (size > 0) {\n        var l = reader.getInt8(p++);\n\n        if (l < 0) {\n          var count = -l;\n          size -= count + 1;\n\n          for (var i = 0; i < count; i++) {\n            out.push(reader.getUint8(p++));\n          }\n        } else {\n          var count = l;\n          size -= 2;\n          var value = reader.getUint8(p++);\n\n          for (var i = 0; i < count + 1; i++) {\n            out.push(value);\n          }\n        }\n      }\n\n      return out;\n    }\n\n    function lossyDctDecode(cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer) {\n      var dataView = new DataView(outBuffer.buffer);\n      var width = channelData[cscSet.idx[0]].width;\n      var height = channelData[cscSet.idx[0]].height;\n      var numComp = 3;\n      var numFullBlocksX = Math.floor(width / 8.0);\n      var numBlocksX = Math.ceil(width / 8.0);\n      var numBlocksY = Math.ceil(height / 8.0);\n      var leftoverX = width - (numBlocksX - 1) * 8;\n      var leftoverY = height - (numBlocksY - 1) * 8;\n      var currAcComp = {\n        value: 0\n      };\n      var currDcComp = new Array(numComp);\n      var dctData = new Array(numComp);\n      var halfZigBlock = new Array(numComp);\n      var rowBlock = new Array(numComp);\n      var rowOffsets = new Array(numComp);\n\n      for (let comp = 0; comp < numComp; ++comp) {\n        rowOffsets[comp] = rowPtrs[cscSet.idx[comp]];\n        currDcComp[comp] = comp < 1 ? 0 : currDcComp[comp - 1] + numBlocksX * numBlocksY;\n        dctData[comp] = new Float32Array(64);\n        halfZigBlock[comp] = new Uint16Array(64);\n        rowBlock[comp] = new Uint16Array(numBlocksX * 64);\n      }\n\n      for (let blocky = 0; blocky < numBlocksY; ++blocky) {\n        var maxY = 8;\n        if (blocky == numBlocksY - 1) maxY = leftoverY;\n        var maxX = 8;\n\n        for (let blockx = 0; blockx < numBlocksX; ++blockx) {\n          if (blockx == numBlocksX - 1) maxX = leftoverX;\n\n          for (let comp = 0; comp < numComp; ++comp) {\n            halfZigBlock[comp].fill(0); // set block DC component\n\n            halfZigBlock[comp][0] = dcBuffer[currDcComp[comp]++]; // set block AC components\n\n            unRleAC(currAcComp, acBuffer, halfZigBlock[comp]); // UnZigZag block to float\n\n            unZigZag(halfZigBlock[comp], dctData[comp]); // decode float dct\n\n            dctInverse(dctData[comp]);\n          }\n\n          {\n            csc709Inverse(dctData);\n          }\n\n          for (let comp = 0; comp < numComp; ++comp) {\n            convertToHalf(dctData[comp], rowBlock[comp], blockx * 64);\n          }\n        } // blockx\n\n\n        let offset = 0;\n\n        for (let comp = 0; comp < numComp; ++comp) {\n          const type = channelData[cscSet.idx[comp]].type;\n\n          for (let y = 8 * blocky; y < 8 * blocky + maxY; ++y) {\n            offset = rowOffsets[comp][y];\n\n            for (let blockx = 0; blockx < numFullBlocksX; ++blockx) {\n              const src = blockx * 64 + (y & 0x7) * 8;\n              dataView.setUint16(offset + 0 * INT16_SIZE * type, rowBlock[comp][src + 0], true);\n              dataView.setUint16(offset + 1 * INT16_SIZE * type, rowBlock[comp][src + 1], true);\n              dataView.setUint16(offset + 2 * INT16_SIZE * type, rowBlock[comp][src + 2], true);\n              dataView.setUint16(offset + 3 * INT16_SIZE * type, rowBlock[comp][src + 3], true);\n              dataView.setUint16(offset + 4 * INT16_SIZE * type, rowBlock[comp][src + 4], true);\n              dataView.setUint16(offset + 5 * INT16_SIZE * type, rowBlock[comp][src + 5], true);\n              dataView.setUint16(offset + 6 * INT16_SIZE * type, rowBlock[comp][src + 6], true);\n              dataView.setUint16(offset + 7 * INT16_SIZE * type, rowBlock[comp][src + 7], true);\n              offset += 8 * INT16_SIZE * type;\n            }\n          } // handle partial X blocks\n\n\n          if (numFullBlocksX != numBlocksX) {\n            for (let y = 8 * blocky; y < 8 * blocky + maxY; ++y) {\n              const offset = rowOffsets[comp][y] + 8 * numFullBlocksX * INT16_SIZE * type;\n              const src = numFullBlocksX * 64 + (y & 0x7) * 8;\n\n              for (let x = 0; x < maxX; ++x) {\n                dataView.setUint16(offset + x * INT16_SIZE * type, rowBlock[comp][src + x], true);\n              }\n            }\n          }\n        } // comp\n\n      } // blocky\n\n\n      var halfRow = new Uint16Array(width);\n      var dataView = new DataView(outBuffer.buffer); // convert channels back to float, if needed\n\n      for (var comp = 0; comp < numComp; ++comp) {\n        channelData[cscSet.idx[comp]].decoded = true;\n        var type = channelData[cscSet.idx[comp]].type;\n        if (channelData[comp].type != 2) continue;\n\n        for (var y = 0; y < height; ++y) {\n          const offset = rowOffsets[comp][y];\n\n          for (var x = 0; x < width; ++x) {\n            halfRow[x] = dataView.getUint16(offset + x * INT16_SIZE * type, true);\n          }\n\n          for (var x = 0; x < width; ++x) {\n            dataView.setFloat32(offset + x * INT16_SIZE * type, decodeFloat16(halfRow[x]), true);\n          }\n        }\n      }\n    }\n\n    function unRleAC(currAcComp, acBuffer, halfZigBlock) {\n      var acValue;\n      var dctComp = 1;\n\n      while (dctComp < 64) {\n        acValue = acBuffer[currAcComp.value];\n\n        if (acValue == 0xff00) {\n          dctComp = 64;\n        } else if (acValue >> 8 == 0xff) {\n          dctComp += acValue & 0xff;\n        } else {\n          halfZigBlock[dctComp] = acValue;\n          dctComp++;\n        }\n\n        currAcComp.value++;\n      }\n    }\n\n    function unZigZag(src, dst) {\n      dst[0] = decodeFloat16(src[0]);\n      dst[1] = decodeFloat16(src[1]);\n      dst[2] = decodeFloat16(src[5]);\n      dst[3] = decodeFloat16(src[6]);\n      dst[4] = decodeFloat16(src[14]);\n      dst[5] = decodeFloat16(src[15]);\n      dst[6] = decodeFloat16(src[27]);\n      dst[7] = decodeFloat16(src[28]);\n      dst[8] = decodeFloat16(src[2]);\n      dst[9] = decodeFloat16(src[4]);\n      dst[10] = decodeFloat16(src[7]);\n      dst[11] = decodeFloat16(src[13]);\n      dst[12] = decodeFloat16(src[16]);\n      dst[13] = decodeFloat16(src[26]);\n      dst[14] = decodeFloat16(src[29]);\n      dst[15] = decodeFloat16(src[42]);\n      dst[16] = decodeFloat16(src[3]);\n      dst[17] = decodeFloat16(src[8]);\n      dst[18] = decodeFloat16(src[12]);\n      dst[19] = decodeFloat16(src[17]);\n      dst[20] = decodeFloat16(src[25]);\n      dst[21] = decodeFloat16(src[30]);\n      dst[22] = decodeFloat16(src[41]);\n      dst[23] = decodeFloat16(src[43]);\n      dst[24] = decodeFloat16(src[9]);\n      dst[25] = decodeFloat16(src[11]);\n      dst[26] = decodeFloat16(src[18]);\n      dst[27] = decodeFloat16(src[24]);\n      dst[28] = decodeFloat16(src[31]);\n      dst[29] = decodeFloat16(src[40]);\n      dst[30] = decodeFloat16(src[44]);\n      dst[31] = decodeFloat16(src[53]);\n      dst[32] = decodeFloat16(src[10]);\n      dst[33] = decodeFloat16(src[19]);\n      dst[34] = decodeFloat16(src[23]);\n      dst[35] = decodeFloat16(src[32]);\n      dst[36] = decodeFloat16(src[39]);\n      dst[37] = decodeFloat16(src[45]);\n      dst[38] = decodeFloat16(src[52]);\n      dst[39] = decodeFloat16(src[54]);\n      dst[40] = decodeFloat16(src[20]);\n      dst[41] = decodeFloat16(src[22]);\n      dst[42] = decodeFloat16(src[33]);\n      dst[43] = decodeFloat16(src[38]);\n      dst[44] = decodeFloat16(src[46]);\n      dst[45] = decodeFloat16(src[51]);\n      dst[46] = decodeFloat16(src[55]);\n      dst[47] = decodeFloat16(src[60]);\n      dst[48] = decodeFloat16(src[21]);\n      dst[49] = decodeFloat16(src[34]);\n      dst[50] = decodeFloat16(src[37]);\n      dst[51] = decodeFloat16(src[47]);\n      dst[52] = decodeFloat16(src[50]);\n      dst[53] = decodeFloat16(src[56]);\n      dst[54] = decodeFloat16(src[59]);\n      dst[55] = decodeFloat16(src[61]);\n      dst[56] = decodeFloat16(src[35]);\n      dst[57] = decodeFloat16(src[36]);\n      dst[58] = decodeFloat16(src[48]);\n      dst[59] = decodeFloat16(src[49]);\n      dst[60] = decodeFloat16(src[57]);\n      dst[61] = decodeFloat16(src[58]);\n      dst[62] = decodeFloat16(src[62]);\n      dst[63] = decodeFloat16(src[63]);\n    }\n\n    function dctInverse(data) {\n      const a = 0.5 * Math.cos(3.14159 / 4.0);\n      const b = 0.5 * Math.cos(3.14159 / 16.0);\n      const c = 0.5 * Math.cos(3.14159 / 8.0);\n      const d = 0.5 * Math.cos(3.0 * 3.14159 / 16.0);\n      const e = 0.5 * Math.cos(5.0 * 3.14159 / 16.0);\n      const f = 0.5 * Math.cos(3.0 * 3.14159 / 8.0);\n      const g = 0.5 * Math.cos(7.0 * 3.14159 / 16.0);\n      var alpha = new Array(4);\n      var beta = new Array(4);\n      var theta = new Array(4);\n      var gamma = new Array(4);\n\n      for (var row = 0; row < 8; ++row) {\n        var rowPtr = row * 8;\n        alpha[0] = c * data[rowPtr + 2];\n        alpha[1] = f * data[rowPtr + 2];\n        alpha[2] = c * data[rowPtr + 6];\n        alpha[3] = f * data[rowPtr + 6];\n        beta[0] = b * data[rowPtr + 1] + d * data[rowPtr + 3] + e * data[rowPtr + 5] + g * data[rowPtr + 7];\n        beta[1] = d * data[rowPtr + 1] - g * data[rowPtr + 3] - b * data[rowPtr + 5] - e * data[rowPtr + 7];\n        beta[2] = e * data[rowPtr + 1] - b * data[rowPtr + 3] + g * data[rowPtr + 5] + d * data[rowPtr + 7];\n        beta[3] = g * data[rowPtr + 1] - e * data[rowPtr + 3] + d * data[rowPtr + 5] - b * data[rowPtr + 7];\n        theta[0] = a * (data[rowPtr + 0] + data[rowPtr + 4]);\n        theta[3] = a * (data[rowPtr + 0] - data[rowPtr + 4]);\n        theta[1] = alpha[0] + alpha[3];\n        theta[2] = alpha[1] - alpha[2];\n        gamma[0] = theta[0] + theta[1];\n        gamma[1] = theta[3] + theta[2];\n        gamma[2] = theta[3] - theta[2];\n        gamma[3] = theta[0] - theta[1];\n        data[rowPtr + 0] = gamma[0] + beta[0];\n        data[rowPtr + 1] = gamma[1] + beta[1];\n        data[rowPtr + 2] = gamma[2] + beta[2];\n        data[rowPtr + 3] = gamma[3] + beta[3];\n        data[rowPtr + 4] = gamma[3] - beta[3];\n        data[rowPtr + 5] = gamma[2] - beta[2];\n        data[rowPtr + 6] = gamma[1] - beta[1];\n        data[rowPtr + 7] = gamma[0] - beta[0];\n      }\n\n      for (var column = 0; column < 8; ++column) {\n        alpha[0] = c * data[16 + column];\n        alpha[1] = f * data[16 + column];\n        alpha[2] = c * data[48 + column];\n        alpha[3] = f * data[48 + column];\n        beta[0] = b * data[8 + column] + d * data[24 + column] + e * data[40 + column] + g * data[56 + column];\n        beta[1] = d * data[8 + column] - g * data[24 + column] - b * data[40 + column] - e * data[56 + column];\n        beta[2] = e * data[8 + column] - b * data[24 + column] + g * data[40 + column] + d * data[56 + column];\n        beta[3] = g * data[8 + column] - e * data[24 + column] + d * data[40 + column] - b * data[56 + column];\n        theta[0] = a * (data[column] + data[32 + column]);\n        theta[3] = a * (data[column] - data[32 + column]);\n        theta[1] = alpha[0] + alpha[3];\n        theta[2] = alpha[1] - alpha[2];\n        gamma[0] = theta[0] + theta[1];\n        gamma[1] = theta[3] + theta[2];\n        gamma[2] = theta[3] - theta[2];\n        gamma[3] = theta[0] - theta[1];\n        data[0 + column] = gamma[0] + beta[0];\n        data[8 + column] = gamma[1] + beta[1];\n        data[16 + column] = gamma[2] + beta[2];\n        data[24 + column] = gamma[3] + beta[3];\n        data[32 + column] = gamma[3] - beta[3];\n        data[40 + column] = gamma[2] - beta[2];\n        data[48 + column] = gamma[1] - beta[1];\n        data[56 + column] = gamma[0] - beta[0];\n      }\n    }\n\n    function csc709Inverse(data) {\n      for (var i = 0; i < 64; ++i) {\n        var y = data[0][i];\n        var cb = data[1][i];\n        var cr = data[2][i];\n        data[0][i] = y + 1.5747 * cr;\n        data[1][i] = y - 0.1873 * cb - 0.4682 * cr;\n        data[2][i] = y + 1.8556 * cb;\n      }\n    }\n\n    function convertToHalf(src, dst, idx) {\n      for (var i = 0; i < 64; ++i) {\n        dst[idx + i] = DataUtils.toHalfFloat(toLinear(src[i]));\n      }\n    }\n\n    function toLinear(float) {\n      if (float <= 1) {\n        return Math.sign(float) * Math.pow(Math.abs(float), 2.2);\n      } else {\n        return Math.sign(float) * Math.pow(logBase, Math.abs(float) - 1.0);\n      }\n    }\n\n    function uncompressRAW(info) {\n      return new DataView(info.array.buffer, info.offset.value, info.size);\n    }\n\n    function uncompressRLE(info) {\n      var compressed = info.viewer.buffer.slice(info.offset.value, info.offset.value + info.size);\n      var rawBuffer = new Uint8Array(decodeRunLength(compressed));\n      var tmpBuffer = new Uint8Array(rawBuffer.length);\n      predictor(rawBuffer); // revert predictor\n\n      interleaveScalar(rawBuffer, tmpBuffer); // interleave pixels\n\n      return new DataView(tmpBuffer.buffer);\n    }\n\n    function uncompressZIP(info) {\n      var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n      var rawBuffer = unzlibSync(compressed); // eslint-disable-line no-undef\n\n      var tmpBuffer = new Uint8Array(rawBuffer.length);\n      predictor(rawBuffer); // revert predictor\n\n      interleaveScalar(rawBuffer, tmpBuffer); // interleave pixels\n\n      return new DataView(tmpBuffer.buffer);\n    }\n\n    function uncompressPIZ(info) {\n      var inDataView = info.viewer;\n      var inOffset = {\n        value: info.offset.value\n      };\n      var outBuffer = new Uint16Array(info.width * info.scanlineBlockSize * (info.channels * info.type));\n      var bitmap = new Uint8Array(BITMAP_SIZE); // Setup channel info\n\n      var outBufferEnd = 0;\n      var pizChannelData = new Array(info.channels);\n\n      for (var i = 0; i < info.channels; i++) {\n        pizChannelData[i] = {};\n        pizChannelData[i]['start'] = outBufferEnd;\n        pizChannelData[i]['end'] = pizChannelData[i]['start'];\n        pizChannelData[i]['nx'] = info.width;\n        pizChannelData[i]['ny'] = info.lines;\n        pizChannelData[i]['size'] = info.type;\n        outBufferEnd += pizChannelData[i].nx * pizChannelData[i].ny * pizChannelData[i].size;\n      } // Read range compression data\n\n\n      var minNonZero = parseUint16(inDataView, inOffset);\n      var maxNonZero = parseUint16(inDataView, inOffset);\n\n      if (maxNonZero >= BITMAP_SIZE) {\n        throw 'Something is wrong with PIZ_COMPRESSION BITMAP_SIZE';\n      }\n\n      if (minNonZero <= maxNonZero) {\n        for (var i = 0; i < maxNonZero - minNonZero + 1; i++) {\n          bitmap[i + minNonZero] = parseUint8(inDataView, inOffset);\n        }\n      } // Reverse LUT\n\n\n      var lut = new Uint16Array(USHORT_RANGE);\n      var maxValue = reverseLutFromBitmap(bitmap, lut);\n      var length = parseUint32(inDataView, inOffset); // Huffman decoding\n\n      hufUncompress(info.array, inDataView, inOffset, length, outBuffer, outBufferEnd); // Wavelet decoding\n\n      for (var i = 0; i < info.channels; ++i) {\n        var cd = pizChannelData[i];\n\n        for (var j = 0; j < pizChannelData[i].size; ++j) {\n          wav2Decode(outBuffer, cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size, maxValue);\n        }\n      } // Expand the pixel data to their original range\n\n\n      applyLut(lut, outBuffer, outBufferEnd); // Rearrange the pixel data into the format expected by the caller.\n\n      var tmpOffset = 0;\n      var tmpBuffer = new Uint8Array(outBuffer.buffer.byteLength);\n\n      for (var y = 0; y < info.lines; y++) {\n        for (var c = 0; c < info.channels; c++) {\n          var cd = pizChannelData[c];\n          var n = cd.nx * cd.size;\n          var cp = new Uint8Array(outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE);\n          tmpBuffer.set(cp, tmpOffset);\n          tmpOffset += n * INT16_SIZE;\n          cd.end += n;\n        }\n      }\n\n      return new DataView(tmpBuffer.buffer);\n    }\n\n    function uncompressPXR(info) {\n      var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n      var rawBuffer = unzlibSync(compressed); // eslint-disable-line no-undef\n\n      const sz = info.lines * info.channels * info.width;\n      const tmpBuffer = info.type == 1 ? new Uint16Array(sz) : new Uint32Array(sz);\n      let tmpBufferEnd = 0;\n      let writePtr = 0;\n      const ptr = new Array(4);\n\n      for (let y = 0; y < info.lines; y++) {\n        for (let c = 0; c < info.channels; c++) {\n          let pixel = 0;\n\n          switch (info.type) {\n            case 1:\n              ptr[0] = tmpBufferEnd;\n              ptr[1] = ptr[0] + info.width;\n              tmpBufferEnd = ptr[1] + info.width;\n\n              for (let j = 0; j < info.width; ++j) {\n                const diff = rawBuffer[ptr[0]++] << 8 | rawBuffer[ptr[1]++];\n                pixel += diff;\n                tmpBuffer[writePtr] = pixel;\n                writePtr++;\n              }\n\n              break;\n\n            case 2:\n              ptr[0] = tmpBufferEnd;\n              ptr[1] = ptr[0] + info.width;\n              ptr[2] = ptr[1] + info.width;\n              tmpBufferEnd = ptr[2] + info.width;\n\n              for (let j = 0; j < info.width; ++j) {\n                const diff = rawBuffer[ptr[0]++] << 24 | rawBuffer[ptr[1]++] << 16 | rawBuffer[ptr[2]++] << 8;\n                pixel += diff;\n                tmpBuffer[writePtr] = pixel;\n                writePtr++;\n              }\n\n              break;\n          }\n        }\n      }\n\n      return new DataView(tmpBuffer.buffer);\n    }\n\n    function uncompressDWA(info) {\n      var inDataView = info.viewer;\n      var inOffset = {\n        value: info.offset.value\n      };\n      var outBuffer = new Uint8Array(info.width * info.lines * (info.channels * info.type * INT16_SIZE)); // Read compression header information\n\n      var dwaHeader = {\n        version: parseInt64(inDataView, inOffset),\n        unknownUncompressedSize: parseInt64(inDataView, inOffset),\n        unknownCompressedSize: parseInt64(inDataView, inOffset),\n        acCompressedSize: parseInt64(inDataView, inOffset),\n        dcCompressedSize: parseInt64(inDataView, inOffset),\n        rleCompressedSize: parseInt64(inDataView, inOffset),\n        rleUncompressedSize: parseInt64(inDataView, inOffset),\n        rleRawSize: parseInt64(inDataView, inOffset),\n        totalAcUncompressedCount: parseInt64(inDataView, inOffset),\n        totalDcUncompressedCount: parseInt64(inDataView, inOffset),\n        acCompression: parseInt64(inDataView, inOffset)\n      };\n\n      if (dwaHeader.version < 2) {\n        throw 'EXRLoader.parse: ' + EXRHeader.compression + ' version ' + dwaHeader.version + ' is unsupported';\n      } // Read channel ruleset information\n\n\n      var channelRules = new Array();\n      var ruleSize = parseUint16(inDataView, inOffset) - INT16_SIZE;\n\n      while (ruleSize > 0) {\n        var name = parseNullTerminatedString(inDataView.buffer, inOffset);\n        var value = parseUint8(inDataView, inOffset);\n        var compression = value >> 2 & 3;\n        var csc = (value >> 4) - 1;\n        var index = new Int8Array([csc])[0];\n        var type = parseUint8(inDataView, inOffset);\n        channelRules.push({\n          name: name,\n          index: index,\n          type: type,\n          compression: compression\n        });\n        ruleSize -= name.length + 3;\n      } // Classify channels\n\n\n      var channels = EXRHeader.channels;\n      var channelData = new Array(info.channels);\n\n      for (var i = 0; i < info.channels; ++i) {\n        var cd = channelData[i] = {};\n        var channel = channels[i];\n        cd.name = channel.name;\n        cd.compression = UNKNOWN;\n        cd.decoded = false;\n        cd.type = channel.pixelType;\n        cd.pLinear = channel.pLinear;\n        cd.width = info.width;\n        cd.height = info.lines;\n      }\n\n      var cscSet = {\n        idx: new Array(3)\n      };\n\n      for (var offset = 0; offset < info.channels; ++offset) {\n        var cd = channelData[offset];\n\n        for (var i = 0; i < channelRules.length; ++i) {\n          var rule = channelRules[i];\n\n          if (cd.name == rule.name) {\n            cd.compression = rule.compression;\n\n            if (rule.index >= 0) {\n              cscSet.idx[rule.index] = offset;\n            }\n\n            cd.offset = offset;\n          }\n        }\n      } // Read DCT - AC component data\n\n\n      if (dwaHeader.acCompressedSize > 0) {\n        switch (dwaHeader.acCompression) {\n          case STATIC_HUFFMAN:\n            var acBuffer = new Uint16Array(dwaHeader.totalAcUncompressedCount);\n            hufUncompress(info.array, inDataView, inOffset, dwaHeader.acCompressedSize, acBuffer, dwaHeader.totalAcUncompressedCount);\n            break;\n\n          case DEFLATE:\n            var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount);\n            var data = unzlibSync(compressed); // eslint-disable-line no-undef\n\n            var acBuffer = new Uint16Array(data.buffer);\n            inOffset.value += dwaHeader.totalAcUncompressedCount;\n            break;\n        }\n      } // Read DCT - DC component data\n\n\n      if (dwaHeader.dcCompressedSize > 0) {\n        var zlibInfo = {\n          array: info.array,\n          offset: inOffset,\n          size: dwaHeader.dcCompressedSize\n        };\n        var dcBuffer = new Uint16Array(uncompressZIP(zlibInfo).buffer);\n        inOffset.value += dwaHeader.dcCompressedSize;\n      } // Read RLE compressed data\n\n\n      if (dwaHeader.rleRawSize > 0) {\n        var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.rleCompressedSize);\n        var data = unzlibSync(compressed); // eslint-disable-line no-undef\n\n        var rleBuffer = decodeRunLength(data.buffer);\n        inOffset.value += dwaHeader.rleCompressedSize;\n      } // Prepare outbuffer data offset\n\n\n      var outBufferEnd = 0;\n      var rowOffsets = new Array(channelData.length);\n\n      for (var i = 0; i < rowOffsets.length; ++i) {\n        rowOffsets[i] = new Array();\n      }\n\n      for (var y = 0; y < info.lines; ++y) {\n        for (var chan = 0; chan < channelData.length; ++chan) {\n          rowOffsets[chan].push(outBufferEnd);\n          outBufferEnd += channelData[chan].width * info.type * INT16_SIZE;\n        }\n      } // Lossy DCT decode RGB channels\n\n\n      lossyDctDecode(cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer); // Decode other channels\n\n      for (var i = 0; i < channelData.length; ++i) {\n        var cd = channelData[i];\n        if (cd.decoded) continue;\n\n        switch (cd.compression) {\n          case RLE:\n            var row = 0;\n            var rleOffset = 0;\n\n            for (var y = 0; y < info.lines; ++y) {\n              var rowOffsetBytes = rowOffsets[i][row];\n\n              for (var x = 0; x < cd.width; ++x) {\n                for (var byte = 0; byte < INT16_SIZE * cd.type; ++byte) {\n                  outBuffer[rowOffsetBytes++] = rleBuffer[rleOffset + byte * cd.width * cd.height];\n                }\n\n                rleOffset++;\n              }\n\n              row++;\n            }\n\n            break;\n\n          case LOSSY_DCT: // skip\n\n          default:\n            throw 'EXRLoader.parse: unsupported channel compression';\n        }\n      }\n\n      return new DataView(outBuffer.buffer);\n    }\n\n    function parseNullTerminatedString(buffer, offset) {\n      var uintBuffer = new Uint8Array(buffer);\n      var endOffset = 0;\n\n      while (uintBuffer[offset.value + endOffset] != 0) {\n        endOffset += 1;\n      }\n\n      var stringValue = new TextDecoder().decode(uintBuffer.slice(offset.value, offset.value + endOffset));\n      offset.value = offset.value + endOffset + 1;\n      return stringValue;\n    }\n\n    function parseFixedLengthString(buffer, offset, size) {\n      var stringValue = new TextDecoder().decode(new Uint8Array(buffer).slice(offset.value, offset.value + size));\n      offset.value = offset.value + size;\n      return stringValue;\n    }\n\n    function parseRational(dataView, offset) {\n      var x = parseInt32(dataView, offset);\n      var y = parseUint32(dataView, offset);\n      return [x, y];\n    }\n\n    function parseTimecode(dataView, offset) {\n      var x = parseUint32(dataView, offset);\n      var y = parseUint32(dataView, offset);\n      return [x, y];\n    }\n\n    function parseInt32(dataView, offset) {\n      var Int32 = dataView.getInt32(offset.value, true);\n      offset.value = offset.value + INT32_SIZE;\n      return Int32;\n    }\n\n    function parseUint32(dataView, offset) {\n      var Uint32 = dataView.getUint32(offset.value, true);\n      offset.value = offset.value + INT32_SIZE;\n      return Uint32;\n    }\n\n    function parseUint8Array(uInt8Array, offset) {\n      var Uint8 = uInt8Array[offset.value];\n      offset.value = offset.value + INT8_SIZE;\n      return Uint8;\n    }\n\n    function parseUint8(dataView, offset) {\n      var Uint8 = dataView.getUint8(offset.value);\n      offset.value = offset.value + INT8_SIZE;\n      return Uint8;\n    }\n\n    const parseInt64 = function (dataView, offset) {\n      let int;\n\n      if ('getBigInt64' in DataView.prototype) {\n        int = Number(dataView.getBigInt64(offset.value, true));\n      } else {\n        int = dataView.getUint32(offset.value + 4, true) + Number(dataView.getUint32(offset.value, true) << 32);\n      }\n\n      offset.value += ULONG_SIZE;\n      return int;\n    };\n\n    function parseFloat32(dataView, offset) {\n      var float = dataView.getFloat32(offset.value, true);\n      offset.value += FLOAT32_SIZE;\n      return float;\n    }\n\n    function decodeFloat32(dataView, offset) {\n      return DataUtils.toHalfFloat(parseFloat32(dataView, offset));\n    } // https://stackoverflow.com/questions/5678432/decompressing-half-precision-floats-in-javascript\n\n\n    function decodeFloat16(binary) {\n      var exponent = (binary & 0x7c00) >> 10,\n          fraction = binary & 0x03ff;\n      return (binary >> 15 ? -1 : 1) * (exponent ? exponent === 0x1f ? fraction ? NaN : Infinity : Math.pow(2, exponent - 15) * (1 + fraction / 0x400) : 6.103515625e-5 * (fraction / 0x400));\n    }\n\n    function parseUint16(dataView, offset) {\n      var Uint16 = dataView.getUint16(offset.value, true);\n      offset.value += INT16_SIZE;\n      return Uint16;\n    }\n\n    function parseFloat16(buffer, offset) {\n      return decodeFloat16(parseUint16(buffer, offset));\n    }\n\n    function parseChlist(dataView, buffer, offset, size) {\n      var startOffset = offset.value;\n      var channels = [];\n\n      while (offset.value < startOffset + size - 1) {\n        var name = parseNullTerminatedString(buffer, offset);\n        var pixelType = parseInt32(dataView, offset);\n        var pLinear = parseUint8(dataView, offset);\n        offset.value += 3; // reserved, three chars\n\n        var xSampling = parseInt32(dataView, offset);\n        var ySampling = parseInt32(dataView, offset);\n        channels.push({\n          name: name,\n          pixelType: pixelType,\n          pLinear: pLinear,\n          xSampling: xSampling,\n          ySampling: ySampling\n        });\n      }\n\n      offset.value += 1;\n      return channels;\n    }\n\n    function parseChromaticities(dataView, offset) {\n      var redX = parseFloat32(dataView, offset);\n      var redY = parseFloat32(dataView, offset);\n      var greenX = parseFloat32(dataView, offset);\n      var greenY = parseFloat32(dataView, offset);\n      var blueX = parseFloat32(dataView, offset);\n      var blueY = parseFloat32(dataView, offset);\n      var whiteX = parseFloat32(dataView, offset);\n      var whiteY = parseFloat32(dataView, offset);\n      return {\n        redX: redX,\n        redY: redY,\n        greenX: greenX,\n        greenY: greenY,\n        blueX: blueX,\n        blueY: blueY,\n        whiteX: whiteX,\n        whiteY: whiteY\n      };\n    }\n\n    function parseCompression(dataView, offset) {\n      var compressionCodes = ['NO_COMPRESSION', 'RLE_COMPRESSION', 'ZIPS_COMPRESSION', 'ZIP_COMPRESSION', 'PIZ_COMPRESSION', 'PXR24_COMPRESSION', 'B44_COMPRESSION', 'B44A_COMPRESSION', 'DWAA_COMPRESSION', 'DWAB_COMPRESSION'];\n      var compression = parseUint8(dataView, offset);\n      return compressionCodes[compression];\n    }\n\n    function parseBox2i(dataView, offset) {\n      var xMin = parseUint32(dataView, offset);\n      var yMin = parseUint32(dataView, offset);\n      var xMax = parseUint32(dataView, offset);\n      var yMax = parseUint32(dataView, offset);\n      return {\n        xMin: xMin,\n        yMin: yMin,\n        xMax: xMax,\n        yMax: yMax\n      };\n    }\n\n    function parseLineOrder(dataView, offset) {\n      var lineOrders = ['INCREASING_Y'];\n      var lineOrder = parseUint8(dataView, offset);\n      return lineOrders[lineOrder];\n    }\n\n    function parseV2f(dataView, offset) {\n      var x = parseFloat32(dataView, offset);\n      var y = parseFloat32(dataView, offset);\n      return [x, y];\n    }\n\n    function parseV3f(dataView, offset) {\n      var x = parseFloat32(dataView, offset);\n      var y = parseFloat32(dataView, offset);\n      var z = parseFloat32(dataView, offset);\n      return [x, y, z];\n    }\n\n    function parseValue(dataView, buffer, offset, type, size) {\n      if (type === 'string' || type === 'stringvector' || type === 'iccProfile') {\n        return parseFixedLengthString(buffer, offset, size);\n      } else if (type === 'chlist') {\n        return parseChlist(dataView, buffer, offset, size);\n      } else if (type === 'chromaticities') {\n        return parseChromaticities(dataView, offset);\n      } else if (type === 'compression') {\n        return parseCompression(dataView, offset);\n      } else if (type === 'box2i') {\n        return parseBox2i(dataView, offset);\n      } else if (type === 'lineOrder') {\n        return parseLineOrder(dataView, offset);\n      } else if (type === 'float') {\n        return parseFloat32(dataView, offset);\n      } else if (type === 'v2f') {\n        return parseV2f(dataView, offset);\n      } else if (type === 'v3f') {\n        return parseV3f(dataView, offset);\n      } else if (type === 'int') {\n        return parseInt32(dataView, offset);\n      } else if (type === 'rational') {\n        return parseRational(dataView, offset);\n      } else if (type === 'timecode') {\n        return parseTimecode(dataView, offset);\n      } else if (type === 'preview') {\n        offset.value += size;\n        return 'skipped';\n      } else {\n        offset.value += size;\n        return undefined;\n      }\n    }\n\n    function parseHeader(dataView, buffer, offset) {\n      const EXRHeader = {};\n\n      if (dataView.getUint32(0, true) != 20000630) {\n        // magic\n        throw \"THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.\";\n      }\n\n      EXRHeader.version = dataView.getUint8(4);\n      const spec = dataView.getUint8(5); // fullMask\n\n      EXRHeader.spec = {\n        singleTile: !!(spec & 2),\n        longName: !!(spec & 4),\n        deepFormat: !!(spec & 8),\n        multiPart: !!(spec & 16)\n      }; // start of header\n\n      offset.value = 8; // start at 8 - after pre-amble\n\n      var keepReading = true;\n\n      while (keepReading) {\n        var attributeName = parseNullTerminatedString(buffer, offset);\n\n        if (attributeName == 0) {\n          keepReading = false;\n        } else {\n          var attributeType = parseNullTerminatedString(buffer, offset);\n          var attributeSize = parseUint32(dataView, offset);\n          var attributeValue = parseValue(dataView, buffer, offset, attributeType, attributeSize);\n\n          if (attributeValue === undefined) {\n            console.warn(`EXRLoader.parse: skipped unknown header attribute type \\'${attributeType}\\'.`);\n          } else {\n            EXRHeader[attributeName] = attributeValue;\n          }\n        }\n      }\n\n      if (spec != 0) {\n        console.error('EXRHeader:', EXRHeader);\n        throw 'THREE.EXRLoader: provided file is currently unsupported.';\n      }\n\n      return EXRHeader;\n    }\n\n    function setupDecoder(EXRHeader, dataView, uInt8Array, offset, outputType) {\n      const EXRDecoder = {\n        size: 0,\n        viewer: dataView,\n        array: uInt8Array,\n        offset: offset,\n        width: EXRHeader.dataWindow.xMax - EXRHeader.dataWindow.xMin + 1,\n        height: EXRHeader.dataWindow.yMax - EXRHeader.dataWindow.yMin + 1,\n        channels: EXRHeader.channels.length,\n        bytesPerLine: null,\n        lines: null,\n        inputSize: null,\n        type: EXRHeader.channels[0].pixelType,\n        uncompress: null,\n        getter: null,\n        format: null,\n        encoding: null\n      };\n\n      switch (EXRHeader.compression) {\n        case 'NO_COMPRESSION':\n          EXRDecoder.lines = 1;\n          EXRDecoder.uncompress = uncompressRAW;\n          break;\n\n        case 'RLE_COMPRESSION':\n          EXRDecoder.lines = 1;\n          EXRDecoder.uncompress = uncompressRLE;\n          break;\n\n        case 'ZIPS_COMPRESSION':\n          EXRDecoder.lines = 1;\n          EXRDecoder.uncompress = uncompressZIP;\n          break;\n\n        case 'ZIP_COMPRESSION':\n          EXRDecoder.lines = 16;\n          EXRDecoder.uncompress = uncompressZIP;\n          break;\n\n        case 'PIZ_COMPRESSION':\n          EXRDecoder.lines = 32;\n          EXRDecoder.uncompress = uncompressPIZ;\n          break;\n\n        case 'PXR24_COMPRESSION':\n          EXRDecoder.lines = 16;\n          EXRDecoder.uncompress = uncompressPXR;\n          break;\n\n        case 'DWAA_COMPRESSION':\n          EXRDecoder.lines = 32;\n          EXRDecoder.uncompress = uncompressDWA;\n          break;\n\n        case 'DWAB_COMPRESSION':\n          EXRDecoder.lines = 256;\n          EXRDecoder.uncompress = uncompressDWA;\n          break;\n\n        default:\n          throw 'EXRLoader.parse: ' + EXRHeader.compression + ' is unsupported';\n      }\n\n      EXRDecoder.scanlineBlockSize = EXRDecoder.lines;\n\n      if (EXRDecoder.type == 1) {\n        // half\n        switch (outputType) {\n          case FloatType:\n            EXRDecoder.getter = parseFloat16;\n            EXRDecoder.inputSize = INT16_SIZE;\n            break;\n\n          case HalfFloatType:\n            EXRDecoder.getter = parseUint16;\n            EXRDecoder.inputSize = INT16_SIZE;\n            break;\n        }\n      } else if (EXRDecoder.type == 2) {\n        // float\n        switch (outputType) {\n          case FloatType:\n            EXRDecoder.getter = parseFloat32;\n            EXRDecoder.inputSize = FLOAT32_SIZE;\n            break;\n\n          case HalfFloatType:\n            EXRDecoder.getter = decodeFloat32;\n            EXRDecoder.inputSize = FLOAT32_SIZE;\n        }\n      } else {\n        throw 'EXRLoader.parse: unsupported pixelType ' + EXRDecoder.type + ' for ' + EXRHeader.compression + '.';\n      }\n\n      EXRDecoder.blockCount = (EXRHeader.dataWindow.yMax + 1) / EXRDecoder.scanlineBlockSize;\n\n      for (var i = 0; i < EXRDecoder.blockCount; i++) parseInt64(dataView, offset); // scanlineOffset\n      // we should be passed the scanline offset table, ready to start reading pixel data.\n      // RGB images will be converted to RGBA format, preventing software emulation in select devices.\n\n\n      EXRDecoder.outputChannels = EXRDecoder.channels == 3 ? 4 : EXRDecoder.channels;\n      const size = EXRDecoder.width * EXRDecoder.height * EXRDecoder.outputChannels;\n\n      switch (outputType) {\n        case FloatType:\n          EXRDecoder.byteArray = new Float32Array(size); // Fill initially with 1s for the alpha value if the texture is not RGBA, RGB values will be overwritten\n\n          if (EXRDecoder.channels < EXRDecoder.outputChannels) EXRDecoder.byteArray.fill(1, 0, size);\n          break;\n\n        case HalfFloatType:\n          EXRDecoder.byteArray = new Uint16Array(size);\n          if (EXRDecoder.channels < EXRDecoder.outputChannels) EXRDecoder.byteArray.fill(0x3c00, 0, size); // Uint16Array holds half float data, 0x3C00 is 1\n\n          break;\n\n        default:\n          console.error('THREE.EXRLoader: unsupported type: ', outputType);\n          break;\n      }\n\n      EXRDecoder.bytesPerLine = EXRDecoder.width * EXRDecoder.inputSize * EXRDecoder.channels;\n\n      if (EXRDecoder.outputChannels == 4) {\n        EXRDecoder.format = RGBAFormat;\n        EXRDecoder.encoding = LinearEncoding;\n      } else {\n        EXRDecoder.format = RedFormat;\n        EXRDecoder.encoding = LinearEncoding;\n      }\n\n      return EXRDecoder;\n    } // start parsing file [START]\n\n\n    const bufferDataView = new DataView(buffer);\n    const uInt8Array = new Uint8Array(buffer);\n    const offset = {\n      value: 0\n    }; // get header information and validate format.\n\n    const EXRHeader = parseHeader(bufferDataView, buffer, offset); // get input compression information and prepare decoding.\n\n    const EXRDecoder = setupDecoder(EXRHeader, bufferDataView, uInt8Array, offset, this.type);\n    const tmpOffset = {\n      value: 0\n    };\n    const channelOffsets = {\n      R: 0,\n      G: 1,\n      B: 2,\n      A: 3,\n      Y: 0\n    };\n\n    for (let scanlineBlockIdx = 0; scanlineBlockIdx < EXRDecoder.height / EXRDecoder.scanlineBlockSize; scanlineBlockIdx++) {\n      const line = parseUint32(bufferDataView, offset); // line_no\n\n      EXRDecoder.size = parseUint32(bufferDataView, offset); // data_len\n\n      EXRDecoder.lines = line + EXRDecoder.scanlineBlockSize > EXRDecoder.height ? EXRDecoder.height - line : EXRDecoder.scanlineBlockSize;\n      const isCompressed = EXRDecoder.size < EXRDecoder.lines * EXRDecoder.bytesPerLine;\n      const viewer = isCompressed ? EXRDecoder.uncompress(EXRDecoder) : uncompressRAW(EXRDecoder);\n      offset.value += EXRDecoder.size;\n\n      for (let line_y = 0; line_y < EXRDecoder.scanlineBlockSize; line_y++) {\n        const true_y = line_y + scanlineBlockIdx * EXRDecoder.scanlineBlockSize;\n        if (true_y >= EXRDecoder.height) break;\n\n        for (let channelID = 0; channelID < EXRDecoder.channels; channelID++) {\n          const cOff = channelOffsets[EXRHeader.channels[channelID].name];\n\n          for (let x = 0; x < EXRDecoder.width; x++) {\n            tmpOffset.value = (line_y * (EXRDecoder.channels * EXRDecoder.width) + channelID * EXRDecoder.width + x) * EXRDecoder.inputSize;\n            const outIndex = (EXRDecoder.height - 1 - true_y) * (EXRDecoder.width * EXRDecoder.outputChannels) + x * EXRDecoder.outputChannels + cOff;\n            EXRDecoder.byteArray[outIndex] = EXRDecoder.getter(viewer, tmpOffset);\n          }\n        }\n      }\n    }\n\n    return {\n      header: EXRHeader,\n      width: EXRDecoder.width,\n      height: EXRDecoder.height,\n      data: EXRDecoder.byteArray,\n      format: EXRDecoder.format,\n      encoding: EXRDecoder.encoding,\n      type: this.type\n    };\n  }\n\n  setDataType(value) {\n    this.type = value;\n    return this;\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    function onLoadCallback(texture, texData) {\n      texture.encoding = texData.encoding;\n      texture.minFilter = LinearFilter;\n      texture.magFilter = LinearFilter;\n      texture.generateMipmaps = false;\n      texture.flipY = false;\n      if (onLoad) onLoad(texture, texData);\n    }\n\n    return super.load(url, onLoadCallback, onProgress, onError);\n  }\n\n}\n\nexport { EXRLoader };\n"],"mappings":"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CP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,CAAC,CAAC,CAAC;QAC/BU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,CAAC,CAAC,CAAC;QAC/BU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,CAAC,CAAC,CAAC;QAC/BU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;QAChCU,GAAG,CAAC,EAAE,CAAC,GAAGH,aAAa,CAACP,GAAG,CAAC,EAAE,CAAC,CAAC;MAClC;MAEA,SAASL,UAAUA,CAACtD,IAAI,EAAE;QACxB,IAAMtD,CAAC,GAAG,GAAG,GAAGxD,IAAI,CAACoL,GAAG,CAAC,OAAO,GAAG,GAAG,CAAC;QACvC,IAAM3H,CAAC,GAAG,GAAG,GAAGzD,IAAI,CAACoL,GAAG,CAAC,OAAO,GAAG,IAAI,CAAC;QACxC,IAAMrK,CAAC,GAAG,GAAG,GAAGf,IAAI,CAACoL,GAAG,CAAC,OAAO,GAAG,GAAG,CAAC;QACvC,IAAMhH,CAAC,GAAG,GAAG,GAAGpE,IAAI,CAACoL,GAAG,CAAC,GAAG,GAAG,OAAO,GAAG,IAAI,CAAC;QAC9C,IAAMC,CAAC,GAAG,GAAG,GAAGrL,IAAI,CAACoL,GAAG,CAAC,GAAG,GAAG,OAAO,GAAG,IAAI,CAAC;QAC9C,IAAME,CAAC,GAAG,GAAG,GAAGtL,IAAI,CAACoL,GAAG,CAAC,GAAG,GAAG,OAAO,GAAG,GAAG,CAAC;QAC7C,IAAMG,CAAC,GAAG,GAAG,GAAGvL,IAAI,CAACoL,GAAG,CAAC,GAAG,GAAG,OAAO,GAAG,IAAI,CAAC;QAC9C,IAAII,KAAK,GAAG,IAAIjK,KAAK,CAAC,CAAC,CAAC;QACxB,IAAIkK,IAAI,GAAG,IAAIlK,KAAK,CAAC,CAAC,CAAC;QACvB,IAAImK,KAAK,GAAG,IAAInK,KAAK,CAAC,CAAC,CAAC;QACxB,IAAIoK,KAAK,GAAG,IAAIpK,KAAK,CAAC,CAAC,CAAC;QAExB,KAAK,IAAIqK,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAG,CAAC,EAAE,EAAEA,GAAG,EAAE;UAChC,IAAIC,MAAM,GAAGD,GAAG,GAAG,CAAC;UACpBJ,KAAK,CAAC,CAAC,CAAC,GAAGzK,CAAC,GAAG+F,IAAI,CAAC+E,MAAM,GAAG,CAAC,CAAC;UAC/BL,KAAK,CAAC,CAAC,CAAC,GAAGF,CAAC,GAAGxE,IAAI,CAAC+E,MAAM,GAAG,CAAC,CAAC;UAC/BL,KAAK,CAAC,CAAC,CAAC,GAAGzK,CAAC,GAAG+F,IAAI,CAAC+E,MAAM,GAAG,CAAC,CAAC;UAC/BL,KAAK,CAAC,CAAC,CAAC,GAAGF,CAAC,GAAGxE,IAAI,CAAC+E,MAAM,GAAG,CAAC,CAAC;UAC/BJ,IAAI,CAAC,CAAC,CAAC,GAAGhI,CAAC,GAAGqD,IAAI,CAAC+E,MAAM,GAAG,CAAC,CAAC,GAAGzH,CAAC,GAAG0C,IAAI,CAAC+E,MAAM,GAAG,CAAC,CAAC,GAAGR,CAAC,GAAGvE,IAAI,CAAC+E,MAAM,GAAG,CAAC,CAAC,GAAGN,CAAC,GAAGzE,IAAI,CAAC+E,MAAM,GAAG,CAAC,CAAC;UACnGJ,IAAI,CAAC,CAAC,CAAC,GAAGrH,CAAC,GAAG0C,IAAI,CAAC+E,MAAM,GAAG,CAAC,CAAC,GAAGN,CAAC,GAAGzE,IAAI,CAAC+E,MAAM,GAAG,CAAC,CAAC,GAAGpI,CAAC,GAAGqD,IAAI,CAAC+E,MAAM,GAAG,CAAC,CAAC,GAAGR,CAAC,GAAGvE,IAAI,CAAC+E,MAAM,GAAG,CAAC,CAAC;UACnGJ,IAAI,CAAC,CAAC,CAAC,GAAGJ,CAAC,GAAGvE,IAAI,CAAC+E,MAAM,GAAG,CAAC,CAAC,GAAGpI,CAAC,GAAGqD,IAAI,CAAC+E,MAAM,GAAG,CAAC,CAAC,GAAGN,CAAC,GAAGzE,IAAI,CAAC+E,MAAM,GAAG,CAAC,CAAC,GAAGzH,CAAC,GAAG0C,IAAI,CAAC+E,MAAM,GAAG,CAAC,CAAC;UACnGJ,IAAI,CAAC,CAAC,CAAC,GAAGF,CAAC,GAAGzE,IAAI,CAAC+E,MAAM,GAAG,CAAC,CAAC,GAAGR,CAAC,GAAGvE,IAAI,CAAC+E,MAAM,GAAG,CAAC,CAAC,GAAGzH,CAAC,GAAG0C,IAAI,CAAC+E,MAAM,GAAG,CAAC,CAAC,GAAGpI,CAAC,GAAGqD,IAAI,CAAC+E,MAAM,GAAG,CAAC,CAAC;UACnGH,KAAK,CAAC,CAAC,CAAC,GAAGlI,CAAC,IAAIsD,IAAI,CAAC+E,MAAM,GAAG,CAAC,CAAC,GAAG/E,IAAI,CAAC+E,MAAM,GAAG,CAAC,CAAC,CAAC;UACpDH,KAAK,CAAC,CAAC,CAAC,GAAGlI,CAAC,IAAIsD,IAAI,CAAC+E,MAAM,GAAG,CAAC,CAAC,GAAG/E,IAAI,CAAC+E,MAAM,GAAG,CAAC,CAAC,CAAC;UACpDH,KAAK,CAAC,CAAC,CAAC,GAAGF,KAAK,CAAC,CAAC,CAAC,GAAGA,KAAK,CAAC,CAAC,CAAC;UAC9BE,KAAK,CAAC,CAAC,CAAC,GAAGF,KAAK,CAAC,CAAC,CAAC,GAAGA,KAAK,CAAC,CAAC,CAAC;UAC9BG,KAAK,CAAC,CAAC,CAAC,GAAGD,KAAK,CAAC,CAAC,CAAC,GAAGA,KAAK,CAAC,CAAC,CAAC;UAC9BC,KAAK,CAAC,CAAC,CAAC,GAAGD,KAAK,CAAC,CAAC,CAAC,GAAGA,KAAK,CAAC,CAAC,CAAC;UAC9BC,KAAK,CAAC,CAAC,CAAC,GAAGD,KAAK,CAAC,CAAC,CAAC,GAAGA,KAAK,CAAC,CAAC,CAAC;UAC9BC,KAAK,CAAC,CAAC,CAAC,GAAGD,KAAK,CAAC,CAAC,CAAC,GAAGA,KAAK,CAAC,CAAC,CAAC;UAC9B5E,IAAI,CAAC+E,MAAM,GAAG,CAAC,CAAC,GAAGF,KAAK,CAAC,CAAC,CAAC,GAAGF,IAAI,CAAC,CAAC,CAAC;UACrC3E,IAAI,CAAC+E,MAAM,GAAG,CAAC,CAAC,GAAGF,KAAK,CAAC,CAAC,CAAC,GAAGF,IAAI,CAAC,CAAC,CAAC;UACrC3E,IAAI,CAAC+E,MAAM,GAAG,CAAC,CAAC,GAAGF,KAAK,CAAC,CAAC,CAAC,GAAGF,IAAI,CAAC,CAAC,CAAC;UACrC3E,IAAI,CAAC+E,MAAM,GAAG,CAAC,CAAC,GAAGF,KAAK,CAAC,CAAC,CAAC,GAAGF,IAAI,CAAC,CAAC,CAAC;UACrC3E,IAAI,CAAC+E,MAAM,GAAG,CAAC,CAAC,GAAGF,KAAK,CAAC,CAAC,CAAC,GAAGF,IAAI,CAAC,CAAC,CAAC;UACrC3E,IAAI,CAAC+E,MAAM,GAAG,CAAC,CAAC,GAAGF,KAAK,CAAC,CAAC,CAAC,GAAGF,IAAI,CAAC,CAAC,CAAC;UACrC3E,IAAI,CAAC+E,MAAM,GAAG,CAAC,CAAC,GAAGF,KAAK,CAAC,CAAC,CAAC,GAAGF,IAAI,CAAC,CAAC,CAAC;UACrC3E,IAAI,CAAC+E,MAAM,GAAG,CAAC,CAAC,GAAGF,KAAK,CAAC,CAAC,CAAC,GAAGF,IAAI,CAAC,CAAC,CAAC;QACvC;QAEA,KAAK,IAAIK,MAAM,GAAG,CAAC,EAAEA,MAAM,GAAG,CAAC,EAAE,EAAEA,MAAM,EAAE;UACzCN,KAAK,CAAC,CAAC,CAAC,GAAGzK,CAAC,GAAG+F,IAAI,CAAC,EAAE,GAAGgF,MAAM,CAAC;UAChCN,KAAK,CAAC,CAAC,CAAC,GAAGF,CAAC,GAAGxE,IAAI,CAAC,EAAE,GAAGgF,MAAM,CAAC;UAChCN,KAAK,CAAC,CAAC,CAAC,GAAGzK,CAAC,GAAG+F,IAAI,CAAC,EAAE,GAAGgF,MAAM,CAAC;UAChCN,KAAK,CAAC,CAAC,CAAC,GAAGF,CAAC,GAAGxE,IAAI,CAAC,EAAE,GAAGgF,MAAM,CAAC;UAChCL,IAAI,CAAC,CAAC,CAAC,GAAGhI,CAAC,GAAGqD,IAAI,CAAC,CAAC,GAAGgF,MAAM,CAAC,GAAG1H,CAAC,GAAG0C,IAAI,CAAC,EAAE,GAAGgF,MAAM,CAAC,GAAGT,CAAC,GAAGvE,IAAI,CAAC,EAAE,GAAGgF,MAAM,CAAC,GAAGP,CAAC,GAAGzE,IAAI,CAAC,EAAE,GAAGgF,MAAM,CAAC;UACtGL,IAAI,CAAC,CAAC,CAAC,GAAGrH,CAAC,GAAG0C,IAAI,CAAC,CAAC,GAAGgF,MAAM,CAAC,GAAGP,CAAC,GAAGzE,IAAI,CAAC,EAAE,GAAGgF,MAAM,CAAC,GAAGrI,CAAC,GAAGqD,IAAI,CAAC,EAAE,GAAGgF,MAAM,CAAC,GAAGT,CAAC,GAAGvE,IAAI,CAAC,EAAE,GAAGgF,MAAM,CAAC;UACtGL,IAAI,CAAC,CAAC,CAAC,GAAGJ,CAAC,GAAGvE,IAAI,CAAC,CAAC,GAAGgF,MAAM,CAAC,GAAGrI,CAAC,GAAGqD,IAAI,CAAC,EAAE,GAAGgF,MAAM,CAAC,GAAGP,CAAC,GAAGzE,IAAI,CAAC,EAAE,GAAGgF,MAAM,CAAC,GAAG1H,CAAC,GAAG0C,IAAI,CAAC,EAAE,GAAGgF,MAAM,CAAC;UACtGL,IAAI,CAAC,CAAC,CAAC,GAAGF,CAAC,GAAGzE,IAAI,CAAC,CAAC,GAAGgF,MAAM,CAAC,GAAGT,CAAC,GAAGvE,IAAI,CAAC,EAAE,GAAGgF,MAAM,CAAC,GAAG1H,CAAC,GAAG0C,IAAI,CAAC,EAAE,GAAGgF,MAAM,CAAC,GAAGrI,CAAC,GAAGqD,IAAI,CAAC,EAAE,GAAGgF,MAAM,CAAC;UACtGJ,KAAK,CAAC,CAAC,CAAC,GAAGlI,CAAC,IAAIsD,IAAI,CAACgF,MAAM,CAAC,GAAGhF,IAAI,CAAC,EAAE,GAAGgF,MAAM,CAAC,CAAC;UACjDJ,KAAK,CAAC,CAAC,CAAC,GAAGlI,CAAC,IAAIsD,IAAI,CAACgF,MAAM,CAAC,GAAGhF,IAAI,CAAC,EAAE,GAAGgF,MAAM,CAAC,CAAC;UACjDJ,KAAK,CAAC,CAAC,CAAC,GAAGF,KAAK,CAAC,CAAC,CAAC,GAAGA,KAAK,CAAC,CAAC,CAAC;UAC9BE,KAAK,CAAC,CAAC,CAAC,GAAGF,KAAK,CAAC,CAAC,CAAC,GAAGA,KAAK,CAAC,CAAC,CAAC;UAC9BG,KAAK,CAAC,CAAC,CAAC,GAAGD,KAAK,CAAC,CAAC,CAAC,GAAGA,KAAK,CAAC,CAAC,CAAC;UAC9BC,KAAK,CAAC,CAAC,CAAC,GAAGD,KAAK,CAAC,CAAC,CAAC,GAAGA,KAAK,CAAC,CAAC,CAAC;UAC9BC,KAAK,CAAC,CAAC,CAAC,GAAGD,KAAK,CAAC,CAAC,CAAC,GAAGA,KAAK,CAAC,CAAC,CAAC;UAC9BC,KAAK,CAAC,CAAC,CAAC,GAAGD,KAAK,CAAC,CAAC,CAAC,GAAGA,KAAK,CAAC,CAAC,CAAC;UAC9B5E,IAAI,CAAC,CAAC,GAAGgF,MAAM,CAAC,GAAGH,KAAK,CAAC,CAAC,CAAC,GAAGF,IAAI,CAAC,CAAC,CAAC;UACrC3E,IAAI,CAAC,CAAC,GAAGgF,MAAM,CAAC,GAAGH,KAAK,CAAC,CAAC,CAAC,GAAGF,IAAI,CAAC,CAAC,CAAC;UACrC3E,IAAI,CAAC,EAAE,GAAGgF,MAAM,CAAC,GAAGH,KAAK,CAAC,CAAC,CAAC,GAAGF,IAAI,CAAC,CAAC,CAAC;UACtC3E,IAAI,CAAC,EAAE,GAAGgF,MAAM,CAAC,GAAGH,KAAK,CAAC,CAAC,CAAC,GAAGF,IAAI,CAAC,CAAC,CAAC;UACtC3E,IAAI,CAAC,EAAE,GAAGgF,MAAM,CAAC,GAAGH,KAAK,CAAC,CAAC,CAAC,GAAGF,IAAI,CAAC,CAAC,CAAC;UACtC3E,IAAI,CAAC,EAAE,GAAGgF,MAAM,CAAC,GAAGH,KAAK,CAAC,CAAC,CAAC,GAAGF,IAAI,CAAC,CAAC,CAAC;UACtC3E,IAAI,CAAC,EAAE,GAAGgF,MAAM,CAAC,GAAGH,KAAK,CAAC,CAAC,CAAC,GAAGF,IAAI,CAAC,CAAC,CAAC;UACtC3E,IAAI,CAAC,EAAE,GAAGgF,MAAM,CAAC,GAAGH,KAAK,CAAC,CAAC,CAAC,GAAGF,IAAI,CAAC,CAAC,CAAC;QACxC;MACF;MAEA,SAASpB,aAAaA,CAACvD,IAAI,EAAE;QAC3B,KAAK,IAAIxG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,EAAE,EAAE,EAAEA,CAAC,EAAE;UAC3B,IAAIkK,CAAC,GAAG1D,IAAI,CAAC,CAAC,CAAC,CAACxG,CAAC,CAAC;UAClB,IAAIyL,EAAE,GAAGjF,IAAI,CAAC,CAAC,CAAC,CAACxG,CAAC,CAAC;UACnB,IAAI0L,EAAE,GAAGlF,IAAI,CAAC,CAAC,CAAC,CAACxG,CAAC,CAAC;UACnBwG,IAAI,CAAC,CAAC,CAAC,CAACxG,CAAC,CAAC,GAAGkK,CAAC,GAAG,MAAM,GAAGwB,EAAE;UAC5BlF,IAAI,CAAC,CAAC,CAAC,CAACxG,CAAC,CAAC,GAAGkK,CAAC,GAAG,MAAM,GAAGuB,EAAE,GAAG,MAAM,GAAGC,EAAE;UAC1ClF,IAAI,CAAC,CAAC,CAAC,CAACxG,CAAC,CAAC,GAAGkK,CAAC,GAAG,MAAM,GAAGuB,EAAE;QAC9B;MACF;MAEA,SAASzB,aAAaA,CAACG,GAAG,EAAEU,GAAG,EAAExC,GAAG,EAAE;QACpC,KAAK,IAAIrI,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,EAAE,EAAE,EAAEA,CAAC,EAAE;UAC3B6K,GAAG,CAACxC,GAAG,GAAGrI,CAAC,CAAC,GAAG/C,SAAS,CAAC0O,WAAW,CAACC,QAAQ,CAACzB,GAAG,CAACnK,CAAC,CAAC,CAAC,CAAC;QACxD;MACF;MAEA,SAAS4L,QAAQA,CAACC,KAAK,EAAE;QACvB,IAAIA,KAAK,IAAI,CAAC,EAAE;UACd,OAAOnM,IAAI,CAACoM,IAAI,CAACD,KAAK,CAAC,GAAGnM,IAAI,CAACC,GAAG,CAACD,IAAI,CAACqM,GAAG,CAACF,KAAK,CAAC,EAAE,GAAG,CAAC;QAC1D,CAAC,MAAM;UACL,OAAOnM,IAAI,CAACoM,IAAI,CAACD,KAAK,CAAC,GAAGnM,IAAI,CAACC,GAAG,CAACF,OAAO,EAAEC,IAAI,CAACqM,GAAG,CAACF,KAAK,CAAC,GAAG,GAAG,CAAC;QACpE;MACF;MAEA,SAASG,aAAaA,CAACC,IAAI,EAAE;QAC3B,OAAO,IAAIzE,QAAQ,CAACyE,IAAI,CAACC,KAAK,CAACjO,MAAM,EAAEgO,IAAI,CAAChC,MAAM,CAAClM,KAAK,EAAEkO,IAAI,CAAC5E,IAAI,CAAC;MACtE;MAEA,SAAS8E,aAAaA,CAACF,IAAI,EAAE;QAC3B,IAAIG,UAAU,GAAGH,IAAI,CAACI,MAAM,CAACpO,MAAM,CAACqO,KAAK,CAACL,IAAI,CAAChC,MAAM,CAAClM,KAAK,EAAEkO,IAAI,CAAChC,MAAM,CAAClM,KAAK,GAAGkO,IAAI,CAAC5E,IAAI,CAAC;QAC3F,IAAIkF,SAAS,GAAG,IAAI3J,UAAU,CAACwE,eAAe,CAACgF,UAAU,CAAC,CAAC;QAC3D,IAAII,SAAS,GAAG,IAAI5J,UAAU,CAAC2J,SAAS,CAAC1F,MAAM,CAAC;QAChDH,SAAS,CAAC6F,SAAS,CAAC,CAAC,CAAC;;QAEtBzF,gBAAgB,CAACyF,SAAS,EAAEC,SAAS,CAAC,CAAC,CAAC;;QAExC,OAAO,IAAIhF,QAAQ,CAACgF,SAAS,CAACvO,MAAM,CAAC;MACvC;MAEA,SAASwO,aAAaA,CAACR,IAAI,EAAE;QAC3B,IAAIG,UAAU,GAAGH,IAAI,CAACC,KAAK,CAACI,KAAK,CAACL,IAAI,CAAChC,MAAM,CAAClM,KAAK,EAAEkO,IAAI,CAAChC,MAAM,CAAClM,KAAK,GAAGkO,IAAI,CAAC5E,IAAI,CAAC;QACnF,IAAIkF,SAAS,GAAGrP,UAAU,CAACkP,UAAU,CAAC,CAAC,CAAC;;QAExC,IAAII,SAAS,GAAG,IAAI5J,UAAU,CAAC2J,SAAS,CAAC1F,MAAM,CAAC;QAChDH,SAAS,CAAC6F,SAAS,CAAC,CAAC,CAAC;;QAEtBzF,gBAAgB,CAACyF,SAAS,EAAEC,SAAS,CAAC,CAAC,CAAC;;QAExC,OAAO,IAAIhF,QAAQ,CAACgF,SAAS,CAACvO,MAAM,CAAC;MACvC;MAEA,SAASyO,aAAaA,CAACT,IAAI,EAAE;QAC3B,IAAI3K,UAAU,GAAG2K,IAAI,CAACI,MAAM;QAC5B,IAAIvL,QAAQ,GAAG;UACb/C,KAAK,EAAEkO,IAAI,CAAChC,MAAM,CAAClM;QACrB,CAAC;QACD,IAAIyE,SAAS,GAAG,IAAI8G,WAAW,CAAC2C,IAAI,CAAC7D,KAAK,GAAG6D,IAAI,CAACU,iBAAiB,IAAIV,IAAI,CAACW,QAAQ,GAAGX,IAAI,CAACrO,IAAI,CAAC,CAAC;QAClG,IAAIiC,MAAM,GAAG,IAAI+C,UAAU,CAACzE,WAAW,CAAC,CAAC,CAAC;;QAE1C,IAAI0O,YAAY,GAAG,CAAC;QACpB,IAAIC,cAAc,GAAG,IAAI7L,KAAK,CAACgL,IAAI,CAACW,QAAQ,CAAC;QAE7C,KAAK,IAAI5M,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiM,IAAI,CAACW,QAAQ,EAAE5M,CAAC,EAAE,EAAE;UACtC8M,cAAc,CAAC9M,CAAC,CAAC,GAAG,CAAC,CAAC;UACtB8M,cAAc,CAAC9M,CAAC,CAAC,CAAC,OAAO,CAAC,GAAG6M,YAAY;UACzCC,cAAc,CAAC9M,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG8M,cAAc,CAAC9M,CAAC,CAAC,CAAC,OAAO,CAAC;UACrD8M,cAAc,CAAC9M,CAAC,CAAC,CAAC,IAAI,CAAC,GAAGiM,IAAI,CAAC7D,KAAK;UACpC0E,cAAc,CAAC9M,CAAC,CAAC,CAAC,IAAI,CAAC,GAAGiM,IAAI,CAACc,KAAK;UACpCD,cAAc,CAAC9M,CAAC,CAAC,CAAC,MAAM,CAAC,GAAGiM,IAAI,CAACrO,IAAI;UACrCiP,YAAY,IAAIC,cAAc,CAAC9M,CAAC,CAAC,CAACmE,EAAE,GAAG2I,cAAc,CAAC9M,CAAC,CAAC,CAACqE,EAAE,GAAGyI,cAAc,CAAC9M,CAAC,CAAC,CAACqH,IAAI;QACtF,CAAC,CAAC;;QAGF,IAAI2F,UAAU,GAAGC,WAAW,CAAC3L,UAAU,EAAER,QAAQ,CAAC;QAClD,IAAIoM,UAAU,GAAGD,WAAW,CAAC3L,UAAU,EAAER,QAAQ,CAAC;QAElD,IAAIoM,UAAU,IAAI/O,WAAW,EAAE;UAC7B,MAAM,qDAAqD;QAC7D;QAEA,IAAI6O,UAAU,IAAIE,UAAU,EAAE;UAC5B,KAAK,IAAIlN,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkN,UAAU,GAAGF,UAAU,GAAG,CAAC,EAAEhN,CAAC,EAAE,EAAE;YACpDH,MAAM,CAACG,CAAC,GAAGgN,UAAU,CAAC,GAAGG,UAAU,CAAC7L,UAAU,EAAER,QAAQ,CAAC;UAC3D;QACF,CAAC,CAAC;;QAGF,IAAIhB,GAAG,GAAG,IAAIwJ,WAAW,CAACpL,YAAY,CAAC;QACvC,IAAIkP,QAAQ,GAAGxN,oBAAoB,CAACC,MAAM,EAAEC,GAAG,CAAC;QAChD,IAAI+G,MAAM,GAAGR,WAAW,CAAC/E,UAAU,EAAER,QAAQ,CAAC,CAAC,CAAC;;QAEhDmF,aAAa,CAACgG,IAAI,CAACC,KAAK,EAAE5K,UAAU,EAAER,QAAQ,EAAE+F,MAAM,EAAErE,SAAS,EAAEqK,YAAY,CAAC,CAAC,CAAC;;QAElF,KAAK,IAAI7M,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiM,IAAI,CAACW,QAAQ,EAAE,EAAE5M,CAAC,EAAE;UACtC,IAAIqN,EAAE,GAAGP,cAAc,CAAC9M,CAAC,CAAC;UAE1B,KAAK,IAAIkE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG4I,cAAc,CAAC9M,CAAC,CAAC,CAACqH,IAAI,EAAE,EAAEnD,CAAC,EAAE;YAC/CD,UAAU,CAACzB,SAAS,EAAE6K,EAAE,CAACC,KAAK,GAAGpJ,CAAC,EAAEmJ,EAAE,CAAClJ,EAAE,EAAEkJ,EAAE,CAAChG,IAAI,EAAEgG,EAAE,CAAChJ,EAAE,EAAEgJ,EAAE,CAAClJ,EAAE,GAAGkJ,EAAE,CAAChG,IAAI,EAAE+F,QAAQ,CAAC;UACvF;QACF,CAAC,CAAC;;QAGF7G,QAAQ,CAACzG,GAAG,EAAE0C,SAAS,EAAEqK,YAAY,CAAC,CAAC,CAAC;;QAExC,IAAIU,SAAS,GAAG,CAAC;QACjB,IAAIf,SAAS,GAAG,IAAI5J,UAAU,CAACJ,SAAS,CAACvE,MAAM,CAACqJ,UAAU,CAAC;QAE3D,KAAK,IAAI4C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG+B,IAAI,CAACc,KAAK,EAAE7C,CAAC,EAAE,EAAE;UACnC,KAAK,IAAIzJ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGwL,IAAI,CAACW,QAAQ,EAAEnM,CAAC,EAAE,EAAE;YACtC,IAAI4M,EAAE,GAAGP,cAAc,CAACrM,CAAC,CAAC;YAC1B,IAAIR,CAAC,GAAGoN,EAAE,CAAClJ,EAAE,GAAGkJ,EAAE,CAAChG,IAAI;YACvB,IAAImG,EAAE,GAAG,IAAI5K,UAAU,CAACJ,SAAS,CAACvE,MAAM,EAAEoP,EAAE,CAACI,GAAG,GAAGvO,UAAU,EAAEe,CAAC,GAAGf,UAAU,CAAC;YAC9EsN,SAAS,CAACkB,GAAG,CAACF,EAAE,EAAED,SAAS,CAAC;YAC5BA,SAAS,IAAItN,CAAC,GAAGf,UAAU;YAC3BmO,EAAE,CAACI,GAAG,IAAIxN,CAAC;UACb;QACF;QAEA,OAAO,IAAIuH,QAAQ,CAACgF,SAAS,CAACvO,MAAM,CAAC;MACvC;MAEA,SAAS0P,aAAaA,CAAC1B,IAAI,EAAE;QAC3B,IAAIG,UAAU,GAAGH,IAAI,CAACC,KAAK,CAACI,KAAK,CAACL,IAAI,CAAChC,MAAM,CAAClM,KAAK,EAAEkO,IAAI,CAAChC,MAAM,CAAClM,KAAK,GAAGkO,IAAI,CAAC5E,IAAI,CAAC;QACnF,IAAIkF,SAAS,GAAGrP,UAAU,CAACkP,UAAU,CAAC,CAAC,CAAC;;QAExC,IAAMwB,EAAE,GAAG3B,IAAI,CAACc,KAAK,GAAGd,IAAI,CAACW,QAAQ,GAAGX,IAAI,CAAC7D,KAAK;QAClD,IAAMoE,SAAS,GAAGP,IAAI,CAACrO,IAAI,IAAI,CAAC,GAAG,IAAI0L,WAAW,CAACsE,EAAE,CAAC,GAAG,IAAIC,WAAW,CAACD,EAAE,CAAC;QAC5E,IAAIE,YAAY,GAAG,CAAC;QACpB,IAAIC,QAAQ,GAAG,CAAC;QAChB,IAAMC,GAAG,GAAG,IAAI/M,KAAK,CAAC,CAAC,CAAC;QAExB,KAAK,IAAIiJ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG+B,IAAI,CAACc,KAAK,EAAE7C,CAAC,EAAE,EAAE;UACnC,KAAK,IAAIzJ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGwL,IAAI,CAACW,QAAQ,EAAEnM,CAAC,EAAE,EAAE;YACtC,IAAIwN,KAAK,GAAG,CAAC;YAEb,QAAQhC,IAAI,CAACrO,IAAI;cACf,KAAK,CAAC;gBACJoQ,GAAG,CAAC,CAAC,CAAC,GAAGF,YAAY;gBACrBE,GAAG,CAAC,CAAC,CAAC,GAAGA,GAAG,CAAC,CAAC,CAAC,GAAG/B,IAAI,CAAC7D,KAAK;gBAC5B0F,YAAY,GAAGE,GAAG,CAAC,CAAC,CAAC,GAAG/B,IAAI,CAAC7D,KAAK;gBAElC,KAAK,IAAIlE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG+H,IAAI,CAAC7D,KAAK,EAAE,EAAElE,CAAC,EAAE;kBACnC,IAAMgK,IAAI,GAAG3B,SAAS,CAACyB,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,GAAGzB,SAAS,CAACyB,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC;kBAC3DC,KAAK,IAAIC,IAAI;kBACb1B,SAAS,CAACuB,QAAQ,CAAC,GAAGE,KAAK;kBAC3BF,QAAQ,EAAE;gBACZ;gBAEA;cAEF,KAAK,CAAC;gBACJC,GAAG,CAAC,CAAC,CAAC,GAAGF,YAAY;gBACrBE,GAAG,CAAC,CAAC,CAAC,GAAGA,GAAG,CAAC,CAAC,CAAC,GAAG/B,IAAI,CAAC7D,KAAK;gBAC5B4F,GAAG,CAAC,CAAC,CAAC,GAAGA,GAAG,CAAC,CAAC,CAAC,GAAG/B,IAAI,CAAC7D,KAAK;gBAC5B0F,YAAY,GAAGE,GAAG,CAAC,CAAC,CAAC,GAAG/B,IAAI,CAAC7D,KAAK;gBAElC,KAAK,IAAIlE,EAAC,GAAG,CAAC,EAAEA,EAAC,GAAG+H,IAAI,CAAC7D,KAAK,EAAE,EAAElE,EAAC,EAAE;kBACnC,IAAMgK,KAAI,GAAG3B,SAAS,CAACyB,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,EAAE,GAAGzB,SAAS,CAACyB,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,EAAE,GAAGzB,SAAS,CAACyB,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC;kBAC7FC,KAAK,IAAIC,KAAI;kBACb1B,SAAS,CAACuB,QAAQ,CAAC,GAAGE,KAAK;kBAC3BF,QAAQ,EAAE;gBACZ;gBAEA;YAAM;UAEZ;QACF;QAEA,OAAO,IAAIvG,QAAQ,CAACgF,SAAS,CAACvO,MAAM,CAAC;MACvC;MAEA,SAASkQ,aAAaA,CAAClC,IAAI,EAAE;QAC3B,IAAI3K,UAAU,GAAG2K,IAAI,CAACI,MAAM;QAC5B,IAAIvL,QAAQ,GAAG;UACb/C,KAAK,EAAEkO,IAAI,CAAChC,MAAM,CAAClM;QACrB,CAAC;QACD,IAAIyE,SAAS,GAAG,IAAII,UAAU,CAACqJ,IAAI,CAAC7D,KAAK,GAAG6D,IAAI,CAACc,KAAK,IAAId,IAAI,CAACW,QAAQ,GAAGX,IAAI,CAACrO,IAAI,GAAGsB,UAAU,CAAC,CAAC,CAAC,CAAC;;QAEpG,IAAIkP,SAAS,GAAG;UACdC,OAAO,EAAEC,UAAU,CAAChN,UAAU,EAAER,QAAQ,CAAC;UACzCyN,uBAAuB,EAAED,UAAU,CAAChN,UAAU,EAAER,QAAQ,CAAC;UACzD0N,qBAAqB,EAAEF,UAAU,CAAChN,UAAU,EAAER,QAAQ,CAAC;UACvD2N,gBAAgB,EAAEH,UAAU,CAAChN,UAAU,EAAER,QAAQ,CAAC;UAClD4N,gBAAgB,EAAEJ,UAAU,CAAChN,UAAU,EAAER,QAAQ,CAAC;UAClD6N,iBAAiB,EAAEL,UAAU,CAAChN,UAAU,EAAER,QAAQ,CAAC;UACnD8N,mBAAmB,EAAEN,UAAU,CAAChN,UAAU,EAAER,QAAQ,CAAC;UACrD+N,UAAU,EAAEP,UAAU,CAAChN,UAAU,EAAER,QAAQ,CAAC;UAC5CgO,wBAAwB,EAAER,UAAU,CAAChN,UAAU,EAAER,QAAQ,CAAC;UAC1DiO,wBAAwB,EAAET,UAAU,CAAChN,UAAU,EAAER,QAAQ,CAAC;UAC1DkO,aAAa,EAAEV,UAAU,CAAChN,UAAU,EAAER,QAAQ;QAChD,CAAC;QAED,IAAIsN,SAAS,CAACC,OAAO,GAAG,CAAC,EAAE;UACzB,MAAM,mBAAmB,GAAGY,SAAS,CAACC,WAAW,GAAG,WAAW,GAAGd,SAAS,CAACC,OAAO,GAAG,iBAAiB;QACzG,CAAC,CAAC;;QAGF,IAAIc,YAAY,GAAG,IAAIlO,KAAK,EAAE;QAC9B,IAAImO,QAAQ,GAAGnC,WAAW,CAAC3L,UAAU,EAAER,QAAQ,CAAC,GAAG5B,UAAU;QAE7D,OAAOkQ,QAAQ,GAAG,CAAC,EAAE;UACnB,IAAIC,IAAI,GAAGC,yBAAyB,CAAChO,UAAU,CAACrD,MAAM,EAAE6C,QAAQ,CAAC;UACjE,IAAI/C,KAAK,GAAGoP,UAAU,CAAC7L,UAAU,EAAER,QAAQ,CAAC;UAC5C,IAAIoO,WAAW,GAAGnR,KAAK,IAAI,CAAC,GAAG,CAAC;UAChC,IAAIwR,GAAG,GAAG,CAACxR,KAAK,IAAI,CAAC,IAAI,CAAC;UAC1B,IAAIiI,KAAK,GAAG,IAAIwJ,SAAS,CAAC,CAACD,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;UACnC,IAAI3R,IAAI,GAAGuP,UAAU,CAAC7L,UAAU,EAAER,QAAQ,CAAC;UAC3CqO,YAAY,CAACxH,IAAI,CAAC;YAChB0H,IAAI,EAAEA,IAAI;YACVrJ,KAAK,EAAEA,KAAK;YACZpI,IAAI,EAAEA,IAAI;YACVsR,WAAW,EAAEA;UACf,CAAC,CAAC;UACFE,QAAQ,IAAIC,IAAI,CAACxI,MAAM,GAAG,CAAC;QAC7B,CAAC,CAAC;;QAGF,IAAI+F,QAAQ,GAAGqC,SAAS,CAACrC,QAAQ;QACjC,IAAI5E,WAAW,GAAG,IAAI/G,KAAK,CAACgL,IAAI,CAACW,QAAQ,CAAC;QAE1C,KAAK,IAAI5M,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiM,IAAI,CAACW,QAAQ,EAAE,EAAE5M,CAAC,EAAE;UACtC,IAAIqN,EAAE,GAAGrF,WAAW,CAAChI,CAAC,CAAC,GAAG,CAAC,CAAC;UAC5B,IAAIyP,OAAO,GAAG7C,QAAQ,CAAC5M,CAAC,CAAC;UACzBqN,EAAE,CAACgC,IAAI,GAAGI,OAAO,CAACJ,IAAI;UACtBhC,EAAE,CAAC6B,WAAW,GAAG5P,OAAO;UACxB+N,EAAE,CAAC9C,OAAO,GAAG,KAAK;UAClB8C,EAAE,CAACzP,IAAI,GAAG6R,OAAO,CAACC,SAAS;UAC3BrC,EAAE,CAACsC,OAAO,GAAGF,OAAO,CAACE,OAAO;UAC5BtC,EAAE,CAACjF,KAAK,GAAG6D,IAAI,CAAC7D,KAAK;UACrBiF,EAAE,CAAC/E,MAAM,GAAG2D,IAAI,CAACc,KAAK;QACxB;QAEA,IAAIjF,MAAM,GAAG;UACXO,GAAG,EAAE,IAAIpH,KAAK,CAAC,CAAC;QAClB,CAAC;QAED,KAAK,IAAIgJ,MAAM,GAAG,CAAC,EAAEA,MAAM,GAAGgC,IAAI,CAACW,QAAQ,EAAE,EAAE3C,MAAM,EAAE;UACrD,IAAIoD,EAAE,GAAGrF,WAAW,CAACiC,MAAM,CAAC;UAE5B,KAAK,IAAIjK,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGmP,YAAY,CAACtI,MAAM,EAAE,EAAE7G,CAAC,EAAE;YAC5C,IAAI4P,IAAI,GAAGT,YAAY,CAACnP,CAAC,CAAC;YAE1B,IAAIqN,EAAE,CAACgC,IAAI,IAAIO,IAAI,CAACP,IAAI,EAAE;cACxBhC,EAAE,CAAC6B,WAAW,GAAGU,IAAI,CAACV,WAAW;cAEjC,IAAIU,IAAI,CAAC5J,KAAK,IAAI,CAAC,EAAE;gBACnB8B,MAAM,CAACO,GAAG,CAACuH,IAAI,CAAC5J,KAAK,CAAC,GAAGiE,MAAM;cACjC;cAEAoD,EAAE,CAACpD,MAAM,GAAGA,MAAM;YACpB;UACF;QACF,CAAC,CAAC;;QAGF,IAAImE,SAAS,CAACK,gBAAgB,GAAG,CAAC,EAAE;UAClC,QAAQL,SAAS,CAACY,aAAa;YAC7B,KAAK5P,cAAc;cACjB,IAAI6I,QAAQ,GAAG,IAAIqB,WAAW,CAAC8E,SAAS,CAACU,wBAAwB,CAAC;cAClE7I,aAAa,CAACgG,IAAI,CAACC,KAAK,EAAE5K,UAAU,EAAER,QAAQ,EAAEsN,SAAS,CAACK,gBAAgB,EAAExG,QAAQ,EAAEmG,SAAS,CAACU,wBAAwB,CAAC;cACzH;YAEF,KAAKzP,OAAO;cACV,IAAI+M,UAAU,GAAGH,IAAI,CAACC,KAAK,CAACI,KAAK,CAACxL,QAAQ,CAAC/C,KAAK,EAAE+C,QAAQ,CAAC/C,KAAK,GAAGqQ,SAAS,CAACU,wBAAwB,CAAC;cACtG,IAAItI,IAAI,GAAGtJ,UAAU,CAACkP,UAAU,CAAC,CAAC,CAAC;;cAEnC,IAAInE,QAAQ,GAAG,IAAIqB,WAAW,CAAC9C,IAAI,CAACvI,MAAM,CAAC;cAC3C6C,QAAQ,CAAC/C,KAAK,IAAIqQ,SAAS,CAACU,wBAAwB;cACpD;UAAM;QAEZ,CAAC,CAAC;;QAGF,IAAIV,SAAS,CAACM,gBAAgB,GAAG,CAAC,EAAE;UAClC,IAAImB,QAAQ,GAAG;YACb3D,KAAK,EAAED,IAAI,CAACC,KAAK;YACjBjC,MAAM,EAAEnJ,QAAQ;YAChBuG,IAAI,EAAE+G,SAAS,CAACM;UAClB,CAAC;UACD,IAAIxG,QAAQ,GAAG,IAAIoB,WAAW,CAACmD,aAAa,CAACoD,QAAQ,CAAC,CAAC5R,MAAM,CAAC;UAC9D6C,QAAQ,CAAC/C,KAAK,IAAIqQ,SAAS,CAACM,gBAAgB;QAC9C,CAAC,CAAC;;QAGF,IAAIN,SAAS,CAACS,UAAU,GAAG,CAAC,EAAE;UAC5B,IAAIzC,UAAU,GAAGH,IAAI,CAACC,KAAK,CAACI,KAAK,CAACxL,QAAQ,CAAC/C,KAAK,EAAE+C,QAAQ,CAAC/C,KAAK,GAAGqQ,SAAS,CAACO,iBAAiB,CAAC;UAC/F,IAAInI,IAAI,GAAGtJ,UAAU,CAACkP,UAAU,CAAC,CAAC,CAAC;;UAEnC,IAAI0D,SAAS,GAAG1I,eAAe,CAACZ,IAAI,CAACvI,MAAM,CAAC;UAC5C6C,QAAQ,CAAC/C,KAAK,IAAIqQ,SAAS,CAACO,iBAAiB;QAC/C,CAAC,CAAC;;QAGF,IAAI9B,YAAY,GAAG,CAAC;QACpB,IAAI1D,UAAU,GAAG,IAAIlI,KAAK,CAAC+G,WAAW,CAACnB,MAAM,CAAC;QAE9C,KAAK,IAAI7G,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGmJ,UAAU,CAACtC,MAAM,EAAE,EAAE7G,CAAC,EAAE;UAC1CmJ,UAAU,CAACnJ,CAAC,CAAC,GAAG,IAAIiB,KAAK,EAAE;QAC7B;QAEA,KAAK,IAAIiJ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG+B,IAAI,CAACc,KAAK,EAAE,EAAE7C,CAAC,EAAE;UACnC,KAAK,IAAI6F,IAAI,GAAG,CAAC,EAAEA,IAAI,GAAG/H,WAAW,CAACnB,MAAM,EAAE,EAAEkJ,IAAI,EAAE;YACpD5G,UAAU,CAAC4G,IAAI,CAAC,CAACpI,IAAI,CAACkF,YAAY,CAAC;YACnCA,YAAY,IAAI7E,WAAW,CAAC+H,IAAI,CAAC,CAAC3H,KAAK,GAAG6D,IAAI,CAACrO,IAAI,GAAGsB,UAAU;UAClE;QACF,CAAC,CAAC;;QAGF2I,cAAc,CAACC,MAAM,EAAEqB,UAAU,EAAEnB,WAAW,EAAEC,QAAQ,EAAEC,QAAQ,EAAE1F,SAAS,CAAC,CAAC,CAAC;;QAEhF,KAAK,IAAIxC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGgI,WAAW,CAACnB,MAAM,EAAE,EAAE7G,CAAC,EAAE;UAC3C,IAAIqN,EAAE,GAAGrF,WAAW,CAAChI,CAAC,CAAC;UACvB,IAAIqN,EAAE,CAAC9C,OAAO,EAAE;UAEhB,QAAQ8C,EAAE,CAAC6B,WAAW;YACpB,KAAK1P,GAAG;cACN,IAAI8L,GAAG,GAAG,CAAC;cACX,IAAI0E,SAAS,GAAG,CAAC;cAEjB,KAAK,IAAI9F,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG+B,IAAI,CAACc,KAAK,EAAE,EAAE7C,CAAC,EAAE;gBACnC,IAAI+F,cAAc,GAAG9G,UAAU,CAACnJ,CAAC,CAAC,CAACsL,GAAG,CAAC;gBAEvC,KAAK,IAAIjB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGgD,EAAE,CAACjF,KAAK,EAAE,EAAEiC,CAAC,EAAE;kBACjC,KAAK,IAAI6F,IAAI,GAAG,CAAC,EAAEA,IAAI,GAAGhR,UAAU,GAAGmO,EAAE,CAACzP,IAAI,EAAE,EAAEsS,IAAI,EAAE;oBACtD1N,SAAS,CAACyN,cAAc,EAAE,CAAC,GAAGH,SAAS,CAACE,SAAS,GAAGE,IAAI,GAAG7C,EAAE,CAACjF,KAAK,GAAGiF,EAAE,CAAC/E,MAAM,CAAC;kBAClF;kBAEA0H,SAAS,EAAE;gBACb;gBAEA1E,GAAG,EAAE;cACP;cAEA;YAEF,KAAK/L,SAAS,CAAC,CAAC;;YAEhB;cACE,MAAM,kDAAkD;UAAC;QAE/D;QAEA,OAAO,IAAIiI,QAAQ,CAAChF,SAAS,CAACvE,MAAM,CAAC;MACvC;MAEA,SAASqR,yBAAyBA,CAACrR,MAAM,EAAEgM,MAAM,EAAE;QACjD,IAAIkG,UAAU,GAAG,IAAIvN,UAAU,CAAC3E,MAAM,CAAC;QACvC,IAAImS,SAAS,GAAG,CAAC;QAEjB,OAAOD,UAAU,CAAClG,MAAM,CAAClM,KAAK,GAAGqS,SAAS,CAAC,IAAI,CAAC,EAAE;UAChDA,SAAS,IAAI,CAAC;QAChB;QAEA,IAAIC,WAAW,GAAG,IAAIC,WAAW,EAAE,CAACC,MAAM,CAACJ,UAAU,CAAC7D,KAAK,CAACrC,MAAM,CAAClM,KAAK,EAAEkM,MAAM,CAAClM,KAAK,GAAGqS,SAAS,CAAC,CAAC;QACpGnG,MAAM,CAAClM,KAAK,GAAGkM,MAAM,CAAClM,KAAK,GAAGqS,SAAS,GAAG,CAAC;QAC3C,OAAOC,WAAW;MACpB;MAEA,SAASG,sBAAsBA,CAACvS,MAAM,EAAEgM,MAAM,EAAE5C,IAAI,EAAE;QACpD,IAAIgJ,WAAW,GAAG,IAAIC,WAAW,EAAE,CAACC,MAAM,CAAC,IAAI3N,UAAU,CAAC3E,MAAM,CAAC,CAACqO,KAAK,CAACrC,MAAM,CAAClM,KAAK,EAAEkM,MAAM,CAAClM,KAAK,GAAGsJ,IAAI,CAAC,CAAC;QAC3G4C,MAAM,CAAClM,KAAK,GAAGkM,MAAM,CAAClM,KAAK,GAAGsJ,IAAI;QAClC,OAAOgJ,WAAW;MACpB;MAEA,SAASI,aAAaA,CAACtI,QAAQ,EAAE8B,MAAM,EAAE;QACvC,IAAII,CAAC,GAAGqG,UAAU,CAACvI,QAAQ,EAAE8B,MAAM,CAAC;QACpC,IAAIC,CAAC,GAAG7D,WAAW,CAAC8B,QAAQ,EAAE8B,MAAM,CAAC;QACrC,OAAO,CAACI,CAAC,EAAEH,CAAC,CAAC;MACf;MAEA,SAASyG,aAAaA,CAACxI,QAAQ,EAAE8B,MAAM,EAAE;QACvC,IAAII,CAAC,GAAGhE,WAAW,CAAC8B,QAAQ,EAAE8B,MAAM,CAAC;QACrC,IAAIC,CAAC,GAAG7D,WAAW,CAAC8B,QAAQ,EAAE8B,MAAM,CAAC;QACrC,OAAO,CAACI,CAAC,EAAEH,CAAC,CAAC;MACf;MAEA,SAASwG,UAAUA,CAACvI,QAAQ,EAAE8B,MAAM,EAAE;QACpC,IAAI2G,KAAK,GAAGzI,QAAQ,CAAC0I,QAAQ,CAAC5G,MAAM,CAAClM,KAAK,EAAE,IAAI,CAAC;QACjDkM,MAAM,CAAClM,KAAK,GAAGkM,MAAM,CAAClM,KAAK,GAAGkB,UAAU;QACxC,OAAO2R,KAAK;MACd;MAEA,SAASvK,WAAWA,CAAC8B,QAAQ,EAAE8B,MAAM,EAAE;QACrC,IAAI6G,MAAM,GAAG3I,QAAQ,CAAC4I,SAAS,CAAC9G,MAAM,CAAClM,KAAK,EAAE,IAAI,CAAC;QACnDkM,MAAM,CAAClM,KAAK,GAAGkM,MAAM,CAAClM,KAAK,GAAGkB,UAAU;QACxC,OAAO6R,MAAM;MACf;MAEA,SAAS/P,eAAeA,CAACF,UAAU,EAAEoJ,MAAM,EAAE;QAC3C,IAAI+G,KAAK,GAAGnQ,UAAU,CAACoJ,MAAM,CAAClM,KAAK,CAAC;QACpCkM,MAAM,CAAClM,KAAK,GAAGkM,MAAM,CAAClM,KAAK,GAAGoB,SAAS;QACvC,OAAO6R,KAAK;MACd;MAEA,SAAS7D,UAAUA,CAAChF,QAAQ,EAAE8B,MAAM,EAAE;QACpC,IAAI+G,KAAK,GAAG7I,QAAQ,CAACP,QAAQ,CAACqC,MAAM,CAAClM,KAAK,CAAC;QAC3CkM,MAAM,CAAClM,KAAK,GAAGkM,MAAM,CAAClM,KAAK,GAAGoB,SAAS;QACvC,OAAO6R,KAAK;MACd;MAEA,IAAM1C,UAAU,GAAG,SAAbA,UAAUA,CAAanG,QAAQ,EAAE8B,MAAM,EAAE;QAC7C,IAAIgH,GAAG;QAEP,IAAI,aAAa,IAAIzJ,QAAQ,CAAC0J,SAAS,EAAE;UACvCD,GAAG,GAAGE,MAAM,CAAChJ,QAAQ,CAACiJ,WAAW,CAACnH,MAAM,CAAClM,KAAK,EAAE,IAAI,CAAC,CAAC;QACxD,CAAC,MAAM;UACLkT,GAAG,GAAG9I,QAAQ,CAAC4I,SAAS,CAAC9G,MAAM,CAAClM,KAAK,GAAG,CAAC,EAAE,IAAI,CAAC,GAAGoT,MAAM,CAAChJ,QAAQ,CAAC4I,SAAS,CAAC9G,MAAM,CAAClM,KAAK,EAAE,IAAI,CAAC,IAAI,EAAE,CAAC;QACzG;QAEAkM,MAAM,CAAClM,KAAK,IAAIgB,UAAU;QAC1B,OAAOkS,GAAG;MACZ,CAAC;MAED,SAASI,YAAYA,CAAClJ,QAAQ,EAAE8B,MAAM,EAAE;QACtC,IAAI4B,KAAK,GAAG1D,QAAQ,CAACmJ,UAAU,CAACrH,MAAM,CAAClM,KAAK,EAAE,IAAI,CAAC;QACnDkM,MAAM,CAAClM,KAAK,IAAIiB,YAAY;QAC5B,OAAO6M,KAAK;MACd;MAEA,SAAS0F,aAAaA,CAACpJ,QAAQ,EAAE8B,MAAM,EAAE;QACvC,OAAOhN,SAAS,CAAC0O,WAAW,CAAC0F,YAAY,CAAClJ,QAAQ,EAAE8B,MAAM,CAAC,CAAC;MAC9D,CAAC,CAAC;;MAGF,SAASS,aAAaA,CAAC8G,MAAM,EAAE;QAC7B,IAAIC,QAAQ,GAAG,CAACD,MAAM,GAAG,MAAM,KAAK,EAAE;UAClCE,QAAQ,GAAGF,MAAM,GAAG,MAAM;QAC9B,OAAO,CAACA,MAAM,IAAI,EAAE,GAAG,CAAC,CAAC,GAAG,CAAC,KAAKC,QAAQ,GAAGA,QAAQ,KAAK,IAAI,GAAGC,QAAQ,GAAGC,GAAG,GAAGC,QAAQ,GAAGlS,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE8R,QAAQ,GAAG,EAAE,CAAC,IAAI,CAAC,GAAGC,QAAQ,GAAG,KAAK,CAAC,GAAG,cAAc,IAAIA,QAAQ,GAAG,KAAK,CAAC,CAAC;MACzL;MAEA,SAASzE,WAAWA,CAAC9E,QAAQ,EAAE8B,MAAM,EAAE;QACrC,IAAI4H,MAAM,GAAG1J,QAAQ,CAACqC,SAAS,CAACP,MAAM,CAAClM,KAAK,EAAE,IAAI,CAAC;QACnDkM,MAAM,CAAClM,KAAK,IAAImB,UAAU;QAC1B,OAAO2S,MAAM;MACf;MAEA,SAASC,YAAYA,CAAC7T,MAAM,EAAEgM,MAAM,EAAE;QACpC,OAAOS,aAAa,CAACuC,WAAW,CAAChP,MAAM,EAAEgM,MAAM,CAAC,CAAC;MACnD;MAEA,SAAS8H,WAAWA,CAAC5J,QAAQ,EAAElK,MAAM,EAAEgM,MAAM,EAAE5C,IAAI,EAAE;QACnD,IAAI2K,WAAW,GAAG/H,MAAM,CAAClM,KAAK;QAC9B,IAAI6O,QAAQ,GAAG,EAAE;QAEjB,OAAO3C,MAAM,CAAClM,KAAK,GAAGiU,WAAW,GAAG3K,IAAI,GAAG,CAAC,EAAE;UAC5C,IAAIgI,IAAI,GAAGC,yBAAyB,CAACrR,MAAM,EAAEgM,MAAM,CAAC;UACpD,IAAIyF,SAAS,GAAGgB,UAAU,CAACvI,QAAQ,EAAE8B,MAAM,CAAC;UAC5C,IAAI0F,OAAO,GAAGxC,UAAU,CAAChF,QAAQ,EAAE8B,MAAM,CAAC;UAC1CA,MAAM,CAAClM,KAAK,IAAI,CAAC,CAAC,CAAC;;UAEnB,IAAIkU,SAAS,GAAGvB,UAAU,CAACvI,QAAQ,EAAE8B,MAAM,CAAC;UAC5C,IAAIiI,SAAS,GAAGxB,UAAU,CAACvI,QAAQ,EAAE8B,MAAM,CAAC;UAC5C2C,QAAQ,CAACjF,IAAI,CAAC;YACZ0H,IAAI,EAAEA,IAAI;YACVK,SAAS,EAAEA,SAAS;YACpBC,OAAO,EAAEA,OAAO;YAChBsC,SAAS,EAAEA,SAAS;YACpBC,SAAS,EAAEA;UACb,CAAC,CAAC;QACJ;QAEAjI,MAAM,CAAClM,KAAK,IAAI,CAAC;QACjB,OAAO6O,QAAQ;MACjB;MAEA,SAASuF,mBAAmBA,CAAChK,QAAQ,EAAE8B,MAAM,EAAE;QAC7C,IAAImI,IAAI,GAAGf,YAAY,CAAClJ,QAAQ,EAAE8B,MAAM,CAAC;QACzC,IAAIoI,IAAI,GAAGhB,YAAY,CAAClJ,QAAQ,EAAE8B,MAAM,CAAC;QACzC,IAAIqI,MAAM,GAAGjB,YAAY,CAAClJ,QAAQ,EAAE8B,MAAM,CAAC;QAC3C,IAAIsI,MAAM,GAAGlB,YAAY,CAAClJ,QAAQ,EAAE8B,MAAM,CAAC;QAC3C,IAAIuI,KAAK,GAAGnB,YAAY,CAAClJ,QAAQ,EAAE8B,MAAM,CAAC;QAC1C,IAAIwI,KAAK,GAAGpB,YAAY,CAAClJ,QAAQ,EAAE8B,MAAM,CAAC;QAC1C,IAAIyI,MAAM,GAAGrB,YAAY,CAAClJ,QAAQ,EAAE8B,MAAM,CAAC;QAC3C,IAAI0I,MAAM,GAAGtB,YAAY,CAAClJ,QAAQ,EAAE8B,MAAM,CAAC;QAC3C,OAAO;UACLmI,IAAI,EAAEA,IAAI;UACVC,IAAI,EAAEA,IAAI;UACVC,MAAM,EAAEA,MAAM;UACdC,MAAM,EAAEA,MAAM;UACdC,KAAK,EAAEA,KAAK;UACZC,KAAK,EAAEA,KAAK;UACZC,MAAM,EAAEA,MAAM;UACdC,MAAM,EAAEA;QACV,CAAC;MACH;MAEA,SAASC,gBAAgBA,CAACzK,QAAQ,EAAE8B,MAAM,EAAE;QAC1C,IAAI4I,gBAAgB,GAAG,CAAC,gBAAgB,EAAE,iBAAiB,EAAE,kBAAkB,EAAE,iBAAiB,EAAE,iBAAiB,EAAE,mBAAmB,EAAE,iBAAiB,EAAE,kBAAkB,EAAE,kBAAkB,EAAE,kBAAkB,CAAC;QAC1N,IAAI3D,WAAW,GAAG/B,UAAU,CAAChF,QAAQ,EAAE8B,MAAM,CAAC;QAC9C,OAAO4I,gBAAgB,CAAC3D,WAAW,CAAC;MACtC;MAEA,SAAS4D,UAAUA,CAAC3K,QAAQ,EAAE8B,MAAM,EAAE;QACpC,IAAI8I,IAAI,GAAG1M,WAAW,CAAC8B,QAAQ,EAAE8B,MAAM,CAAC;QACxC,IAAI+I,IAAI,GAAG3M,WAAW,CAAC8B,QAAQ,EAAE8B,MAAM,CAAC;QACxC,IAAIgJ,IAAI,GAAG5M,WAAW,CAAC8B,QAAQ,EAAE8B,MAAM,CAAC;QACxC,IAAIiJ,IAAI,GAAG7M,WAAW,CAAC8B,QAAQ,EAAE8B,MAAM,CAAC;QACxC,OAAO;UACL8I,IAAI,EAAEA,IAAI;UACVC,IAAI,EAAEA,IAAI;UACVC,IAAI,EAAEA,IAAI;UACVC,IAAI,EAAEA;QACR,CAAC;MACH;MAEA,SAASC,cAAcA,CAAChL,QAAQ,EAAE8B,MAAM,EAAE;QACxC,IAAImJ,UAAU,GAAG,CAAC,cAAc,CAAC;QACjC,IAAIC,SAAS,GAAGlG,UAAU,CAAChF,QAAQ,EAAE8B,MAAM,CAAC;QAC5C,OAAOmJ,UAAU,CAACC,SAAS,CAAC;MAC9B;MAEA,SAASC,QAAQA,CAACnL,QAAQ,EAAE8B,MAAM,EAAE;QAClC,IAAII,CAAC,GAAGgH,YAAY,CAAClJ,QAAQ,EAAE8B,MAAM,CAAC;QACtC,IAAIC,CAAC,GAAGmH,YAAY,CAAClJ,QAAQ,EAAE8B,MAAM,CAAC;QACtC,OAAO,CAACI,CAAC,EAAEH,CAAC,CAAC;MACf;MAEA,SAASqJ,QAAQA,CAACpL,QAAQ,EAAE8B,MAAM,EAAE;QAClC,IAAII,CAAC,GAAGgH,YAAY,CAAClJ,QAAQ,EAAE8B,MAAM,CAAC;QACtC,IAAIC,CAAC,GAAGmH,YAAY,CAAClJ,QAAQ,EAAE8B,MAAM,CAAC;QACtC,IAAIuJ,CAAC,GAAGnC,YAAY,CAAClJ,QAAQ,EAAE8B,MAAM,CAAC;QACtC,OAAO,CAACI,CAAC,EAAEH,CAAC,EAAEsJ,CAAC,CAAC;MAClB;MAEA,SAASC,UAAUA,CAACtL,QAAQ,EAAElK,MAAM,EAAEgM,MAAM,EAAErM,IAAI,EAAEyJ,IAAI,EAAE;QACxD,IAAIzJ,IAAI,KAAK,QAAQ,IAAIA,IAAI,KAAK,cAAc,IAAIA,IAAI,KAAK,YAAY,EAAE;UACzE,OAAO4S,sBAAsB,CAACvS,MAAM,EAAEgM,MAAM,EAAE5C,IAAI,CAAC;QACrD,CAAC,MAAM,IAAIzJ,IAAI,KAAK,QAAQ,EAAE;UAC5B,OAAOmU,WAAW,CAAC5J,QAAQ,EAAElK,MAAM,EAAEgM,MAAM,EAAE5C,IAAI,CAAC;QACpD,CAAC,MAAM,IAAIzJ,IAAI,KAAK,gBAAgB,EAAE;UACpC,OAAOuU,mBAAmB,CAAChK,QAAQ,EAAE8B,MAAM,CAAC;QAC9C,CAAC,MAAM,IAAIrM,IAAI,KAAK,aAAa,EAAE;UACjC,OAAOgV,gBAAgB,CAACzK,QAAQ,EAAE8B,MAAM,CAAC;QAC3C,CAAC,MAAM,IAAIrM,IAAI,KAAK,OAAO,EAAE;UAC3B,OAAOkV,UAAU,CAAC3K,QAAQ,EAAE8B,MAAM,CAAC;QACrC,CAAC,MAAM,IAAIrM,IAAI,KAAK,WAAW,EAAE;UAC/B,OAAOuV,cAAc,CAAChL,QAAQ,EAAE8B,MAAM,CAAC;QACzC,CAAC,MAAM,IAAIrM,IAAI,KAAK,OAAO,EAAE;UAC3B,OAAOyT,YAAY,CAAClJ,QAAQ,EAAE8B,MAAM,CAAC;QACvC,CAAC,MAAM,IAAIrM,IAAI,KAAK,KAAK,EAAE;UACzB,OAAO0V,QAAQ,CAACnL,QAAQ,EAAE8B,MAAM,CAAC;QACnC,CAAC,MAAM,IAAIrM,IAAI,KAAK,KAAK,EAAE;UACzB,OAAO2V,QAAQ,CAACpL,QAAQ,EAAE8B,MAAM,CAAC;QACnC,CAAC,MAAM,IAAIrM,IAAI,KAAK,KAAK,EAAE;UACzB,OAAO8S,UAAU,CAACvI,QAAQ,EAAE8B,MAAM,CAAC;QACrC,CAAC,MAAM,IAAIrM,IAAI,KAAK,UAAU,EAAE;UAC9B,OAAO6S,aAAa,CAACtI,QAAQ,EAAE8B,MAAM,CAAC;QACxC,CAAC,MAAM,IAAIrM,IAAI,KAAK,UAAU,EAAE;UAC9B,OAAO+S,aAAa,CAACxI,QAAQ,EAAE8B,MAAM,CAAC;QACxC,CAAC,MAAM,IAAIrM,IAAI,KAAK,SAAS,EAAE;UAC7BqM,MAAM,CAAClM,KAAK,IAAIsJ,IAAI;UACpB,OAAO,SAAS;QAClB,CAAC,MAAM;UACL4C,MAAM,CAAClM,KAAK,IAAIsJ,IAAI;UACpB,OAAOqM,SAAS;QAClB;MACF;MAEA,SAASC,WAAWA,CAACxL,QAAQ,EAAElK,MAAM,EAAEgM,MAAM,EAAE;QAC7C,IAAMgF,SAAS,GAAG,CAAC,CAAC;QAEpB,IAAI9G,QAAQ,CAAC4I,SAAS,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,QAAQ,EAAE;UAC3C;UACA,MAAM,wEAAwE;QAChF;QAEA9B,SAAS,CAACZ,OAAO,GAAGlG,QAAQ,CAACP,QAAQ,CAAC,CAAC,CAAC;QACxC,IAAMgM,IAAI,GAAGzL,QAAQ,CAACP,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;;QAEnCqH,SAAS,CAAC2E,IAAI,GAAG;UACfC,UAAU,EAAE,CAAC,EAAED,IAAI,GAAG,CAAC,CAAC;UACxBE,QAAQ,EAAE,CAAC,EAAEF,IAAI,GAAG,CAAC,CAAC;UACtBG,UAAU,EAAE,CAAC,EAAEH,IAAI,GAAG,CAAC,CAAC;UACxBI,SAAS,EAAE,CAAC,EAAEJ,IAAI,GAAG,EAAE;QACzB,CAAC,CAAC,CAAC;;QAEH3J,MAAM,CAAClM,KAAK,GAAG,CAAC,CAAC,CAAC;;QAElB,IAAIkW,WAAW,GAAG,IAAI;QAEtB,OAAOA,WAAW,EAAE;UAClB,IAAIC,aAAa,GAAG5E,yBAAyB,CAACrR,MAAM,EAAEgM,MAAM,CAAC;UAE7D,IAAIiK,aAAa,IAAI,CAAC,EAAE;YACtBD,WAAW,GAAG,KAAK;UACrB,CAAC,MAAM;YACL,IAAIE,aAAa,GAAG7E,yBAAyB,CAACrR,MAAM,EAAEgM,MAAM,CAAC;YAC7D,IAAImK,aAAa,GAAG/N,WAAW,CAAC8B,QAAQ,EAAE8B,MAAM,CAAC;YACjD,IAAIoK,cAAc,GAAGZ,UAAU,CAACtL,QAAQ,EAAElK,MAAM,EAAEgM,MAAM,EAAEkK,aAAa,EAAEC,aAAa,CAAC;YAEvF,IAAIC,cAAc,KAAKX,SAAS,EAAE;cAChCY,OAAO,CAACC,IAAI,4DAAAC,MAAA,CAA6DL,aAAa,QAAM;YAC9F,CAAC,MAAM;cACLlF,SAAS,CAACiF,aAAa,CAAC,GAAGG,cAAc;YAC3C;UACF;QACF;QAEA,IAAIT,IAAI,IAAI,CAAC,EAAE;UACbU,OAAO,CAACG,KAAK,CAAC,YAAY,EAAExF,SAAS,CAAC;UACtC,MAAM,0DAA0D;QAClE;QAEA,OAAOA,SAAS;MAClB;MAEA,SAASyF,YAAYA,CAACzF,SAAS,EAAE9G,QAAQ,EAAEtH,UAAU,EAAEoJ,MAAM,EAAE0K,UAAU,EAAE;QACzE,IAAMC,UAAU,GAAG;UACjBvN,IAAI,EAAE,CAAC;UACPgF,MAAM,EAAElE,QAAQ;UAChB+D,KAAK,EAAErL,UAAU;UACjBoJ,MAAM,EAAEA,MAAM;UACd7B,KAAK,EAAE6G,SAAS,CAAC4F,UAAU,CAAC5B,IAAI,GAAGhE,SAAS,CAAC4F,UAAU,CAAC9B,IAAI,GAAG,CAAC;UAChEzK,MAAM,EAAE2G,SAAS,CAAC4F,UAAU,CAAC3B,IAAI,GAAGjE,SAAS,CAAC4F,UAAU,CAAC7B,IAAI,GAAG,CAAC;UACjEpG,QAAQ,EAAEqC,SAAS,CAACrC,QAAQ,CAAC/F,MAAM;UACnCiO,YAAY,EAAE,IAAI;UAClB/H,KAAK,EAAE,IAAI;UACXgI,SAAS,EAAE,IAAI;UACfnX,IAAI,EAAEqR,SAAS,CAACrC,QAAQ,CAAC,CAAC,CAAC,CAAC8C,SAAS;UACrCsF,UAAU,EAAE,IAAI;UAChBC,MAAM,EAAE,IAAI;UACZC,MAAM,EAAE,IAAI;UACZC,QAAQ,EAAE;QACZ,CAAC;QAED,QAAQlG,SAAS,CAACC,WAAW;UAC3B,KAAK,gBAAgB;YACnB0F,UAAU,CAAC7H,KAAK,GAAG,CAAC;YACpB6H,UAAU,CAACI,UAAU,GAAGhJ,aAAa;YACrC;UAEF,KAAK,iBAAiB;YACpB4I,UAAU,CAAC7H,KAAK,GAAG,CAAC;YACpB6H,UAAU,CAACI,UAAU,GAAG7I,aAAa;YACrC;UAEF,KAAK,kBAAkB;YACrByI,UAAU,CAAC7H,KAAK,GAAG,CAAC;YACpB6H,UAAU,CAACI,UAAU,GAAGvI,aAAa;YACrC;UAEF,KAAK,iBAAiB;YACpBmI,UAAU,CAAC7H,KAAK,GAAG,EAAE;YACrB6H,UAAU,CAACI,UAAU,GAAGvI,aAAa;YACrC;UAEF,KAAK,iBAAiB;YACpBmI,UAAU,CAAC7H,KAAK,GAAG,EAAE;YACrB6H,UAAU,CAACI,UAAU,GAAGtI,aAAa;YACrC;UAEF,KAAK,mBAAmB;YACtBkI,UAAU,CAAC7H,KAAK,GAAG,EAAE;YACrB6H,UAAU,CAACI,UAAU,GAAGrH,aAAa;YACrC;UAEF,KAAK,kBAAkB;YACrBiH,UAAU,CAAC7H,KAAK,GAAG,EAAE;YACrB6H,UAAU,CAACI,UAAU,GAAG7G,aAAa;YACrC;UAEF,KAAK,kBAAkB;YACrByG,UAAU,CAAC7H,KAAK,GAAG,GAAG;YACtB6H,UAAU,CAACI,UAAU,GAAG7G,aAAa;YACrC;UAEF;YACE,MAAM,mBAAmB,GAAGc,SAAS,CAACC,WAAW,GAAG,iBAAiB;QAAC;QAG1E0F,UAAU,CAACjI,iBAAiB,GAAGiI,UAAU,CAAC7H,KAAK;QAE/C,IAAI6H,UAAU,CAAChX,IAAI,IAAI,CAAC,EAAE;UACxB;UACA,QAAQ+W,UAAU;YAChB,KAAK/X,SAAS;cACZgY,UAAU,CAACK,MAAM,GAAGnD,YAAY;cAChC8C,UAAU,CAACG,SAAS,GAAG7V,UAAU;cACjC;YAEF,KAAKvC,aAAa;cAChBiY,UAAU,CAACK,MAAM,GAAGhI,WAAW;cAC/B2H,UAAU,CAACG,SAAS,GAAG7V,UAAU;cACjC;UAAM;QAEZ,CAAC,MAAM,IAAI0V,UAAU,CAAChX,IAAI,IAAI,CAAC,EAAE;UAC/B;UACA,QAAQ+W,UAAU;YAChB,KAAK/X,SAAS;cACZgY,UAAU,CAACK,MAAM,GAAG5D,YAAY;cAChCuD,UAAU,CAACG,SAAS,GAAG/V,YAAY;cACnC;YAEF,KAAKrC,aAAa;cAChBiY,UAAU,CAACK,MAAM,GAAG1D,aAAa;cACjCqD,UAAU,CAACG,SAAS,GAAG/V,YAAY;UAAC;QAE1C,CAAC,MAAM;UACL,MAAM,yCAAyC,GAAG4V,UAAU,CAAChX,IAAI,GAAG,OAAO,GAAGqR,SAAS,CAACC,WAAW,GAAG,GAAG;QAC3G;QAEA0F,UAAU,CAACQ,UAAU,GAAG,CAACnG,SAAS,CAAC4F,UAAU,CAAC3B,IAAI,GAAG,CAAC,IAAI0B,UAAU,CAACjI,iBAAiB;QAEtF,KAAK,IAAI3M,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG4U,UAAU,CAACQ,UAAU,EAAEpV,CAAC,EAAE,EAAEsO,UAAU,CAACnG,QAAQ,EAAE8B,MAAM,CAAC,CAAC,CAAC;QAC9E;QACA;;QAGA2K,UAAU,CAACS,cAAc,GAAGT,UAAU,CAAChI,QAAQ,IAAI,CAAC,GAAG,CAAC,GAAGgI,UAAU,CAAChI,QAAQ;QAC9E,IAAMvF,IAAI,GAAGuN,UAAU,CAACxM,KAAK,GAAGwM,UAAU,CAACtM,MAAM,GAAGsM,UAAU,CAACS,cAAc;QAE7E,QAAQV,UAAU;UAChB,KAAK/X,SAAS;YACZgY,UAAU,CAACU,SAAS,GAAG,IAAIjM,YAAY,CAAChC,IAAI,CAAC,CAAC,CAAC;;YAE/C,IAAIuN,UAAU,CAAChI,QAAQ,GAAGgI,UAAU,CAACS,cAAc,EAAET,UAAU,CAACU,SAAS,CAAC3L,IAAI,CAAC,CAAC,EAAE,CAAC,EAAEtC,IAAI,CAAC;YAC1F;UAEF,KAAK1K,aAAa;YAChBiY,UAAU,CAACU,SAAS,GAAG,IAAIhM,WAAW,CAACjC,IAAI,CAAC;YAC5C,IAAIuN,UAAU,CAAChI,QAAQ,GAAGgI,UAAU,CAACS,cAAc,EAAET,UAAU,CAACU,SAAS,CAAC3L,IAAI,CAAC,MAAM,EAAE,CAAC,EAAEtC,IAAI,CAAC,CAAC,CAAC;;YAEjG;UAEF;YACEiN,OAAO,CAACG,KAAK,CAAC,qCAAqC,EAAEE,UAAU,CAAC;YAChE;QAAM;QAGVC,UAAU,CAACE,YAAY,GAAGF,UAAU,CAACxM,KAAK,GAAGwM,UAAU,CAACG,SAAS,GAAGH,UAAU,CAAChI,QAAQ;QAEvF,IAAIgI,UAAU,CAACS,cAAc,IAAI,CAAC,EAAE;UAClCT,UAAU,CAACM,MAAM,GAAGrY,UAAU;UAC9B+X,UAAU,CAACO,QAAQ,GAAGrY,cAAc;QACtC,CAAC,MAAM;UACL8X,UAAU,CAACM,MAAM,GAAGnY,SAAS;UAC7B6X,UAAU,CAACO,QAAQ,GAAGrY,cAAc;QACtC;QAEA,OAAO8X,UAAU;MACnB,CAAC,CAAC;;MAGF,IAAMW,cAAc,GAAG,IAAI/N,QAAQ,CAACvJ,MAAM,CAAC;MAC3C,IAAM4C,UAAU,GAAG,IAAI+B,UAAU,CAAC3E,MAAM,CAAC;MACzC,IAAMgM,MAAM,GAAG;QACblM,KAAK,EAAE;MACT,CAAC,CAAC,CAAC;;MAEH,IAAMkR,SAAS,GAAG0E,WAAW,CAAC4B,cAAc,EAAEtX,MAAM,EAAEgM,MAAM,CAAC,CAAC,CAAC;;MAE/D,IAAM2K,UAAU,GAAGF,YAAY,CAACzF,SAAS,EAAEsG,cAAc,EAAE1U,UAAU,EAAEoJ,MAAM,EAAE,IAAI,CAACrM,IAAI,CAAC;MACzF,IAAM2P,SAAS,GAAG;QAChBxP,KAAK,EAAE;MACT,CAAC;MACD,IAAMyX,cAAc,GAAG;QACrBC,CAAC,EAAE,CAAC;QACJC,CAAC,EAAE,CAAC;QACJC,CAAC,EAAE,CAAC;QACJC,CAAC,EAAE,CAAC;QACJC,CAAC,EAAE;MACL,CAAC;MAED,KAAK,IAAIC,gBAAgB,GAAG,CAAC,EAAEA,gBAAgB,GAAGlB,UAAU,CAACtM,MAAM,GAAGsM,UAAU,CAACjI,iBAAiB,EAAEmJ,gBAAgB,EAAE,EAAE;QACtH,IAAMC,IAAI,GAAG1P,WAAW,CAACkP,cAAc,EAAEtL,MAAM,CAAC,CAAC,CAAC;;QAElD2K,UAAU,CAACvN,IAAI,GAAGhB,WAAW,CAACkP,cAAc,EAAEtL,MAAM,CAAC,CAAC,CAAC;;QAEvD2K,UAAU,CAAC7H,KAAK,GAAGgJ,IAAI,GAAGnB,UAAU,CAACjI,iBAAiB,GAAGiI,UAAU,CAACtM,MAAM,GAAGsM,UAAU,CAACtM,MAAM,GAAGyN,IAAI,GAAGnB,UAAU,CAACjI,iBAAiB;QACpI,IAAMqJ,YAAY,GAAGpB,UAAU,CAACvN,IAAI,GAAGuN,UAAU,CAAC7H,KAAK,GAAG6H,UAAU,CAACE,YAAY;QACjF,IAAMzI,MAAM,GAAG2J,YAAY,GAAGpB,UAAU,CAACI,UAAU,CAACJ,UAAU,CAAC,GAAG5I,aAAa,CAAC4I,UAAU,CAAC;QAC3F3K,MAAM,CAAClM,KAAK,IAAI6W,UAAU,CAACvN,IAAI;QAE/B,KAAK,IAAI4O,MAAM,GAAG,CAAC,EAAEA,MAAM,GAAGrB,UAAU,CAACjI,iBAAiB,EAAEsJ,MAAM,EAAE,EAAE;UACpE,IAAMC,MAAM,GAAGD,MAAM,GAAGH,gBAAgB,GAAGlB,UAAU,CAACjI,iBAAiB;UACvE,IAAIuJ,MAAM,IAAItB,UAAU,CAACtM,MAAM,EAAE;UAEjC,KAAK,IAAI6N,SAAS,GAAG,CAAC,EAAEA,SAAS,GAAGvB,UAAU,CAAChI,QAAQ,EAAEuJ,SAAS,EAAE,EAAE;YACpE,IAAMC,IAAI,GAAGZ,cAAc,CAACvG,SAAS,CAACrC,QAAQ,CAACuJ,SAAS,CAAC,CAAC9G,IAAI,CAAC;YAE/D,KAAK,IAAIhF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGuK,UAAU,CAACxM,KAAK,EAAEiC,CAAC,EAAE,EAAE;cACzCkD,SAAS,CAACxP,KAAK,GAAG,CAACkY,MAAM,IAAIrB,UAAU,CAAChI,QAAQ,GAAGgI,UAAU,CAACxM,KAAK,CAAC,GAAG+N,SAAS,GAAGvB,UAAU,CAACxM,KAAK,GAAGiC,CAAC,IAAIuK,UAAU,CAACG,SAAS;cAC/H,IAAMsB,QAAQ,GAAG,CAACzB,UAAU,CAACtM,MAAM,GAAG,CAAC,GAAG4N,MAAM,KAAKtB,UAAU,CAACxM,KAAK,GAAGwM,UAAU,CAACS,cAAc,CAAC,GAAGhL,CAAC,GAAGuK,UAAU,CAACS,cAAc,GAAGe,IAAI;cACzIxB,UAAU,CAACU,SAAS,CAACe,QAAQ,CAAC,GAAGzB,UAAU,CAACK,MAAM,CAAC5I,MAAM,EAAEkB,SAAS,CAAC;YACvE;UACF;QACF;MACF;MAEA,OAAO;QACL+I,MAAM,EAAErH,SAAS;QACjB7G,KAAK,EAAEwM,UAAU,CAACxM,KAAK;QACvBE,MAAM,EAAEsM,UAAU,CAACtM,MAAM;QACzB9B,IAAI,EAAEoO,UAAU,CAACU,SAAS;QAC1BJ,MAAM,EAAEN,UAAU,CAACM,MAAM;QACzBC,QAAQ,EAAEP,UAAU,CAACO,QAAQ;QAC7BvX,IAAI,EAAE,IAAI,CAACA;MACb,CAAC;IACH;EAAC;IAAAE,GAAA;IAAAC,KAAA,EAED,SAAAwY,YAAYxY,KAAK,EAAE;MACjB,IAAI,CAACH,IAAI,GAAGG,KAAK;MACjB,OAAO,IAAI;IACb;EAAC;IAAAD,GAAA;IAAAC,KAAA,EAED,SAAAyY,KAAKC,GAAG,EAAEC,MAAM,EAAEC,UAAU,EAAEC,OAAO,EAAE;MACrC,SAASC,cAAcA,CAACC,OAAO,EAAEC,OAAO,EAAE;QACxCD,OAAO,CAAC3B,QAAQ,GAAG4B,OAAO,CAAC5B,QAAQ;QACnC2B,OAAO,CAACE,SAAS,GAAGha,YAAY;QAChC8Z,OAAO,CAACG,SAAS,GAAGja,YAAY;QAChC8Z,OAAO,CAACI,eAAe,GAAG,KAAK;QAC/BJ,OAAO,CAACK,KAAK,GAAG,KAAK;QACrB,IAAIT,MAAM,EAAEA,MAAM,CAACI,OAAO,EAAEC,OAAO,CAAC;MACtC;MAEA,OAAAK,IAAA,CAAAC,eAAA,CAAAla,SAAA,CAAA+T,SAAA,iBAAAvT,IAAA,OAAkB8Y,GAAG,EAAEI,cAAc,EAAEF,UAAU,EAAEC,OAAO;IAC5D;EAAC;EAAA,OAAAzZ,SAAA;AAAA,EAxlDqBT,iBAAiB;AA4lDzC,SAASS,SAAS"},"metadata":{},"sourceType":"module","externalDependencies":[]}