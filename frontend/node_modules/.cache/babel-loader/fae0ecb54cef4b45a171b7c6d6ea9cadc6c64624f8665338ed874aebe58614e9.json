{"ast":null,"code":"import _classCallCheck from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Loader, LoaderUtils, FileLoader, Vector3, Quaternion, Matrix4, MeshBasicMaterial, Scene, TextureLoader, Euler, MathUtils, AnimationClip, VectorKeyframeTrack, QuaternionKeyframeTrack, MeshLambertMaterial, MeshPhongMaterial, Vector2, DoubleSide, FrontSide, PerspectiveCamera, OrthographicCamera, Color, AmbientLight, SpotLight, PointLight, DirectionalLight, BufferGeometry, Float32BufferAttribute, Skeleton, Bone, Group, LineBasicMaterial, SkinnedMesh, Mesh, Line, LineSegments, RepeatWrapping, ClampToEdgeWrapping } from 'three';\nimport { TGALoader } from './TGALoader.js';\nvar ColladaLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(ColladaLoader, _Loader);\n  var _super = _createSuper(ColladaLoader);\n  function ColladaLoader(manager) {\n    _classCallCheck(this, ColladaLoader);\n    return _super.call(this, manager);\n  }\n  _createClass(ColladaLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var path = scope.path === '' ? LoaderUtils.extractUrlBase(url) : scope.path;\n      var loader = new FileLoader(scope.manager);\n      loader.setPath(scope.path);\n      loader.setRequestHeader(scope.requestHeader);\n      loader.setWithCredentials(scope.withCredentials);\n      loader.load(url, function (text) {\n        try {\n          onLoad(scope.parse(text, path));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(text, path) {\n      function getElementsByTagName(xml, name) {\n        // Non recursive xml.getElementsByTagName() ...\n        var array = [];\n        var childNodes = xml.childNodes;\n        for (var i = 0, l = childNodes.length; i < l; i++) {\n          var child = childNodes[i];\n          if (child.nodeName === name) {\n            array.push(child);\n          }\n        }\n        return array;\n      }\n      function parseStrings(text) {\n        if (text.length === 0) return [];\n        var parts = text.trim().split(/\\s+/);\n        var array = new Array(parts.length);\n        for (var i = 0, l = parts.length; i < l; i++) {\n          array[i] = parts[i];\n        }\n        return array;\n      }\n      function parseFloats(text) {\n        if (text.length === 0) return [];\n        var parts = text.trim().split(/\\s+/);\n        var array = new Array(parts.length);\n        for (var i = 0, l = parts.length; i < l; i++) {\n          array[i] = parseFloat(parts[i]);\n        }\n        return array;\n      }\n      function parseInts(text) {\n        if (text.length === 0) return [];\n        var parts = text.trim().split(/\\s+/);\n        var array = new Array(parts.length);\n        for (var i = 0, l = parts.length; i < l; i++) {\n          array[i] = parseInt(parts[i]);\n        }\n        return array;\n      }\n      function parseId(text) {\n        return text.substring(1);\n      }\n      function generateId() {\n        return 'three_default_' + count++;\n      }\n      function isEmpty(object) {\n        return Object.keys(object).length === 0;\n      } // asset\n\n      function parseAsset(xml) {\n        return {\n          unit: parseAssetUnit(getElementsByTagName(xml, 'unit')[0]),\n          upAxis: parseAssetUpAxis(getElementsByTagName(xml, 'up_axis')[0])\n        };\n      }\n      function parseAssetUnit(xml) {\n        if (xml !== undefined && xml.hasAttribute('meter') === true) {\n          return parseFloat(xml.getAttribute('meter'));\n        } else {\n          return 1; // default 1 meter\n        }\n      }\n\n      function parseAssetUpAxis(xml) {\n        return xml !== undefined ? xml.textContent : 'Y_UP';\n      } // library\n\n      function parseLibrary(xml, libraryName, nodeName, parser) {\n        var library = getElementsByTagName(xml, libraryName)[0];\n        if (library !== undefined) {\n          var elements = getElementsByTagName(library, nodeName);\n          for (var i = 0; i < elements.length; i++) {\n            parser(elements[i]);\n          }\n        }\n      }\n      function buildLibrary(data, builder) {\n        for (var name in data) {\n          var object = data[name];\n          object.build = builder(data[name]);\n        }\n      } // get\n\n      function getBuild(data, builder) {\n        if (data.build !== undefined) return data.build;\n        data.build = builder(data);\n        return data.build;\n      } // animation\n\n      function parseAnimation(xml) {\n        var data = {\n          sources: {},\n          samplers: {},\n          channels: {}\n        };\n        var hasChildren = false;\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          var id = void 0;\n          switch (child.nodeName) {\n            case 'source':\n              id = child.getAttribute('id');\n              data.sources[id] = parseSource(child);\n              break;\n            case 'sampler':\n              id = child.getAttribute('id');\n              data.samplers[id] = parseAnimationSampler(child);\n              break;\n            case 'channel':\n              id = child.getAttribute('target');\n              data.channels[id] = parseAnimationChannel(child);\n              break;\n            case 'animation':\n              // hierarchy of related animations\n              parseAnimation(child);\n              hasChildren = true;\n              break;\n            default:\n              console.log(child);\n          }\n        }\n        if (hasChildren === false) {\n          // since 'id' attributes can be optional, it's necessary to generate a UUID for unqiue assignment\n          library.animations[xml.getAttribute('id') || MathUtils.generateUUID()] = data;\n        }\n      }\n      function parseAnimationSampler(xml) {\n        var data = {\n          inputs: {}\n        };\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'input':\n              var id = parseId(child.getAttribute('source'));\n              var semantic = child.getAttribute('semantic');\n              data.inputs[semantic] = id;\n              break;\n          }\n        }\n        return data;\n      }\n      function parseAnimationChannel(xml) {\n        var data = {};\n        var target = xml.getAttribute('target'); // parsing SID Addressing Syntax\n\n        var parts = target.split('/');\n        var id = parts.shift();\n        var sid = parts.shift(); // check selection syntax\n\n        var arraySyntax = sid.indexOf('(') !== -1;\n        var memberSyntax = sid.indexOf('.') !== -1;\n        if (memberSyntax) {\n          //  member selection access\n          parts = sid.split('.');\n          sid = parts.shift();\n          data.member = parts.shift();\n        } else if (arraySyntax) {\n          // array-access syntax. can be used to express fields in one-dimensional vectors or two-dimensional matrices.\n          var indices = sid.split('(');\n          sid = indices.shift();\n          for (var i = 0; i < indices.length; i++) {\n            indices[i] = parseInt(indices[i].replace(/\\)/, ''));\n          }\n          data.indices = indices;\n        }\n        data.id = id;\n        data.sid = sid;\n        data.arraySyntax = arraySyntax;\n        data.memberSyntax = memberSyntax;\n        data.sampler = parseId(xml.getAttribute('source'));\n        return data;\n      }\n      function buildAnimation(data) {\n        var tracks = [];\n        var channels = data.channels;\n        var samplers = data.samplers;\n        var sources = data.sources;\n        for (var target in channels) {\n          if (channels.hasOwnProperty(target)) {\n            var channel = channels[target];\n            var sampler = samplers[channel.sampler];\n            var inputId = sampler.inputs.INPUT;\n            var outputId = sampler.inputs.OUTPUT;\n            var inputSource = sources[inputId];\n            var outputSource = sources[outputId];\n            var animation = buildAnimationChannel(channel, inputSource, outputSource);\n            createKeyframeTracks(animation, tracks);\n          }\n        }\n        return tracks;\n      }\n      function getAnimation(id) {\n        return getBuild(library.animations[id], buildAnimation);\n      }\n      function buildAnimationChannel(channel, inputSource, outputSource) {\n        var node = library.nodes[channel.id];\n        var object3D = getNode(node.id);\n        var transform = node.transforms[channel.sid];\n        var defaultMatrix = node.matrix.clone().transpose();\n        var time, stride;\n        var i, il, j, jl;\n        var data = {}; // the collada spec allows the animation of data in various ways.\n        // depending on the transform type (matrix, translate, rotate, scale), we execute different logic\n\n        switch (transform) {\n          case 'matrix':\n            for (i = 0, il = inputSource.array.length; i < il; i++) {\n              time = inputSource.array[i];\n              stride = i * outputSource.stride;\n              if (data[time] === undefined) data[time] = {};\n              if (channel.arraySyntax === true) {\n                var value = outputSource.array[stride];\n                var index = channel.indices[0] + 4 * channel.indices[1];\n                data[time][index] = value;\n              } else {\n                for (j = 0, jl = outputSource.stride; j < jl; j++) {\n                  data[time][j] = outputSource.array[stride + j];\n                }\n              }\n            }\n            break;\n          case 'translate':\n            console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n            break;\n          case 'rotate':\n            console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n            break;\n          case 'scale':\n            console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n            break;\n        }\n        var keyframes = prepareAnimationData(data, defaultMatrix);\n        var animation = {\n          name: object3D.uuid,\n          keyframes: keyframes\n        };\n        return animation;\n      }\n      function prepareAnimationData(data, defaultMatrix) {\n        var keyframes = []; // transfer data into a sortable array\n\n        for (var time in data) {\n          keyframes.push({\n            time: parseFloat(time),\n            value: data[time]\n          });\n        } // ensure keyframes are sorted by time\n\n        keyframes.sort(ascending); // now we clean up all animation data, so we can use them for keyframe tracks\n\n        for (var i = 0; i < 16; i++) {\n          transformAnimationData(keyframes, i, defaultMatrix.elements[i]);\n        }\n        return keyframes; // array sort function\n\n        function ascending(a, b) {\n          return a.time - b.time;\n        }\n      }\n      var position = new Vector3();\n      var scale = new Vector3();\n      var quaternion = new Quaternion();\n      function createKeyframeTracks(animation, tracks) {\n        var keyframes = animation.keyframes;\n        var name = animation.name;\n        var times = [];\n        var positionData = [];\n        var quaternionData = [];\n        var scaleData = [];\n        for (var i = 0, l = keyframes.length; i < l; i++) {\n          var keyframe = keyframes[i];\n          var time = keyframe.time;\n          var value = keyframe.value;\n          matrix.fromArray(value).transpose();\n          matrix.decompose(position, quaternion, scale);\n          times.push(time);\n          positionData.push(position.x, position.y, position.z);\n          quaternionData.push(quaternion.x, quaternion.y, quaternion.z, quaternion.w);\n          scaleData.push(scale.x, scale.y, scale.z);\n        }\n        if (positionData.length > 0) tracks.push(new VectorKeyframeTrack(name + '.position', times, positionData));\n        if (quaternionData.length > 0) {\n          tracks.push(new QuaternionKeyframeTrack(name + '.quaternion', times, quaternionData));\n        }\n        if (scaleData.length > 0) tracks.push(new VectorKeyframeTrack(name + '.scale', times, scaleData));\n        return tracks;\n      }\n      function transformAnimationData(keyframes, property, defaultValue) {\n        var keyframe;\n        var empty = true;\n        var i, l; // check, if values of a property are missing in our keyframes\n\n        for (i = 0, l = keyframes.length; i < l; i++) {\n          keyframe = keyframes[i];\n          if (keyframe.value[property] === undefined) {\n            keyframe.value[property] = null; // mark as missing\n          } else {\n            empty = false;\n          }\n        }\n        if (empty === true) {\n          // no values at all, so we set a default value\n          for (i = 0, l = keyframes.length; i < l; i++) {\n            keyframe = keyframes[i];\n            keyframe.value[property] = defaultValue;\n          }\n        } else {\n          // filling gaps\n          createMissingKeyframes(keyframes, property);\n        }\n      }\n      function createMissingKeyframes(keyframes, property) {\n        var prev, next;\n        for (var i = 0, l = keyframes.length; i < l; i++) {\n          var keyframe = keyframes[i];\n          if (keyframe.value[property] === null) {\n            prev = getPrev(keyframes, i, property);\n            next = getNext(keyframes, i, property);\n            if (prev === null) {\n              keyframe.value[property] = next.value[property];\n              continue;\n            }\n            if (next === null) {\n              keyframe.value[property] = prev.value[property];\n              continue;\n            }\n            interpolate(keyframe, prev, next, property);\n          }\n        }\n      }\n      function getPrev(keyframes, i, property) {\n        while (i >= 0) {\n          var keyframe = keyframes[i];\n          if (keyframe.value[property] !== null) return keyframe;\n          i--;\n        }\n        return null;\n      }\n      function getNext(keyframes, i, property) {\n        while (i < keyframes.length) {\n          var keyframe = keyframes[i];\n          if (keyframe.value[property] !== null) return keyframe;\n          i++;\n        }\n        return null;\n      }\n      function interpolate(key, prev, next, property) {\n        if (next.time - prev.time === 0) {\n          key.value[property] = prev.value[property];\n          return;\n        }\n        key.value[property] = (key.time - prev.time) * (next.value[property] - prev.value[property]) / (next.time - prev.time) + prev.value[property];\n      } // animation clips\n\n      function parseAnimationClip(xml) {\n        var data = {\n          name: xml.getAttribute('id') || 'default',\n          start: parseFloat(xml.getAttribute('start') || 0),\n          end: parseFloat(xml.getAttribute('end') || 0),\n          animations: []\n        };\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'instance_animation':\n              data.animations.push(parseId(child.getAttribute('url')));\n              break;\n          }\n        }\n        library.clips[xml.getAttribute('id')] = data;\n      }\n      function buildAnimationClip(data) {\n        var tracks = [];\n        var name = data.name;\n        var duration = data.end - data.start || -1;\n        var animations = data.animations;\n        for (var i = 0, il = animations.length; i < il; i++) {\n          var animationTracks = getAnimation(animations[i]);\n          for (var j = 0, jl = animationTracks.length; j < jl; j++) {\n            tracks.push(animationTracks[j]);\n          }\n        }\n        return new AnimationClip(name, duration, tracks);\n      }\n      function getAnimationClip(id) {\n        return getBuild(library.clips[id], buildAnimationClip);\n      } // controller\n\n      function parseController(xml) {\n        var data = {};\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'skin':\n              // there is exactly one skin per controller\n              data.id = parseId(child.getAttribute('source'));\n              data.skin = parseSkin(child);\n              break;\n            case 'morph':\n              data.id = parseId(child.getAttribute('source'));\n              console.warn('THREE.ColladaLoader: Morph target animation not supported yet.');\n              break;\n          }\n        }\n        library.controllers[xml.getAttribute('id')] = data;\n      }\n      function parseSkin(xml) {\n        var data = {\n          sources: {}\n        };\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'bind_shape_matrix':\n              data.bindShapeMatrix = parseFloats(child.textContent);\n              break;\n            case 'source':\n              var id = child.getAttribute('id');\n              data.sources[id] = parseSource(child);\n              break;\n            case 'joints':\n              data.joints = parseJoints(child);\n              break;\n            case 'vertex_weights':\n              data.vertexWeights = parseVertexWeights(child);\n              break;\n          }\n        }\n        return data;\n      }\n      function parseJoints(xml) {\n        var data = {\n          inputs: {}\n        };\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'input':\n              var semantic = child.getAttribute('semantic');\n              var id = parseId(child.getAttribute('source'));\n              data.inputs[semantic] = id;\n              break;\n          }\n        }\n        return data;\n      }\n      function parseVertexWeights(xml) {\n        var data = {\n          inputs: {}\n        };\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'input':\n              var semantic = child.getAttribute('semantic');\n              var id = parseId(child.getAttribute('source'));\n              var offset = parseInt(child.getAttribute('offset'));\n              data.inputs[semantic] = {\n                id: id,\n                offset: offset\n              };\n              break;\n            case 'vcount':\n              data.vcount = parseInts(child.textContent);\n              break;\n            case 'v':\n              data.v = parseInts(child.textContent);\n              break;\n          }\n        }\n        return data;\n      }\n      function buildController(data) {\n        var build = {\n          id: data.id\n        };\n        var geometry = library.geometries[build.id];\n        if (data.skin !== undefined) {\n          build.skin = buildSkin(data.skin); // we enhance the 'sources' property of the corresponding geometry with our skin data\n\n          geometry.sources.skinIndices = build.skin.indices;\n          geometry.sources.skinWeights = build.skin.weights;\n        }\n        return build;\n      }\n      function buildSkin(data) {\n        var BONE_LIMIT = 4;\n        var build = {\n          joints: [],\n          // this must be an array to preserve the joint order\n          indices: {\n            array: [],\n            stride: BONE_LIMIT\n          },\n          weights: {\n            array: [],\n            stride: BONE_LIMIT\n          }\n        };\n        var sources = data.sources;\n        var vertexWeights = data.vertexWeights;\n        var vcount = vertexWeights.vcount;\n        var v = vertexWeights.v;\n        var jointOffset = vertexWeights.inputs.JOINT.offset;\n        var weightOffset = vertexWeights.inputs.WEIGHT.offset;\n        var jointSource = data.sources[data.joints.inputs.JOINT];\n        var inverseSource = data.sources[data.joints.inputs.INV_BIND_MATRIX];\n        var weights = sources[vertexWeights.inputs.WEIGHT.id].array;\n        var stride = 0;\n        var i, j, l; // procces skin data for each vertex\n\n        for (i = 0, l = vcount.length; i < l; i++) {\n          var jointCount = vcount[i]; // this is the amount of joints that affect a single vertex\n\n          var vertexSkinData = [];\n          for (j = 0; j < jointCount; j++) {\n            var skinIndex = v[stride + jointOffset];\n            var weightId = v[stride + weightOffset];\n            var skinWeight = weights[weightId];\n            vertexSkinData.push({\n              index: skinIndex,\n              weight: skinWeight\n            });\n            stride += 2;\n          } // we sort the joints in descending order based on the weights.\n          // this ensures, we only procced the most important joints of the vertex\n\n          vertexSkinData.sort(descending); // now we provide for each vertex a set of four index and weight values.\n          // the order of the skin data matches the order of vertices\n\n          for (j = 0; j < BONE_LIMIT; j++) {\n            var d = vertexSkinData[j];\n            if (d !== undefined) {\n              build.indices.array.push(d.index);\n              build.weights.array.push(d.weight);\n            } else {\n              build.indices.array.push(0);\n              build.weights.array.push(0);\n            }\n          }\n        } // setup bind matrix\n\n        if (data.bindShapeMatrix) {\n          build.bindMatrix = new Matrix4().fromArray(data.bindShapeMatrix).transpose();\n        } else {\n          build.bindMatrix = new Matrix4().identity();\n        } // process bones and inverse bind matrix data\n\n        for (i = 0, l = jointSource.array.length; i < l; i++) {\n          var name = jointSource.array[i];\n          var boneInverse = new Matrix4().fromArray(inverseSource.array, i * inverseSource.stride).transpose();\n          build.joints.push({\n            name: name,\n            boneInverse: boneInverse\n          });\n        }\n        return build; // array sort function\n\n        function descending(a, b) {\n          return b.weight - a.weight;\n        }\n      }\n      function getController(id) {\n        return getBuild(library.controllers[id], buildController);\n      } // image\n\n      function parseImage(xml) {\n        var data = {\n          init_from: getElementsByTagName(xml, 'init_from')[0].textContent\n        };\n        library.images[xml.getAttribute('id')] = data;\n      }\n      function buildImage(data) {\n        if (data.build !== undefined) return data.build;\n        return data.init_from;\n      }\n      function getImage(id) {\n        var data = library.images[id];\n        if (data !== undefined) {\n          return getBuild(data, buildImage);\n        }\n        console.warn(\"THREE.ColladaLoader: Couldn't find image with ID:\", id);\n        return null;\n      } // effect\n\n      function parseEffect(xml) {\n        var data = {};\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'profile_COMMON':\n              data.profile = parseEffectProfileCOMMON(child);\n              break;\n          }\n        }\n        library.effects[xml.getAttribute('id')] = data;\n      }\n      function parseEffectProfileCOMMON(xml) {\n        var data = {\n          surfaces: {},\n          samplers: {}\n        };\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'newparam':\n              parseEffectNewparam(child, data);\n              break;\n            case 'technique':\n              data.technique = parseEffectTechnique(child);\n              break;\n            case 'extra':\n              data.extra = parseEffectExtra(child);\n              break;\n          }\n        }\n        return data;\n      }\n      function parseEffectNewparam(xml, data) {\n        var sid = xml.getAttribute('sid');\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'surface':\n              data.surfaces[sid] = parseEffectSurface(child);\n              break;\n            case 'sampler2D':\n              data.samplers[sid] = parseEffectSampler(child);\n              break;\n          }\n        }\n      }\n      function parseEffectSurface(xml) {\n        var data = {};\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'init_from':\n              data.init_from = child.textContent;\n              break;\n          }\n        }\n        return data;\n      }\n      function parseEffectSampler(xml) {\n        var data = {};\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'source':\n              data.source = child.textContent;\n              break;\n          }\n        }\n        return data;\n      }\n      function parseEffectTechnique(xml) {\n        var data = {};\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'constant':\n            case 'lambert':\n            case 'blinn':\n            case 'phong':\n              data.type = child.nodeName;\n              data.parameters = parseEffectParameters(child);\n              break;\n            case 'extra':\n              data.extra = parseEffectExtra(child);\n              break;\n          }\n        }\n        return data;\n      }\n      function parseEffectParameters(xml) {\n        var data = {};\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'emission':\n            case 'diffuse':\n            case 'specular':\n            case 'bump':\n            case 'ambient':\n            case 'shininess':\n            case 'transparency':\n              data[child.nodeName] = parseEffectParameter(child);\n              break;\n            case 'transparent':\n              data[child.nodeName] = {\n                opaque: child.hasAttribute('opaque') ? child.getAttribute('opaque') : 'A_ONE',\n                data: parseEffectParameter(child)\n              };\n              break;\n          }\n        }\n        return data;\n      }\n      function parseEffectParameter(xml) {\n        var data = {};\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'color':\n              data[child.nodeName] = parseFloats(child.textContent);\n              break;\n            case 'float':\n              data[child.nodeName] = parseFloat(child.textContent);\n              break;\n            case 'texture':\n              data[child.nodeName] = {\n                id: child.getAttribute('texture'),\n                extra: parseEffectParameterTexture(child)\n              };\n              break;\n          }\n        }\n        return data;\n      }\n      function parseEffectParameterTexture(xml) {\n        var data = {\n          technique: {}\n        };\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'extra':\n              parseEffectParameterTextureExtra(child, data);\n              break;\n          }\n        }\n        return data;\n      }\n      function parseEffectParameterTextureExtra(xml, data) {\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'technique':\n              parseEffectParameterTextureExtraTechnique(child, data);\n              break;\n          }\n        }\n      }\n      function parseEffectParameterTextureExtraTechnique(xml, data) {\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'repeatU':\n            case 'repeatV':\n            case 'offsetU':\n            case 'offsetV':\n              data.technique[child.nodeName] = parseFloat(child.textContent);\n              break;\n            case 'wrapU':\n            case 'wrapV':\n              // some files have values for wrapU/wrapV which become NaN via parseInt\n              if (child.textContent.toUpperCase() === 'TRUE') {\n                data.technique[child.nodeName] = 1;\n              } else if (child.textContent.toUpperCase() === 'FALSE') {\n                data.technique[child.nodeName] = 0;\n              } else {\n                data.technique[child.nodeName] = parseInt(child.textContent);\n              }\n              break;\n            case 'bump':\n              data[child.nodeName] = parseEffectExtraTechniqueBump(child);\n              break;\n          }\n        }\n      }\n      function parseEffectExtra(xml) {\n        var data = {};\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'technique':\n              data.technique = parseEffectExtraTechnique(child);\n              break;\n          }\n        }\n        return data;\n      }\n      function parseEffectExtraTechnique(xml) {\n        var data = {};\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'double_sided':\n              data[child.nodeName] = parseInt(child.textContent);\n              break;\n            case 'bump':\n              data[child.nodeName] = parseEffectExtraTechniqueBump(child);\n              break;\n          }\n        }\n        return data;\n      }\n      function parseEffectExtraTechniqueBump(xml) {\n        var data = {};\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'texture':\n              data[child.nodeName] = {\n                id: child.getAttribute('texture'),\n                texcoord: child.getAttribute('texcoord'),\n                extra: parseEffectParameterTexture(child)\n              };\n              break;\n          }\n        }\n        return data;\n      }\n      function buildEffect(data) {\n        return data;\n      }\n      function getEffect(id) {\n        return getBuild(library.effects[id], buildEffect);\n      } // material\n\n      function parseMaterial(xml) {\n        var data = {\n          name: xml.getAttribute('name')\n        };\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'instance_effect':\n              data.url = parseId(child.getAttribute('url'));\n              break;\n          }\n        }\n        library.materials[xml.getAttribute('id')] = data;\n      }\n      function getTextureLoader(image) {\n        var loader;\n        var extension = image.slice((image.lastIndexOf('.') - 1 >>> 0) + 2); // http://www.jstips.co/en/javascript/get-file-extension/\n\n        extension = extension.toLowerCase();\n        switch (extension) {\n          case 'tga':\n            loader = tgaLoader;\n            break;\n          default:\n            loader = textureLoader;\n        }\n        return loader;\n      }\n      function buildMaterial(data) {\n        var effect = getEffect(data.url);\n        var technique = effect.profile.technique;\n        var material;\n        switch (technique.type) {\n          case 'phong':\n          case 'blinn':\n            material = new MeshPhongMaterial();\n            break;\n          case 'lambert':\n            material = new MeshLambertMaterial();\n            break;\n          default:\n            material = new MeshBasicMaterial();\n            break;\n        }\n        material.name = data.name || '';\n        function getTexture(textureObject) {\n          var sampler = effect.profile.samplers[textureObject.id];\n          var image = null; // get image\n\n          if (sampler !== undefined) {\n            var surface = effect.profile.surfaces[sampler.source];\n            image = getImage(surface.init_from);\n          } else {\n            console.warn('THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530).');\n            image = getImage(textureObject.id);\n          } // create texture if image is avaiable\n\n          if (image !== null) {\n            var loader = getTextureLoader(image);\n            if (loader !== undefined) {\n              var texture = loader.load(image);\n              var extra = textureObject.extra;\n              if (extra !== undefined && extra.technique !== undefined && isEmpty(extra.technique) === false) {\n                var _technique = extra.technique;\n                texture.wrapS = _technique.wrapU ? RepeatWrapping : ClampToEdgeWrapping;\n                texture.wrapT = _technique.wrapV ? RepeatWrapping : ClampToEdgeWrapping;\n                texture.offset.set(_technique.offsetU || 0, _technique.offsetV || 0);\n                texture.repeat.set(_technique.repeatU || 1, _technique.repeatV || 1);\n              } else {\n                texture.wrapS = RepeatWrapping;\n                texture.wrapT = RepeatWrapping;\n              }\n              return texture;\n            } else {\n              console.warn('THREE.ColladaLoader: Loader for texture %s not found.', image);\n              return null;\n            }\n          } else {\n            console.warn(\"THREE.ColladaLoader: Couldn't create texture with ID:\", textureObject.id);\n            return null;\n          }\n        }\n        var parameters = technique.parameters;\n        for (var key in parameters) {\n          var parameter = parameters[key];\n          switch (key) {\n            case 'diffuse':\n              if (parameter.color) material.color.fromArray(parameter.color);\n              if (parameter.texture) material.map = getTexture(parameter.texture);\n              break;\n            case 'specular':\n              if (parameter.color && material.specular) material.specular.fromArray(parameter.color);\n              if (parameter.texture) material.specularMap = getTexture(parameter.texture);\n              break;\n            case 'bump':\n              if (parameter.texture) material.normalMap = getTexture(parameter.texture);\n              break;\n            case 'ambient':\n              if (parameter.texture) material.lightMap = getTexture(parameter.texture);\n              break;\n            case 'shininess':\n              if (parameter.float && material.shininess) material.shininess = parameter.float;\n              break;\n            case 'emission':\n              if (parameter.color && material.emissive) material.emissive.fromArray(parameter.color);\n              if (parameter.texture) material.emissiveMap = getTexture(parameter.texture);\n              break;\n          }\n        } //\n\n        var transparent = parameters['transparent'];\n        var transparency = parameters['transparency']; // <transparency> does not exist but <transparent>\n\n        if (transparency === undefined && transparent) {\n          transparency = {\n            float: 1\n          };\n        } // <transparent> does not exist but <transparency>\n\n        if (transparent === undefined && transparency) {\n          transparent = {\n            opaque: 'A_ONE',\n            data: {\n              color: [1, 1, 1, 1]\n            }\n          };\n        }\n        if (transparent && transparency) {\n          // handle case if a texture exists but no color\n          if (transparent.data.texture) {\n            // we do not set an alpha map (see #13792)\n            material.transparent = true;\n          } else {\n            var color = transparent.data.color;\n            switch (transparent.opaque) {\n              case 'A_ONE':\n                material.opacity = color[3] * transparency.float;\n                break;\n              case 'RGB_ZERO':\n                material.opacity = 1 - color[0] * transparency.float;\n                break;\n              case 'A_ZERO':\n                material.opacity = 1 - color[3] * transparency.float;\n                break;\n              case 'RGB_ONE':\n                material.opacity = color[0] * transparency.float;\n                break;\n              default:\n                console.warn('THREE.ColladaLoader: Invalid opaque type \"%s\" of transparent tag.', transparent.opaque);\n            }\n            if (material.opacity < 1) material.transparent = true;\n          }\n        } //\n\n        if (technique.extra !== undefined && technique.extra.technique !== undefined) {\n          var techniques = technique.extra.technique;\n          for (var k in techniques) {\n            var v = techniques[k];\n            switch (k) {\n              case 'double_sided':\n                material.side = v === 1 ? DoubleSide : FrontSide;\n                break;\n              case 'bump':\n                material.normalMap = getTexture(v.texture);\n                material.normalScale = new Vector2(1, 1);\n                break;\n            }\n          }\n        }\n        return material;\n      }\n      function getMaterial(id) {\n        return getBuild(library.materials[id], buildMaterial);\n      } // camera\n\n      function parseCamera(xml) {\n        var data = {\n          name: xml.getAttribute('name')\n        };\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'optics':\n              data.optics = parseCameraOptics(child);\n              break;\n          }\n        }\n        library.cameras[xml.getAttribute('id')] = data;\n      }\n      function parseCameraOptics(xml) {\n        for (var i = 0; i < xml.childNodes.length; i++) {\n          var child = xml.childNodes[i];\n          switch (child.nodeName) {\n            case 'technique_common':\n              return parseCameraTechnique(child);\n          }\n        }\n        return {};\n      }\n      function parseCameraTechnique(xml) {\n        var data = {};\n        for (var i = 0; i < xml.childNodes.length; i++) {\n          var child = xml.childNodes[i];\n          switch (child.nodeName) {\n            case 'perspective':\n            case 'orthographic':\n              data.technique = child.nodeName;\n              data.parameters = parseCameraParameters(child);\n              break;\n          }\n        }\n        return data;\n      }\n      function parseCameraParameters(xml) {\n        var data = {};\n        for (var i = 0; i < xml.childNodes.length; i++) {\n          var child = xml.childNodes[i];\n          switch (child.nodeName) {\n            case 'xfov':\n            case 'yfov':\n            case 'xmag':\n            case 'ymag':\n            case 'znear':\n            case 'zfar':\n            case 'aspect_ratio':\n              data[child.nodeName] = parseFloat(child.textContent);\n              break;\n          }\n        }\n        return data;\n      }\n      function buildCamera(data) {\n        var camera;\n        switch (data.optics.technique) {\n          case 'perspective':\n            camera = new PerspectiveCamera(data.optics.parameters.yfov, data.optics.parameters.aspect_ratio, data.optics.parameters.znear, data.optics.parameters.zfar);\n            break;\n          case 'orthographic':\n            var ymag = data.optics.parameters.ymag;\n            var xmag = data.optics.parameters.xmag;\n            var aspectRatio = data.optics.parameters.aspect_ratio;\n            xmag = xmag === undefined ? ymag * aspectRatio : xmag;\n            ymag = ymag === undefined ? xmag / aspectRatio : ymag;\n            xmag *= 0.5;\n            ymag *= 0.5;\n            camera = new OrthographicCamera(-xmag, xmag, ymag, -ymag,\n            // left, right, top, bottom\n            data.optics.parameters.znear, data.optics.parameters.zfar);\n            break;\n          default:\n            camera = new PerspectiveCamera();\n            break;\n        }\n        camera.name = data.name || '';\n        return camera;\n      }\n      function getCamera(id) {\n        var data = library.cameras[id];\n        if (data !== undefined) {\n          return getBuild(data, buildCamera);\n        }\n        console.warn(\"THREE.ColladaLoader: Couldn't find camera with ID:\", id);\n        return null;\n      } // light\n\n      function parseLight(xml) {\n        var data = {};\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'technique_common':\n              data = parseLightTechnique(child);\n              break;\n          }\n        }\n        library.lights[xml.getAttribute('id')] = data;\n      }\n      function parseLightTechnique(xml) {\n        var data = {};\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'directional':\n            case 'point':\n            case 'spot':\n            case 'ambient':\n              data.technique = child.nodeName;\n              data.parameters = parseLightParameters(child);\n          }\n        }\n        return data;\n      }\n      function parseLightParameters(xml) {\n        var data = {};\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'color':\n              var array = parseFloats(child.textContent);\n              data.color = new Color().fromArray(array);\n              break;\n            case 'falloff_angle':\n              data.falloffAngle = parseFloat(child.textContent);\n              break;\n            case 'quadratic_attenuation':\n              var f = parseFloat(child.textContent);\n              data.distance = f ? Math.sqrt(1 / f) : 0;\n              break;\n          }\n        }\n        return data;\n      }\n      function buildLight(data) {\n        var light;\n        switch (data.technique) {\n          case 'directional':\n            light = new DirectionalLight();\n            break;\n          case 'point':\n            light = new PointLight();\n            break;\n          case 'spot':\n            light = new SpotLight();\n            break;\n          case 'ambient':\n            light = new AmbientLight();\n            break;\n        }\n        if (data.parameters.color) light.color.copy(data.parameters.color);\n        if (data.parameters.distance) light.distance = data.parameters.distance;\n        return light;\n      }\n      function getLight(id) {\n        var data = library.lights[id];\n        if (data !== undefined) {\n          return getBuild(data, buildLight);\n        }\n        console.warn(\"THREE.ColladaLoader: Couldn't find light with ID:\", id);\n        return null;\n      } // geometry\n\n      function parseGeometry(xml) {\n        var data = {\n          name: xml.getAttribute('name'),\n          sources: {},\n          vertices: {},\n          primitives: []\n        };\n        var mesh = getElementsByTagName(xml, 'mesh')[0]; // the following tags inside geometry are not supported yet (see https://github.com/mrdoob/three.js/pull/12606): convex_mesh, spline, brep\n\n        if (mesh === undefined) return;\n        for (var i = 0; i < mesh.childNodes.length; i++) {\n          var child = mesh.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          var id = child.getAttribute('id');\n          switch (child.nodeName) {\n            case 'source':\n              data.sources[id] = parseSource(child);\n              break;\n            case 'vertices':\n              // data.sources[ id ] = data.sources[ parseId( getElementsByTagName( child, 'input' )[ 0 ].getAttribute( 'source' ) ) ];\n              data.vertices = parseGeometryVertices(child);\n              break;\n            case 'polygons':\n              console.warn('THREE.ColladaLoader: Unsupported primitive type: ', child.nodeName);\n              break;\n            case 'lines':\n            case 'linestrips':\n            case 'polylist':\n            case 'triangles':\n              data.primitives.push(parseGeometryPrimitive(child));\n              break;\n            default:\n              console.log(child);\n          }\n        }\n        library.geometries[xml.getAttribute('id')] = data;\n      }\n      function parseSource(xml) {\n        var data = {\n          array: [],\n          stride: 3\n        };\n        for (var i = 0; i < xml.childNodes.length; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'float_array':\n              data.array = parseFloats(child.textContent);\n              break;\n            case 'Name_array':\n              data.array = parseStrings(child.textContent);\n              break;\n            case 'technique_common':\n              var accessor = getElementsByTagName(child, 'accessor')[0];\n              if (accessor !== undefined) {\n                data.stride = parseInt(accessor.getAttribute('stride'));\n              }\n              break;\n          }\n        }\n        return data;\n      }\n      function parseGeometryVertices(xml) {\n        var data = {};\n        for (var i = 0; i < xml.childNodes.length; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          data[child.getAttribute('semantic')] = parseId(child.getAttribute('source'));\n        }\n        return data;\n      }\n      function parseGeometryPrimitive(xml) {\n        var primitive = {\n          type: xml.nodeName,\n          material: xml.getAttribute('material'),\n          count: parseInt(xml.getAttribute('count')),\n          inputs: {},\n          stride: 0,\n          hasUV: false\n        };\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'input':\n              var id = parseId(child.getAttribute('source'));\n              var semantic = child.getAttribute('semantic');\n              var offset = parseInt(child.getAttribute('offset'));\n              var set = parseInt(child.getAttribute('set'));\n              var inputname = set > 0 ? semantic + set : semantic;\n              primitive.inputs[inputname] = {\n                id: id,\n                offset: offset\n              };\n              primitive.stride = Math.max(primitive.stride, offset + 1);\n              if (semantic === 'TEXCOORD') primitive.hasUV = true;\n              break;\n            case 'vcount':\n              primitive.vcount = parseInts(child.textContent);\n              break;\n            case 'p':\n              primitive.p = parseInts(child.textContent);\n              break;\n          }\n        }\n        return primitive;\n      }\n      function groupPrimitives(primitives) {\n        var build = {};\n        for (var i = 0; i < primitives.length; i++) {\n          var primitive = primitives[i];\n          if (build[primitive.type] === undefined) build[primitive.type] = [];\n          build[primitive.type].push(primitive);\n        }\n        return build;\n      }\n      function checkUVCoordinates(primitives) {\n        var count = 0;\n        for (var i = 0, l = primitives.length; i < l; i++) {\n          var primitive = primitives[i];\n          if (primitive.hasUV === true) {\n            count++;\n          }\n        }\n        if (count > 0 && count < primitives.length) {\n          primitives.uvsNeedsFix = true;\n        }\n      }\n      function buildGeometry(data) {\n        var build = {};\n        var sources = data.sources;\n        var vertices = data.vertices;\n        var primitives = data.primitives;\n        if (primitives.length === 0) return {}; // our goal is to create one buffer geometry for a single type of primitives\n        // first, we group all primitives by their type\n\n        var groupedPrimitives = groupPrimitives(primitives);\n        for (var type in groupedPrimitives) {\n          var primitiveType = groupedPrimitives[type]; // second, ensure consistent uv coordinates for each type of primitives (polylist,triangles or lines)\n\n          checkUVCoordinates(primitiveType); // third, create a buffer geometry for each type of primitives\n\n          build[type] = buildGeometryType(primitiveType, sources, vertices);\n        }\n        return build;\n      }\n      function buildGeometryType(primitives, sources, vertices) {\n        var build = {};\n        var position = {\n          array: [],\n          stride: 0\n        };\n        var normal = {\n          array: [],\n          stride: 0\n        };\n        var uv = {\n          array: [],\n          stride: 0\n        };\n        var uv2 = {\n          array: [],\n          stride: 0\n        };\n        var color = {\n          array: [],\n          stride: 0\n        };\n        var skinIndex = {\n          array: [],\n          stride: 4\n        };\n        var skinWeight = {\n          array: [],\n          stride: 4\n        };\n        var geometry = new BufferGeometry();\n        var materialKeys = [];\n        var start = 0;\n        for (var p = 0; p < primitives.length; p++) {\n          var primitive = primitives[p];\n          var inputs = primitive.inputs; // groups\n\n          var _count = 0;\n          switch (primitive.type) {\n            case 'lines':\n            case 'linestrips':\n              _count = primitive.count * 2;\n              break;\n            case 'triangles':\n              _count = primitive.count * 3;\n              break;\n            case 'polylist':\n              for (var g = 0; g < primitive.count; g++) {\n                var vc = primitive.vcount[g];\n                switch (vc) {\n                  case 3:\n                    _count += 3; // single triangle\n\n                    break;\n                  case 4:\n                    _count += 6; // quad, subdivided into two triangles\n\n                    break;\n                  default:\n                    _count += (vc - 2) * 3; // polylist with more than four vertices\n\n                    break;\n                }\n              }\n              break;\n            default:\n              console.warn('THREE.ColladaLoader: Unknow primitive type:', primitive.type);\n          }\n          geometry.addGroup(start, _count, p);\n          start += _count; // material\n\n          if (primitive.material) {\n            materialKeys.push(primitive.material);\n          } // geometry data\n\n          for (var name in inputs) {\n            var input = inputs[name];\n            switch (name) {\n              case 'VERTEX':\n                for (var key in vertices) {\n                  var id = vertices[key];\n                  switch (key) {\n                    case 'POSITION':\n                      var prevLength = position.array.length;\n                      buildGeometryData(primitive, sources[id], input.offset, position.array);\n                      position.stride = sources[id].stride;\n                      if (sources.skinWeights && sources.skinIndices) {\n                        buildGeometryData(primitive, sources.skinIndices, input.offset, skinIndex.array);\n                        buildGeometryData(primitive, sources.skinWeights, input.offset, skinWeight.array);\n                      } // see #3803\n\n                      if (primitive.hasUV === false && primitives.uvsNeedsFix === true) {\n                        var _count2 = (position.array.length - prevLength) / position.stride;\n                        for (var i = 0; i < _count2; i++) {\n                          // fill missing uv coordinates\n                          uv.array.push(0, 0);\n                        }\n                      }\n                      break;\n                    case 'NORMAL':\n                      buildGeometryData(primitive, sources[id], input.offset, normal.array);\n                      normal.stride = sources[id].stride;\n                      break;\n                    case 'COLOR':\n                      buildGeometryData(primitive, sources[id], input.offset, color.array);\n                      color.stride = sources[id].stride;\n                      break;\n                    case 'TEXCOORD':\n                      buildGeometryData(primitive, sources[id], input.offset, uv.array);\n                      uv.stride = sources[id].stride;\n                      break;\n                    case 'TEXCOORD1':\n                      buildGeometryData(primitive, sources[id], input.offset, uv2.array);\n                      uv.stride = sources[id].stride;\n                      break;\n                    default:\n                      console.warn('THREE.ColladaLoader: Semantic \"%s\" not handled in geometry build process.', key);\n                  }\n                }\n                break;\n              case 'NORMAL':\n                buildGeometryData(primitive, sources[input.id], input.offset, normal.array);\n                normal.stride = sources[input.id].stride;\n                break;\n              case 'COLOR':\n                buildGeometryData(primitive, sources[input.id], input.offset, color.array);\n                color.stride = sources[input.id].stride;\n                break;\n              case 'TEXCOORD':\n                buildGeometryData(primitive, sources[input.id], input.offset, uv.array);\n                uv.stride = sources[input.id].stride;\n                break;\n              case 'TEXCOORD1':\n                buildGeometryData(primitive, sources[input.id], input.offset, uv2.array);\n                uv2.stride = sources[input.id].stride;\n                break;\n            }\n          }\n        } // build geometry\n\n        if (position.array.length > 0) {\n          geometry.setAttribute('position', new Float32BufferAttribute(position.array, position.stride));\n        }\n        if (normal.array.length > 0) {\n          geometry.setAttribute('normal', new Float32BufferAttribute(normal.array, normal.stride));\n        }\n        if (color.array.length > 0) geometry.setAttribute('color', new Float32BufferAttribute(color.array, color.stride));\n        if (uv.array.length > 0) geometry.setAttribute('uv', new Float32BufferAttribute(uv.array, uv.stride));\n        if (uv2.array.length > 0) geometry.setAttribute('uv2', new Float32BufferAttribute(uv2.array, uv2.stride));\n        if (skinIndex.array.length > 0) {\n          geometry.setAttribute('skinIndex', new Float32BufferAttribute(skinIndex.array, skinIndex.stride));\n        }\n        if (skinWeight.array.length > 0) {\n          geometry.setAttribute('skinWeight', new Float32BufferAttribute(skinWeight.array, skinWeight.stride));\n        }\n        build.data = geometry;\n        build.type = primitives[0].type;\n        build.materialKeys = materialKeys;\n        return build;\n      }\n      function buildGeometryData(primitive, source, offset, array) {\n        var indices = primitive.p;\n        var stride = primitive.stride;\n        var vcount = primitive.vcount;\n        function pushVector(i) {\n          var index = indices[i + offset] * sourceStride;\n          var length = index + sourceStride;\n          for (; index < length; index++) {\n            array.push(sourceArray[index]);\n          }\n        }\n        var sourceArray = source.array;\n        var sourceStride = source.stride;\n        if (primitive.vcount !== undefined) {\n          var index = 0;\n          for (var i = 0, l = vcount.length; i < l; i++) {\n            var _count3 = vcount[i];\n            if (_count3 === 4) {\n              var a = index + stride * 0;\n              var b = index + stride * 1;\n              var c = index + stride * 2;\n              var d = index + stride * 3;\n              pushVector(a);\n              pushVector(b);\n              pushVector(d);\n              pushVector(b);\n              pushVector(c);\n              pushVector(d);\n            } else if (_count3 === 3) {\n              var _a = index + stride * 0;\n              var _b = index + stride * 1;\n              var _c = index + stride * 2;\n              pushVector(_a);\n              pushVector(_b);\n              pushVector(_c);\n            } else if (_count3 > 4) {\n              for (var k = 1, kl = _count3 - 2; k <= kl; k++) {\n                var _a2 = index + stride * 0;\n                var _b2 = index + stride * k;\n                var _c2 = index + stride * (k + 1);\n                pushVector(_a2);\n                pushVector(_b2);\n                pushVector(_c2);\n              }\n            }\n            index += stride * _count3;\n          }\n        } else {\n          for (var _i = 0, _l = indices.length; _i < _l; _i += stride) {\n            pushVector(_i);\n          }\n        }\n      }\n      function getGeometry(id) {\n        return getBuild(library.geometries[id], buildGeometry);\n      } // kinematics\n\n      function parseKinematicsModel(xml) {\n        var data = {\n          name: xml.getAttribute('name') || '',\n          joints: {},\n          links: []\n        };\n        for (var i = 0; i < xml.childNodes.length; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'technique_common':\n              parseKinematicsTechniqueCommon(child, data);\n              break;\n          }\n        }\n        library.kinematicsModels[xml.getAttribute('id')] = data;\n      }\n      function buildKinematicsModel(data) {\n        if (data.build !== undefined) return data.build;\n        return data;\n      }\n      function getKinematicsModel(id) {\n        return getBuild(library.kinematicsModels[id], buildKinematicsModel);\n      }\n      function parseKinematicsTechniqueCommon(xml, data) {\n        for (var i = 0; i < xml.childNodes.length; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'joint':\n              data.joints[child.getAttribute('sid')] = parseKinematicsJoint(child);\n              break;\n            case 'link':\n              data.links.push(parseKinematicsLink(child));\n              break;\n          }\n        }\n      }\n      function parseKinematicsJoint(xml) {\n        var data;\n        for (var i = 0; i < xml.childNodes.length; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'prismatic':\n            case 'revolute':\n              data = parseKinematicsJointParameter(child);\n              break;\n          }\n        }\n        return data;\n      }\n      function parseKinematicsJointParameter(xml) {\n        var data = {\n          sid: xml.getAttribute('sid'),\n          name: xml.getAttribute('name') || '',\n          axis: new Vector3(),\n          limits: {\n            min: 0,\n            max: 0\n          },\n          type: xml.nodeName,\n          static: false,\n          zeroPosition: 0,\n          middlePosition: 0\n        };\n        for (var i = 0; i < xml.childNodes.length; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'axis':\n              var array = parseFloats(child.textContent);\n              data.axis.fromArray(array);\n              break;\n            case 'limits':\n              var max = child.getElementsByTagName('max')[0];\n              var min = child.getElementsByTagName('min')[0];\n              data.limits.max = parseFloat(max.textContent);\n              data.limits.min = parseFloat(min.textContent);\n              break;\n          }\n        } // if min is equal to or greater than max, consider the joint static\n\n        if (data.limits.min >= data.limits.max) {\n          data.static = true;\n        } // calculate middle position\n\n        data.middlePosition = (data.limits.min + data.limits.max) / 2.0;\n        return data;\n      }\n      function parseKinematicsLink(xml) {\n        var data = {\n          sid: xml.getAttribute('sid'),\n          name: xml.getAttribute('name') || '',\n          attachments: [],\n          transforms: []\n        };\n        for (var i = 0; i < xml.childNodes.length; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'attachment_full':\n              data.attachments.push(parseKinematicsAttachment(child));\n              break;\n            case 'matrix':\n            case 'translate':\n            case 'rotate':\n              data.transforms.push(parseKinematicsTransform(child));\n              break;\n          }\n        }\n        return data;\n      }\n      function parseKinematicsAttachment(xml) {\n        var data = {\n          joint: xml.getAttribute('joint').split('/').pop(),\n          transforms: [],\n          links: []\n        };\n        for (var i = 0; i < xml.childNodes.length; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'link':\n              data.links.push(parseKinematicsLink(child));\n              break;\n            case 'matrix':\n            case 'translate':\n            case 'rotate':\n              data.transforms.push(parseKinematicsTransform(child));\n              break;\n          }\n        }\n        return data;\n      }\n      function parseKinematicsTransform(xml) {\n        var data = {\n          type: xml.nodeName\n        };\n        var array = parseFloats(xml.textContent);\n        switch (data.type) {\n          case 'matrix':\n            data.obj = new Matrix4();\n            data.obj.fromArray(array).transpose();\n            break;\n          case 'translate':\n            data.obj = new Vector3();\n            data.obj.fromArray(array);\n            break;\n          case 'rotate':\n            data.obj = new Vector3();\n            data.obj.fromArray(array);\n            data.angle = MathUtils.degToRad(array[3]);\n            break;\n        }\n        return data;\n      } // physics\n\n      function parsePhysicsModel(xml) {\n        var data = {\n          name: xml.getAttribute('name') || '',\n          rigidBodies: {}\n        };\n        for (var i = 0; i < xml.childNodes.length; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'rigid_body':\n              data.rigidBodies[child.getAttribute('name')] = {};\n              parsePhysicsRigidBody(child, data.rigidBodies[child.getAttribute('name')]);\n              break;\n          }\n        }\n        library.physicsModels[xml.getAttribute('id')] = data;\n      }\n      function parsePhysicsRigidBody(xml, data) {\n        for (var i = 0; i < xml.childNodes.length; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'technique_common':\n              parsePhysicsTechniqueCommon(child, data);\n              break;\n          }\n        }\n      }\n      function parsePhysicsTechniqueCommon(xml, data) {\n        for (var i = 0; i < xml.childNodes.length; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'inertia':\n              data.inertia = parseFloats(child.textContent);\n              break;\n            case 'mass':\n              data.mass = parseFloats(child.textContent)[0];\n              break;\n          }\n        }\n      } // scene\n\n      function parseKinematicsScene(xml) {\n        var data = {\n          bindJointAxis: []\n        };\n        for (var i = 0; i < xml.childNodes.length; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'bind_joint_axis':\n              data.bindJointAxis.push(parseKinematicsBindJointAxis(child));\n              break;\n          }\n        }\n        library.kinematicsScenes[parseId(xml.getAttribute('url'))] = data;\n      }\n      function parseKinematicsBindJointAxis(xml) {\n        var data = {\n          target: xml.getAttribute('target').split('/').pop()\n        };\n        for (var i = 0; i < xml.childNodes.length; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'axis':\n              var param = child.getElementsByTagName('param')[0];\n              data.axis = param.textContent;\n              var tmpJointIndex = data.axis.split('inst_').pop().split('axis')[0];\n              data.jointIndex = tmpJointIndex.substr(0, tmpJointIndex.length - 1);\n              break;\n          }\n        }\n        return data;\n      }\n      function buildKinematicsScene(data) {\n        if (data.build !== undefined) return data.build;\n        return data;\n      }\n      function getKinematicsScene(id) {\n        return getBuild(library.kinematicsScenes[id], buildKinematicsScene);\n      }\n      function setupKinematics() {\n        var kinematicsModelId = Object.keys(library.kinematicsModels)[0];\n        var kinematicsSceneId = Object.keys(library.kinematicsScenes)[0];\n        var visualSceneId = Object.keys(library.visualScenes)[0];\n        if (kinematicsModelId === undefined || kinematicsSceneId === undefined) return;\n        var kinematicsModel = getKinematicsModel(kinematicsModelId);\n        var kinematicsScene = getKinematicsScene(kinematicsSceneId);\n        var visualScene = getVisualScene(visualSceneId);\n        var bindJointAxis = kinematicsScene.bindJointAxis;\n        var jointMap = {};\n        for (var i = 0, l = bindJointAxis.length; i < l; i++) {\n          var axis = bindJointAxis[i]; // the result of the following query is an element of type 'translate', 'rotate','scale' or 'matrix'\n\n          var targetElement = collada.querySelector('[sid=\"' + axis.target + '\"]');\n          if (targetElement) {\n            // get the parent of the transform element\n            var parentVisualElement = targetElement.parentElement; // connect the joint of the kinematics model with the element in the visual scene\n\n            connect(axis.jointIndex, parentVisualElement);\n          }\n        }\n        function connect(jointIndex, visualElement) {\n          var visualElementName = visualElement.getAttribute('name');\n          var joint = kinematicsModel.joints[jointIndex];\n          visualScene.traverse(function (object) {\n            if (object.name === visualElementName) {\n              jointMap[jointIndex] = {\n                object: object,\n                transforms: buildTransformList(visualElement),\n                joint: joint,\n                position: joint.zeroPosition\n              };\n            }\n          });\n        }\n        var m0 = new Matrix4();\n        kinematics = {\n          joints: kinematicsModel && kinematicsModel.joints,\n          getJointValue: function getJointValue(jointIndex) {\n            var jointData = jointMap[jointIndex];\n            if (jointData) {\n              return jointData.position;\n            } else {\n              console.warn('THREE.ColladaLoader: Joint ' + jointIndex + \" doesn't exist.\");\n            }\n          },\n          setJointValue: function setJointValue(jointIndex, value) {\n            var jointData = jointMap[jointIndex];\n            if (jointData) {\n              var joint = jointData.joint;\n              if (value > joint.limits.max || value < joint.limits.min) {\n                console.warn('THREE.ColladaLoader: Joint ' + jointIndex + ' value ' + value + ' outside of limits (min: ' + joint.limits.min + ', max: ' + joint.limits.max + ').');\n              } else if (joint.static) {\n                console.warn('THREE.ColladaLoader: Joint ' + jointIndex + ' is static.');\n              } else {\n                var object = jointData.object;\n                var _axis = joint.axis;\n                var transforms = jointData.transforms;\n                matrix.identity(); // each update, we have to apply all transforms in the correct order\n\n                for (var _i2 = 0; _i2 < transforms.length; _i2++) {\n                  var transform = transforms[_i2]; // if there is a connection of the transform node with a joint, apply the joint value\n\n                  if (transform.sid && transform.sid.indexOf(jointIndex) !== -1) {\n                    switch (joint.type) {\n                      case 'revolute':\n                        matrix.multiply(m0.makeRotationAxis(_axis, MathUtils.degToRad(value)));\n                        break;\n                      case 'prismatic':\n                        matrix.multiply(m0.makeTranslation(_axis.x * value, _axis.y * value, _axis.z * value));\n                        break;\n                      default:\n                        console.warn('THREE.ColladaLoader: Unknown joint type: ' + joint.type);\n                        break;\n                    }\n                  } else {\n                    switch (transform.type) {\n                      case 'matrix':\n                        matrix.multiply(transform.obj);\n                        break;\n                      case 'translate':\n                        matrix.multiply(m0.makeTranslation(transform.obj.x, transform.obj.y, transform.obj.z));\n                        break;\n                      case 'scale':\n                        matrix.scale(transform.obj);\n                        break;\n                      case 'rotate':\n                        matrix.multiply(m0.makeRotationAxis(transform.obj, transform.angle));\n                        break;\n                    }\n                  }\n                }\n                object.matrix.copy(matrix);\n                object.matrix.decompose(object.position, object.quaternion, object.scale);\n                jointMap[jointIndex].position = value;\n              }\n            } else {\n              console.log('THREE.ColladaLoader: ' + jointIndex + ' does not exist.');\n            }\n          }\n        };\n      }\n      function buildTransformList(node) {\n        var transforms = [];\n        var xml = collada.querySelector('[id=\"' + node.id + '\"]');\n        for (var i = 0; i < xml.childNodes.length; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          var array = void 0,\n            _vector = void 0;\n          switch (child.nodeName) {\n            case 'matrix':\n              array = parseFloats(child.textContent);\n              var _matrix = new Matrix4().fromArray(array).transpose();\n              transforms.push({\n                sid: child.getAttribute('sid'),\n                type: child.nodeName,\n                obj: _matrix\n              });\n              break;\n            case 'translate':\n            case 'scale':\n              array = parseFloats(child.textContent);\n              _vector = new Vector3().fromArray(array);\n              transforms.push({\n                sid: child.getAttribute('sid'),\n                type: child.nodeName,\n                obj: _vector\n              });\n              break;\n            case 'rotate':\n              array = parseFloats(child.textContent);\n              _vector = new Vector3().fromArray(array);\n              var angle = MathUtils.degToRad(array[3]);\n              transforms.push({\n                sid: child.getAttribute('sid'),\n                type: child.nodeName,\n                obj: _vector,\n                angle: angle\n              });\n              break;\n          }\n        }\n        return transforms;\n      } // nodes\n\n      function prepareNodes(xml) {\n        var elements = xml.getElementsByTagName('node'); // ensure all node elements have id attributes\n\n        for (var i = 0; i < elements.length; i++) {\n          var element = elements[i];\n          if (element.hasAttribute('id') === false) {\n            element.setAttribute('id', generateId());\n          }\n        }\n      }\n      var matrix = new Matrix4();\n      var vector = new Vector3();\n      function parseNode(xml) {\n        var data = {\n          name: xml.getAttribute('name') || '',\n          type: xml.getAttribute('type'),\n          id: xml.getAttribute('id'),\n          sid: xml.getAttribute('sid'),\n          matrix: new Matrix4(),\n          nodes: [],\n          instanceCameras: [],\n          instanceControllers: [],\n          instanceLights: [],\n          instanceGeometries: [],\n          instanceNodes: [],\n          transforms: {}\n        };\n        for (var i = 0; i < xml.childNodes.length; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          var array = void 0;\n          switch (child.nodeName) {\n            case 'node':\n              data.nodes.push(child.getAttribute('id'));\n              parseNode(child);\n              break;\n            case 'instance_camera':\n              data.instanceCameras.push(parseId(child.getAttribute('url')));\n              break;\n            case 'instance_controller':\n              data.instanceControllers.push(parseNodeInstance(child));\n              break;\n            case 'instance_light':\n              data.instanceLights.push(parseId(child.getAttribute('url')));\n              break;\n            case 'instance_geometry':\n              data.instanceGeometries.push(parseNodeInstance(child));\n              break;\n            case 'instance_node':\n              data.instanceNodes.push(parseId(child.getAttribute('url')));\n              break;\n            case 'matrix':\n              array = parseFloats(child.textContent);\n              data.matrix.multiply(matrix.fromArray(array).transpose());\n              data.transforms[child.getAttribute('sid')] = child.nodeName;\n              break;\n            case 'translate':\n              array = parseFloats(child.textContent);\n              vector.fromArray(array);\n              data.matrix.multiply(matrix.makeTranslation(vector.x, vector.y, vector.z));\n              data.transforms[child.getAttribute('sid')] = child.nodeName;\n              break;\n            case 'rotate':\n              array = parseFloats(child.textContent);\n              var angle = MathUtils.degToRad(array[3]);\n              data.matrix.multiply(matrix.makeRotationAxis(vector.fromArray(array), angle));\n              data.transforms[child.getAttribute('sid')] = child.nodeName;\n              break;\n            case 'scale':\n              array = parseFloats(child.textContent);\n              data.matrix.scale(vector.fromArray(array));\n              data.transforms[child.getAttribute('sid')] = child.nodeName;\n              break;\n            case 'extra':\n              break;\n            default:\n              console.log(child);\n          }\n        }\n        if (hasNode(data.id)) {\n          console.warn('THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.', data.id);\n        } else {\n          library.nodes[data.id] = data;\n        }\n        return data;\n      }\n      function parseNodeInstance(xml) {\n        var data = {\n          id: parseId(xml.getAttribute('url')),\n          materials: {},\n          skeletons: []\n        };\n        for (var i = 0; i < xml.childNodes.length; i++) {\n          var child = xml.childNodes[i];\n          switch (child.nodeName) {\n            case 'bind_material':\n              var instances = child.getElementsByTagName('instance_material');\n              for (var j = 0; j < instances.length; j++) {\n                var instance = instances[j];\n                var symbol = instance.getAttribute('symbol');\n                var target = instance.getAttribute('target');\n                data.materials[symbol] = parseId(target);\n              }\n              break;\n            case 'skeleton':\n              data.skeletons.push(parseId(child.textContent));\n              break;\n          }\n        }\n        return data;\n      }\n      function buildSkeleton(skeletons, joints) {\n        var boneData = [];\n        var sortedBoneData = [];\n        var i, j, data; // a skeleton can have multiple root bones. collada expresses this\n        // situtation with multiple \"skeleton\" tags per controller instance\n\n        for (i = 0; i < skeletons.length; i++) {\n          var skeleton = skeletons[i];\n          var root = void 0;\n          if (hasNode(skeleton)) {\n            root = getNode(skeleton);\n            buildBoneHierarchy(root, joints, boneData);\n          } else if (hasVisualScene(skeleton)) {\n            // handle case where the skeleton refers to the visual scene (#13335)\n            var visualScene = library.visualScenes[skeleton];\n            var children = visualScene.children;\n            for (var _j = 0; _j < children.length; _j++) {\n              var child = children[_j];\n              if (child.type === 'JOINT') {\n                var _root = getNode(child.id);\n                buildBoneHierarchy(_root, joints, boneData);\n              }\n            }\n          } else {\n            console.error('THREE.ColladaLoader: Unable to find root bone of skeleton with ID:', skeleton);\n          }\n        } // sort bone data (the order is defined in the corresponding controller)\n\n        for (i = 0; i < joints.length; i++) {\n          for (j = 0; j < boneData.length; j++) {\n            data = boneData[j];\n            if (data.bone.name === joints[i].name) {\n              sortedBoneData[i] = data;\n              data.processed = true;\n              break;\n            }\n          }\n        } // add unprocessed bone data at the end of the list\n\n        for (i = 0; i < boneData.length; i++) {\n          data = boneData[i];\n          if (data.processed === false) {\n            sortedBoneData.push(data);\n            data.processed = true;\n          }\n        } // setup arrays for skeleton creation\n\n        var bones = [];\n        var boneInverses = [];\n        for (i = 0; i < sortedBoneData.length; i++) {\n          data = sortedBoneData[i];\n          bones.push(data.bone);\n          boneInverses.push(data.boneInverse);\n        }\n        return new Skeleton(bones, boneInverses);\n      }\n      function buildBoneHierarchy(root, joints, boneData) {\n        // setup bone data from visual scene\n        root.traverse(function (object) {\n          if (object.isBone === true) {\n            var boneInverse; // retrieve the boneInverse from the controller data\n\n            for (var i = 0; i < joints.length; i++) {\n              var joint = joints[i];\n              if (joint.name === object.name) {\n                boneInverse = joint.boneInverse;\n                break;\n              }\n            }\n            if (boneInverse === undefined) {\n              // Unfortunately, there can be joints in the visual scene that are not part of the\n              // corresponding controller. In this case, we have to create a dummy boneInverse matrix\n              // for the respective bone. This bone won't affect any vertices, because there are no skin indices\n              // and weights defined for it. But we still have to add the bone to the sorted bone list in order to\n              // ensure a correct animation of the model.\n              boneInverse = new Matrix4();\n            }\n            boneData.push({\n              bone: object,\n              boneInverse: boneInverse,\n              processed: false\n            });\n          }\n        });\n      }\n      function buildNode(data) {\n        var objects = [];\n        var matrix = data.matrix;\n        var nodes = data.nodes;\n        var type = data.type;\n        var instanceCameras = data.instanceCameras;\n        var instanceControllers = data.instanceControllers;\n        var instanceLights = data.instanceLights;\n        var instanceGeometries = data.instanceGeometries;\n        var instanceNodes = data.instanceNodes; // nodes\n\n        for (var i = 0, l = nodes.length; i < l; i++) {\n          objects.push(getNode(nodes[i]));\n        } // instance cameras\n\n        for (var _i3 = 0, _l2 = instanceCameras.length; _i3 < _l2; _i3++) {\n          var instanceCamera = getCamera(instanceCameras[_i3]);\n          if (instanceCamera !== null) {\n            objects.push(instanceCamera.clone());\n          }\n        } // instance controllers\n\n        for (var _i4 = 0, _l3 = instanceControllers.length; _i4 < _l3; _i4++) {\n          var instance = instanceControllers[_i4];\n          var controller = getController(instance.id);\n          var geometries = getGeometry(controller.id);\n          var newObjects = buildObjects(geometries, instance.materials);\n          var skeletons = instance.skeletons;\n          var joints = controller.skin.joints;\n          var skeleton = buildSkeleton(skeletons, joints);\n          for (var j = 0, jl = newObjects.length; j < jl; j++) {\n            var _object = newObjects[j];\n            if (_object.isSkinnedMesh) {\n              _object.bind(skeleton, controller.skin.bindMatrix);\n              _object.normalizeSkinWeights();\n            }\n            objects.push(_object);\n          }\n        } // instance lights\n\n        for (var _i5 = 0, _l4 = instanceLights.length; _i5 < _l4; _i5++) {\n          var instanceLight = getLight(instanceLights[_i5]);\n          if (instanceLight !== null) {\n            objects.push(instanceLight.clone());\n          }\n        } // instance geometries\n\n        for (var _i6 = 0, _l5 = instanceGeometries.length; _i6 < _l5; _i6++) {\n          var _instance = instanceGeometries[_i6]; // a single geometry instance in collada can lead to multiple object3Ds.\n          // this is the case when primitives are combined like triangles and lines\n\n          var _geometries = getGeometry(_instance.id);\n          var _newObjects = buildObjects(_geometries, _instance.materials);\n          for (var _j2 = 0, _jl = _newObjects.length; _j2 < _jl; _j2++) {\n            objects.push(_newObjects[_j2]);\n          }\n        } // instance nodes\n\n        for (var _i7 = 0, _l6 = instanceNodes.length; _i7 < _l6; _i7++) {\n          objects.push(getNode(instanceNodes[_i7]).clone());\n        }\n        var object;\n        if (nodes.length === 0 && objects.length === 1) {\n          object = objects[0];\n        } else {\n          object = type === 'JOINT' ? new Bone() : new Group();\n          for (var _i8 = 0; _i8 < objects.length; _i8++) {\n            object.add(objects[_i8]);\n          }\n        }\n        object.name = type === 'JOINT' ? data.sid : data.name;\n        object.matrix.copy(matrix);\n        object.matrix.decompose(object.position, object.quaternion, object.scale);\n        return object;\n      }\n      var fallbackMaterial = new MeshBasicMaterial({\n        color: 0xff00ff\n      });\n      function resolveMaterialBinding(keys, instanceMaterials) {\n        var materials = [];\n        for (var i = 0, l = keys.length; i < l; i++) {\n          var id = instanceMaterials[keys[i]];\n          if (id === undefined) {\n            console.warn('THREE.ColladaLoader: Material with key %s not found. Apply fallback material.', keys[i]);\n            materials.push(fallbackMaterial);\n          } else {\n            materials.push(getMaterial(id));\n          }\n        }\n        return materials;\n      }\n      function buildObjects(geometries, instanceMaterials) {\n        var objects = [];\n        for (var type in geometries) {\n          var geometry = geometries[type];\n          var materials = resolveMaterialBinding(geometry.materialKeys, instanceMaterials); // handle case if no materials are defined\n\n          if (materials.length === 0) {\n            if (type === 'lines' || type === 'linestrips') {\n              materials.push(new LineBasicMaterial());\n            } else {\n              materials.push(new MeshPhongMaterial());\n            }\n          } // regard skinning\n\n          var skinning = geometry.data.attributes.skinIndex !== undefined; // choose between a single or multi materials (material array)\n\n          var material = materials.length === 1 ? materials[0] : materials; // now create a specific 3D object\n\n          var object = void 0;\n          switch (type) {\n            case 'lines':\n              object = new LineSegments(geometry.data, material);\n              break;\n            case 'linestrips':\n              object = new Line(geometry.data, material);\n              break;\n            case 'triangles':\n            case 'polylist':\n              if (skinning) {\n                object = new SkinnedMesh(geometry.data, material);\n              } else {\n                object = new Mesh(geometry.data, material);\n              }\n              break;\n          }\n          objects.push(object);\n        }\n        return objects;\n      }\n      function hasNode(id) {\n        return library.nodes[id] !== undefined;\n      }\n      function getNode(id) {\n        return getBuild(library.nodes[id], buildNode);\n      } // visual scenes\n\n      function parseVisualScene(xml) {\n        var data = {\n          name: xml.getAttribute('name'),\n          children: []\n        };\n        prepareNodes(xml);\n        var elements = getElementsByTagName(xml, 'node');\n        for (var i = 0; i < elements.length; i++) {\n          data.children.push(parseNode(elements[i]));\n        }\n        library.visualScenes[xml.getAttribute('id')] = data;\n      }\n      function buildVisualScene(data) {\n        var group = new Group();\n        group.name = data.name;\n        var children = data.children;\n        for (var i = 0; i < children.length; i++) {\n          var child = children[i];\n          group.add(getNode(child.id));\n        }\n        return group;\n      }\n      function hasVisualScene(id) {\n        return library.visualScenes[id] !== undefined;\n      }\n      function getVisualScene(id) {\n        return getBuild(library.visualScenes[id], buildVisualScene);\n      } // scenes\n\n      function parseScene(xml) {\n        var instance = getElementsByTagName(xml, 'instance_visual_scene')[0];\n        return getVisualScene(parseId(instance.getAttribute('url')));\n      }\n      function setupAnimations() {\n        var clips = library.clips;\n        if (isEmpty(clips) === true) {\n          if (isEmpty(library.animations) === false) {\n            // if there are animations but no clips, we create a default clip for playback\n            var tracks = [];\n            for (var id in library.animations) {\n              var animationTracks = getAnimation(id);\n              for (var i = 0, l = animationTracks.length; i < l; i++) {\n                tracks.push(animationTracks[i]);\n              }\n            }\n            animations.push(new AnimationClip('default', -1, tracks));\n          }\n        } else {\n          for (var _id in clips) {\n            animations.push(getAnimationClip(_id));\n          }\n        }\n      } // convert the parser error element into text with each child elements text\n      // separated by new lines.\n\n      function parserErrorToText(parserError) {\n        var result = '';\n        var stack = [parserError];\n        while (stack.length) {\n          var node = stack.shift();\n          if (node.nodeType === Node.TEXT_NODE) {\n            result += node.textContent;\n          } else {\n            result += '\\n';\n            stack.push.apply(stack, node.childNodes);\n          }\n        }\n        return result.trim();\n      }\n      if (text.length === 0) {\n        return {\n          scene: new Scene()\n        };\n      }\n      var xml = new DOMParser().parseFromString(text, 'application/xml');\n      var collada = getElementsByTagName(xml, 'COLLADA')[0];\n      var parserError = xml.getElementsByTagName('parsererror')[0];\n      if (parserError !== undefined) {\n        // Chrome will return parser error with a div in it\n        var errorElement = getElementsByTagName(parserError, 'div')[0];\n        var errorText;\n        if (errorElement) {\n          errorText = errorElement.textContent;\n        } else {\n          errorText = parserErrorToText(parserError);\n        }\n        console.error('THREE.ColladaLoader: Failed to parse collada file.\\n', errorText);\n        return null;\n      } // metadata\n\n      var version = collada.getAttribute('version');\n      console.log('THREE.ColladaLoader: File version', version);\n      var asset = parseAsset(getElementsByTagName(collada, 'asset')[0]);\n      var textureLoader = new TextureLoader(this.manager);\n      textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n      var tgaLoader;\n      if (TGALoader) {\n        tgaLoader = new TGALoader(this.manager);\n        tgaLoader.setPath(this.resourcePath || path);\n      } //\n\n      var animations = [];\n      var kinematics = {};\n      var count = 0; //\n\n      var library = {\n        animations: {},\n        clips: {},\n        controllers: {},\n        images: {},\n        effects: {},\n        materials: {},\n        cameras: {},\n        lights: {},\n        geometries: {},\n        nodes: {},\n        visualScenes: {},\n        kinematicsModels: {},\n        physicsModels: {},\n        kinematicsScenes: {}\n      };\n      parseLibrary(collada, 'library_animations', 'animation', parseAnimation);\n      parseLibrary(collada, 'library_animation_clips', 'animation_clip', parseAnimationClip);\n      parseLibrary(collada, 'library_controllers', 'controller', parseController);\n      parseLibrary(collada, 'library_images', 'image', parseImage);\n      parseLibrary(collada, 'library_effects', 'effect', parseEffect);\n      parseLibrary(collada, 'library_materials', 'material', parseMaterial);\n      parseLibrary(collada, 'library_cameras', 'camera', parseCamera);\n      parseLibrary(collada, 'library_lights', 'light', parseLight);\n      parseLibrary(collada, 'library_geometries', 'geometry', parseGeometry);\n      parseLibrary(collada, 'library_nodes', 'node', parseNode);\n      parseLibrary(collada, 'library_visual_scenes', 'visual_scene', parseVisualScene);\n      parseLibrary(collada, 'library_kinematics_models', 'kinematics_model', parseKinematicsModel);\n      parseLibrary(collada, 'library_physics_models', 'physics_model', parsePhysicsModel);\n      parseLibrary(collada, 'scene', 'instance_kinematics_scene', parseKinematicsScene);\n      buildLibrary(library.animations, buildAnimation);\n      buildLibrary(library.clips, buildAnimationClip);\n      buildLibrary(library.controllers, buildController);\n      buildLibrary(library.images, buildImage);\n      buildLibrary(library.effects, buildEffect);\n      buildLibrary(library.materials, buildMaterial);\n      buildLibrary(library.cameras, buildCamera);\n      buildLibrary(library.lights, buildLight);\n      buildLibrary(library.geometries, buildGeometry);\n      buildLibrary(library.visualScenes, buildVisualScene);\n      setupAnimations();\n      setupKinematics();\n      var scene = parseScene(getElementsByTagName(collada, 'scene')[0]);\n      scene.animations = animations;\n      if (asset.upAxis === 'Z_UP') {\n        scene.quaternion.setFromEuler(new Euler(-Math.PI / 2, 0, 0));\n      }\n      scene.scale.multiplyScalar(asset.unit);\n      return {\n        get animations() {\n          console.warn('THREE.ColladaLoader: Please access animations over scene.animations now.');\n          return animations;\n        },\n        kinematics: kinematics,\n        library: library,\n        scene: scene\n      };\n    }\n  }]);\n  return ColladaLoader;\n}(Loader);\nexport { ColladaLoader };","map":{"version":3,"names":["Loader","LoaderUtils","FileLoader","Vector3","Quaternion","Matrix4","MeshBasicMaterial","Scene","TextureLoader","Euler","MathUtils","AnimationClip","VectorKeyframeTrack","QuaternionKeyframeTrack","MeshLambertMaterial","MeshPhongMaterial","Vector2","DoubleSide","FrontSide","PerspectiveCamera","OrthographicCamera","Color","AmbientLight","SpotLight","PointLight","DirectionalLight","BufferGeometry","Float32BufferAttribute","Skeleton","Bone","Group","LineBasicMaterial","SkinnedMesh","Mesh","Line","LineSegments","RepeatWrapping","ClampToEdgeWrapping","TGALoader","ColladaLoader","_Loader","_inherits","_super","_createSuper","manager","_classCallCheck","call","_createClass","key","value","load","url","onLoad","onProgress","onError","scope","path","extractUrlBase","loader","setPath","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","getElementsByTagName","xml","name","array","childNodes","i","l","length","child","nodeName","push","parseStrings","parts","trim","split","Array","parseFloats","parseFloat","parseInts","parseInt","parseId","substring","generateId","count","isEmpty","object","Object","keys","parseAsset","unit","parseAssetUnit","upAxis","parseAssetUpAxis","undefined","hasAttribute","getAttribute","textContent","parseLibrary","libraryName","parser","library","elements","buildLibrary","data","builder","build","getBuild","parseAnimation","sources","samplers","channels","hasChildren","nodeType","id","parseSource","parseAnimationSampler","parseAnimationChannel","log","animations","generateUUID","inputs","semantic","target","shift","sid","arraySyntax","indexOf","memberSyntax","member","indices","replace","sampler","buildAnimation","tracks","hasOwnProperty","channel","inputId","INPUT","outputId","OUTPUT","inputSource","outputSource","animation","buildAnimationChannel","createKeyframeTracks","getAnimation","node","nodes","object3D","getNode","transform","transforms","defaultMatrix","matrix","clone","transpose","time","stride","il","j","jl","index","warn","keyframes","prepareAnimationData","uuid","sort","ascending","transformAnimationData","a","b","position","scale","quaternion","times","positionData","quaternionData","scaleData","keyframe","fromArray","decompose","x","y","z","w","property","defaultValue","empty","createMissingKeyframes","prev","next","getPrev","getNext","interpolate","parseAnimationClip","start","end","clips","buildAnimationClip","duration","animationTracks","getAnimationClip","parseController","skin","parseSkin","controllers","bindShapeMatrix","joints","parseJoints","vertexWeights","parseVertexWeights","offset","vcount","v","buildController","geometry","geometries","buildSkin","skinIndices","skinWeights","weights","BONE_LIMIT","jointOffset","JOINT","weightOffset","WEIGHT","jointSource","inverseSource","INV_BIND_MATRIX","jointCount","vertexSkinData","skinIndex","weightId","skinWeight","weight","descending","d","bindMatrix","identity","boneInverse","getController","parseImage","init_from","images","buildImage","getImage","parseEffect","profile","parseEffectProfileCOMMON","effects","surfaces","parseEffectNewparam","technique","parseEffectTechnique","extra","parseEffectExtra","parseEffectSurface","parseEffectSampler","source","type","parameters","parseEffectParameters","parseEffectParameter","opaque","parseEffectParameterTexture","parseEffectParameterTextureExtra","parseEffectParameterTextureExtraTechnique","toUpperCase","parseEffectExtraTechniqueBump","parseEffectExtraTechnique","texcoord","buildEffect","getEffect","parseMaterial","materials","getTextureLoader","image","extension","slice","lastIndexOf","toLowerCase","tgaLoader","textureLoader","buildMaterial","effect","material","getTexture","textureObject","surface","texture","wrapS","wrapU","wrapT","wrapV","set","offsetU","offsetV","repeat","repeatU","repeatV","parameter","color","map","specular","specularMap","normalMap","lightMap","float","shininess","emissive","emissiveMap","transparent","transparency","opacity","techniques","k","side","normalScale","getMaterial","parseCamera","optics","parseCameraOptics","cameras","parseCameraTechnique","parseCameraParameters","buildCamera","camera","yfov","aspect_ratio","znear","zfar","ymag","xmag","aspectRatio","getCamera","parseLight","parseLightTechnique","lights","parseLightParameters","falloffAngle","f","distance","Math","sqrt","buildLight","light","copy","getLight","parseGeometry","vertices","primitives","mesh","parseGeometryVertices","parseGeometryPrimitive","accessor","primitive","hasUV","inputname","max","p","groupPrimitives","checkUVCoordinates","uvsNeedsFix","buildGeometry","groupedPrimitives","primitiveType","buildGeometryType","normal","uv","uv2","materialKeys","g","vc","addGroup","input","prevLength","buildGeometryData","setAttribute","pushVector","sourceStride","sourceArray","c","kl","getGeometry","parseKinematicsModel","links","parseKinematicsTechniqueCommon","kinematicsModels","buildKinematicsModel","getKinematicsModel","parseKinematicsJoint","parseKinematicsLink","parseKinematicsJointParameter","axis","limits","min","static","zeroPosition","middlePosition","attachments","parseKinematicsAttachment","parseKinematicsTransform","joint","pop","obj","angle","degToRad","parsePhysicsModel","rigidBodies","parsePhysicsRigidBody","physicsModels","parsePhysicsTechniqueCommon","inertia","mass","parseKinematicsScene","bindJointAxis","parseKinematicsBindJointAxis","kinematicsScenes","param","tmpJointIndex","jointIndex","substr","buildKinematicsScene","getKinematicsScene","setupKinematics","kinematicsModelId","kinematicsSceneId","visualSceneId","visualScenes","kinematicsModel","kinematicsScene","visualScene","getVisualScene","jointMap","targetElement","collada","querySelector","parentVisualElement","parentElement","connect","visualElement","visualElementName","traverse","buildTransformList","m0","kinematics","getJointValue","jointData","setJointValue","multiply","makeRotationAxis","makeTranslation","vector","prepareNodes","element","parseNode","instanceCameras","instanceControllers","instanceLights","instanceGeometries","instanceNodes","parseNodeInstance","hasNode","skeletons","instances","instance","symbol","buildSkeleton","boneData","sortedBoneData","skeleton","root","buildBoneHierarchy","hasVisualScene","children","bone","processed","bones","boneInverses","isBone","buildNode","objects","instanceCamera","controller","newObjects","buildObjects","isSkinnedMesh","bind","normalizeSkinWeights","instanceLight","add","fallbackMaterial","resolveMaterialBinding","instanceMaterials","skinning","attributes","parseVisualScene","buildVisualScene","group","parseScene","setupAnimations","parserErrorToText","parserError","result","stack","Node","TEXT_NODE","apply","scene","DOMParser","parseFromString","errorElement","errorText","version","asset","resourcePath","setCrossOrigin","crossOrigin","setFromEuler","PI","multiplyScalar"],"sources":["/home/samuel/experiment/3d/farm/frontend/node_modules/three-stdlib/loaders/ColladaLoader.js"],"sourcesContent":["import { Loader, LoaderUtils, FileLoader, Vector3, Quaternion, Matrix4, MeshBasicMaterial, Scene, TextureLoader, Euler, MathUtils, AnimationClip, VectorKeyframeTrack, QuaternionKeyframeTrack, MeshLambertMaterial, MeshPhongMaterial, Vector2, DoubleSide, FrontSide, PerspectiveCamera, OrthographicCamera, Color, AmbientLight, SpotLight, PointLight, DirectionalLight, BufferGeometry, Float32BufferAttribute, Skeleton, Bone, Group, LineBasicMaterial, SkinnedMesh, Mesh, Line, LineSegments, RepeatWrapping, ClampToEdgeWrapping } from 'three';\nimport { TGALoader } from './TGALoader.js';\n\nclass ColladaLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const path = scope.path === '' ? LoaderUtils.extractUrlBase(url) : scope.path;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text, path));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n\n  parse(text, path) {\n    function getElementsByTagName(xml, name) {\n      // Non recursive xml.getElementsByTagName() ...\n      const array = [];\n      const childNodes = xml.childNodes;\n\n      for (let i = 0, l = childNodes.length; i < l; i++) {\n        const child = childNodes[i];\n\n        if (child.nodeName === name) {\n          array.push(child);\n        }\n      }\n\n      return array;\n    }\n\n    function parseStrings(text) {\n      if (text.length === 0) return [];\n      const parts = text.trim().split(/\\s+/);\n      const array = new Array(parts.length);\n\n      for (let i = 0, l = parts.length; i < l; i++) {\n        array[i] = parts[i];\n      }\n\n      return array;\n    }\n\n    function parseFloats(text) {\n      if (text.length === 0) return [];\n      const parts = text.trim().split(/\\s+/);\n      const array = new Array(parts.length);\n\n      for (let i = 0, l = parts.length; i < l; i++) {\n        array[i] = parseFloat(parts[i]);\n      }\n\n      return array;\n    }\n\n    function parseInts(text) {\n      if (text.length === 0) return [];\n      const parts = text.trim().split(/\\s+/);\n      const array = new Array(parts.length);\n\n      for (let i = 0, l = parts.length; i < l; i++) {\n        array[i] = parseInt(parts[i]);\n      }\n\n      return array;\n    }\n\n    function parseId(text) {\n      return text.substring(1);\n    }\n\n    function generateId() {\n      return 'three_default_' + count++;\n    }\n\n    function isEmpty(object) {\n      return Object.keys(object).length === 0;\n    } // asset\n\n\n    function parseAsset(xml) {\n      return {\n        unit: parseAssetUnit(getElementsByTagName(xml, 'unit')[0]),\n        upAxis: parseAssetUpAxis(getElementsByTagName(xml, 'up_axis')[0])\n      };\n    }\n\n    function parseAssetUnit(xml) {\n      if (xml !== undefined && xml.hasAttribute('meter') === true) {\n        return parseFloat(xml.getAttribute('meter'));\n      } else {\n        return 1; // default 1 meter\n      }\n    }\n\n    function parseAssetUpAxis(xml) {\n      return xml !== undefined ? xml.textContent : 'Y_UP';\n    } // library\n\n\n    function parseLibrary(xml, libraryName, nodeName, parser) {\n      const library = getElementsByTagName(xml, libraryName)[0];\n\n      if (library !== undefined) {\n        const elements = getElementsByTagName(library, nodeName);\n\n        for (let i = 0; i < elements.length; i++) {\n          parser(elements[i]);\n        }\n      }\n    }\n\n    function buildLibrary(data, builder) {\n      for (const name in data) {\n        const object = data[name];\n        object.build = builder(data[name]);\n      }\n    } // get\n\n\n    function getBuild(data, builder) {\n      if (data.build !== undefined) return data.build;\n      data.build = builder(data);\n      return data.build;\n    } // animation\n\n\n    function parseAnimation(xml) {\n      const data = {\n        sources: {},\n        samplers: {},\n        channels: {}\n      };\n      let hasChildren = false;\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        let id;\n\n        switch (child.nodeName) {\n          case 'source':\n            id = child.getAttribute('id');\n            data.sources[id] = parseSource(child);\n            break;\n\n          case 'sampler':\n            id = child.getAttribute('id');\n            data.samplers[id] = parseAnimationSampler(child);\n            break;\n\n          case 'channel':\n            id = child.getAttribute('target');\n            data.channels[id] = parseAnimationChannel(child);\n            break;\n\n          case 'animation':\n            // hierarchy of related animations\n            parseAnimation(child);\n            hasChildren = true;\n            break;\n\n          default:\n            console.log(child);\n        }\n      }\n\n      if (hasChildren === false) {\n        // since 'id' attributes can be optional, it's necessary to generate a UUID for unqiue assignment\n        library.animations[xml.getAttribute('id') || MathUtils.generateUUID()] = data;\n      }\n    }\n\n    function parseAnimationSampler(xml) {\n      const data = {\n        inputs: {}\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'input':\n            const id = parseId(child.getAttribute('source'));\n            const semantic = child.getAttribute('semantic');\n            data.inputs[semantic] = id;\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseAnimationChannel(xml) {\n      const data = {};\n      const target = xml.getAttribute('target'); // parsing SID Addressing Syntax\n\n      let parts = target.split('/');\n      const id = parts.shift();\n      let sid = parts.shift(); // check selection syntax\n\n      const arraySyntax = sid.indexOf('(') !== -1;\n      const memberSyntax = sid.indexOf('.') !== -1;\n\n      if (memberSyntax) {\n        //  member selection access\n        parts = sid.split('.');\n        sid = parts.shift();\n        data.member = parts.shift();\n      } else if (arraySyntax) {\n        // array-access syntax. can be used to express fields in one-dimensional vectors or two-dimensional matrices.\n        const indices = sid.split('(');\n        sid = indices.shift();\n\n        for (let i = 0; i < indices.length; i++) {\n          indices[i] = parseInt(indices[i].replace(/\\)/, ''));\n        }\n\n        data.indices = indices;\n      }\n\n      data.id = id;\n      data.sid = sid;\n      data.arraySyntax = arraySyntax;\n      data.memberSyntax = memberSyntax;\n      data.sampler = parseId(xml.getAttribute('source'));\n      return data;\n    }\n\n    function buildAnimation(data) {\n      const tracks = [];\n      const channels = data.channels;\n      const samplers = data.samplers;\n      const sources = data.sources;\n\n      for (const target in channels) {\n        if (channels.hasOwnProperty(target)) {\n          const channel = channels[target];\n          const sampler = samplers[channel.sampler];\n          const inputId = sampler.inputs.INPUT;\n          const outputId = sampler.inputs.OUTPUT;\n          const inputSource = sources[inputId];\n          const outputSource = sources[outputId];\n          const animation = buildAnimationChannel(channel, inputSource, outputSource);\n          createKeyframeTracks(animation, tracks);\n        }\n      }\n\n      return tracks;\n    }\n\n    function getAnimation(id) {\n      return getBuild(library.animations[id], buildAnimation);\n    }\n\n    function buildAnimationChannel(channel, inputSource, outputSource) {\n      const node = library.nodes[channel.id];\n      const object3D = getNode(node.id);\n      const transform = node.transforms[channel.sid];\n      const defaultMatrix = node.matrix.clone().transpose();\n      let time, stride;\n      let i, il, j, jl;\n      const data = {}; // the collada spec allows the animation of data in various ways.\n      // depending on the transform type (matrix, translate, rotate, scale), we execute different logic\n\n      switch (transform) {\n        case 'matrix':\n          for (i = 0, il = inputSource.array.length; i < il; i++) {\n            time = inputSource.array[i];\n            stride = i * outputSource.stride;\n            if (data[time] === undefined) data[time] = {};\n\n            if (channel.arraySyntax === true) {\n              const value = outputSource.array[stride];\n              const index = channel.indices[0] + 4 * channel.indices[1];\n              data[time][index] = value;\n            } else {\n              for (j = 0, jl = outputSource.stride; j < jl; j++) {\n                data[time][j] = outputSource.array[stride + j];\n              }\n            }\n          }\n\n          break;\n\n        case 'translate':\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n          break;\n\n        case 'rotate':\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n          break;\n\n        case 'scale':\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n          break;\n      }\n\n      const keyframes = prepareAnimationData(data, defaultMatrix);\n      const animation = {\n        name: object3D.uuid,\n        keyframes: keyframes\n      };\n      return animation;\n    }\n\n    function prepareAnimationData(data, defaultMatrix) {\n      const keyframes = []; // transfer data into a sortable array\n\n      for (const time in data) {\n        keyframes.push({\n          time: parseFloat(time),\n          value: data[time]\n        });\n      } // ensure keyframes are sorted by time\n\n\n      keyframes.sort(ascending); // now we clean up all animation data, so we can use them for keyframe tracks\n\n      for (let i = 0; i < 16; i++) {\n        transformAnimationData(keyframes, i, defaultMatrix.elements[i]);\n      }\n\n      return keyframes; // array sort function\n\n      function ascending(a, b) {\n        return a.time - b.time;\n      }\n    }\n\n    const position = new Vector3();\n    const scale = new Vector3();\n    const quaternion = new Quaternion();\n\n    function createKeyframeTracks(animation, tracks) {\n      const keyframes = animation.keyframes;\n      const name = animation.name;\n      const times = [];\n      const positionData = [];\n      const quaternionData = [];\n      const scaleData = [];\n\n      for (let i = 0, l = keyframes.length; i < l; i++) {\n        const keyframe = keyframes[i];\n        const time = keyframe.time;\n        const value = keyframe.value;\n        matrix.fromArray(value).transpose();\n        matrix.decompose(position, quaternion, scale);\n        times.push(time);\n        positionData.push(position.x, position.y, position.z);\n        quaternionData.push(quaternion.x, quaternion.y, quaternion.z, quaternion.w);\n        scaleData.push(scale.x, scale.y, scale.z);\n      }\n\n      if (positionData.length > 0) tracks.push(new VectorKeyframeTrack(name + '.position', times, positionData));\n\n      if (quaternionData.length > 0) {\n        tracks.push(new QuaternionKeyframeTrack(name + '.quaternion', times, quaternionData));\n      }\n\n      if (scaleData.length > 0) tracks.push(new VectorKeyframeTrack(name + '.scale', times, scaleData));\n      return tracks;\n    }\n\n    function transformAnimationData(keyframes, property, defaultValue) {\n      let keyframe;\n      let empty = true;\n      let i, l; // check, if values of a property are missing in our keyframes\n\n      for (i = 0, l = keyframes.length; i < l; i++) {\n        keyframe = keyframes[i];\n\n        if (keyframe.value[property] === undefined) {\n          keyframe.value[property] = null; // mark as missing\n        } else {\n          empty = false;\n        }\n      }\n\n      if (empty === true) {\n        // no values at all, so we set a default value\n        for (i = 0, l = keyframes.length; i < l; i++) {\n          keyframe = keyframes[i];\n          keyframe.value[property] = defaultValue;\n        }\n      } else {\n        // filling gaps\n        createMissingKeyframes(keyframes, property);\n      }\n    }\n\n    function createMissingKeyframes(keyframes, property) {\n      let prev, next;\n\n      for (let i = 0, l = keyframes.length; i < l; i++) {\n        const keyframe = keyframes[i];\n\n        if (keyframe.value[property] === null) {\n          prev = getPrev(keyframes, i, property);\n          next = getNext(keyframes, i, property);\n\n          if (prev === null) {\n            keyframe.value[property] = next.value[property];\n            continue;\n          }\n\n          if (next === null) {\n            keyframe.value[property] = prev.value[property];\n            continue;\n          }\n\n          interpolate(keyframe, prev, next, property);\n        }\n      }\n    }\n\n    function getPrev(keyframes, i, property) {\n      while (i >= 0) {\n        const keyframe = keyframes[i];\n        if (keyframe.value[property] !== null) return keyframe;\n        i--;\n      }\n\n      return null;\n    }\n\n    function getNext(keyframes, i, property) {\n      while (i < keyframes.length) {\n        const keyframe = keyframes[i];\n        if (keyframe.value[property] !== null) return keyframe;\n        i++;\n      }\n\n      return null;\n    }\n\n    function interpolate(key, prev, next, property) {\n      if (next.time - prev.time === 0) {\n        key.value[property] = prev.value[property];\n        return;\n      }\n\n      key.value[property] = (key.time - prev.time) * (next.value[property] - prev.value[property]) / (next.time - prev.time) + prev.value[property];\n    } // animation clips\n\n\n    function parseAnimationClip(xml) {\n      const data = {\n        name: xml.getAttribute('id') || 'default',\n        start: parseFloat(xml.getAttribute('start') || 0),\n        end: parseFloat(xml.getAttribute('end') || 0),\n        animations: []\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'instance_animation':\n            data.animations.push(parseId(child.getAttribute('url')));\n            break;\n        }\n      }\n\n      library.clips[xml.getAttribute('id')] = data;\n    }\n\n    function buildAnimationClip(data) {\n      const tracks = [];\n      const name = data.name;\n      const duration = data.end - data.start || -1;\n      const animations = data.animations;\n\n      for (let i = 0, il = animations.length; i < il; i++) {\n        const animationTracks = getAnimation(animations[i]);\n\n        for (let j = 0, jl = animationTracks.length; j < jl; j++) {\n          tracks.push(animationTracks[j]);\n        }\n      }\n\n      return new AnimationClip(name, duration, tracks);\n    }\n\n    function getAnimationClip(id) {\n      return getBuild(library.clips[id], buildAnimationClip);\n    } // controller\n\n\n    function parseController(xml) {\n      const data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'skin':\n            // there is exactly one skin per controller\n            data.id = parseId(child.getAttribute('source'));\n            data.skin = parseSkin(child);\n            break;\n\n          case 'morph':\n            data.id = parseId(child.getAttribute('source'));\n            console.warn('THREE.ColladaLoader: Morph target animation not supported yet.');\n            break;\n        }\n      }\n\n      library.controllers[xml.getAttribute('id')] = data;\n    }\n\n    function parseSkin(xml) {\n      const data = {\n        sources: {}\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'bind_shape_matrix':\n            data.bindShapeMatrix = parseFloats(child.textContent);\n            break;\n\n          case 'source':\n            const id = child.getAttribute('id');\n            data.sources[id] = parseSource(child);\n            break;\n\n          case 'joints':\n            data.joints = parseJoints(child);\n            break;\n\n          case 'vertex_weights':\n            data.vertexWeights = parseVertexWeights(child);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseJoints(xml) {\n      const data = {\n        inputs: {}\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'input':\n            const semantic = child.getAttribute('semantic');\n            const id = parseId(child.getAttribute('source'));\n            data.inputs[semantic] = id;\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseVertexWeights(xml) {\n      const data = {\n        inputs: {}\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'input':\n            const semantic = child.getAttribute('semantic');\n            const id = parseId(child.getAttribute('source'));\n            const offset = parseInt(child.getAttribute('offset'));\n            data.inputs[semantic] = {\n              id: id,\n              offset: offset\n            };\n            break;\n\n          case 'vcount':\n            data.vcount = parseInts(child.textContent);\n            break;\n\n          case 'v':\n            data.v = parseInts(child.textContent);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function buildController(data) {\n      const build = {\n        id: data.id\n      };\n      const geometry = library.geometries[build.id];\n\n      if (data.skin !== undefined) {\n        build.skin = buildSkin(data.skin); // we enhance the 'sources' property of the corresponding geometry with our skin data\n\n        geometry.sources.skinIndices = build.skin.indices;\n        geometry.sources.skinWeights = build.skin.weights;\n      }\n\n      return build;\n    }\n\n    function buildSkin(data) {\n      const BONE_LIMIT = 4;\n      const build = {\n        joints: [],\n        // this must be an array to preserve the joint order\n        indices: {\n          array: [],\n          stride: BONE_LIMIT\n        },\n        weights: {\n          array: [],\n          stride: BONE_LIMIT\n        }\n      };\n      const sources = data.sources;\n      const vertexWeights = data.vertexWeights;\n      const vcount = vertexWeights.vcount;\n      const v = vertexWeights.v;\n      const jointOffset = vertexWeights.inputs.JOINT.offset;\n      const weightOffset = vertexWeights.inputs.WEIGHT.offset;\n      const jointSource = data.sources[data.joints.inputs.JOINT];\n      const inverseSource = data.sources[data.joints.inputs.INV_BIND_MATRIX];\n      const weights = sources[vertexWeights.inputs.WEIGHT.id].array;\n      let stride = 0;\n      let i, j, l; // procces skin data for each vertex\n\n      for (i = 0, l = vcount.length; i < l; i++) {\n        const jointCount = vcount[i]; // this is the amount of joints that affect a single vertex\n\n        const vertexSkinData = [];\n\n        for (j = 0; j < jointCount; j++) {\n          const skinIndex = v[stride + jointOffset];\n          const weightId = v[stride + weightOffset];\n          const skinWeight = weights[weightId];\n          vertexSkinData.push({\n            index: skinIndex,\n            weight: skinWeight\n          });\n          stride += 2;\n        } // we sort the joints in descending order based on the weights.\n        // this ensures, we only procced the most important joints of the vertex\n\n\n        vertexSkinData.sort(descending); // now we provide for each vertex a set of four index and weight values.\n        // the order of the skin data matches the order of vertices\n\n        for (j = 0; j < BONE_LIMIT; j++) {\n          const d = vertexSkinData[j];\n\n          if (d !== undefined) {\n            build.indices.array.push(d.index);\n            build.weights.array.push(d.weight);\n          } else {\n            build.indices.array.push(0);\n            build.weights.array.push(0);\n          }\n        }\n      } // setup bind matrix\n\n\n      if (data.bindShapeMatrix) {\n        build.bindMatrix = new Matrix4().fromArray(data.bindShapeMatrix).transpose();\n      } else {\n        build.bindMatrix = new Matrix4().identity();\n      } // process bones and inverse bind matrix data\n\n\n      for (i = 0, l = jointSource.array.length; i < l; i++) {\n        const name = jointSource.array[i];\n        const boneInverse = new Matrix4().fromArray(inverseSource.array, i * inverseSource.stride).transpose();\n        build.joints.push({\n          name: name,\n          boneInverse: boneInverse\n        });\n      }\n\n      return build; // array sort function\n\n      function descending(a, b) {\n        return b.weight - a.weight;\n      }\n    }\n\n    function getController(id) {\n      return getBuild(library.controllers[id], buildController);\n    } // image\n\n\n    function parseImage(xml) {\n      const data = {\n        init_from: getElementsByTagName(xml, 'init_from')[0].textContent\n      };\n      library.images[xml.getAttribute('id')] = data;\n    }\n\n    function buildImage(data) {\n      if (data.build !== undefined) return data.build;\n      return data.init_from;\n    }\n\n    function getImage(id) {\n      const data = library.images[id];\n\n      if (data !== undefined) {\n        return getBuild(data, buildImage);\n      }\n\n      console.warn(\"THREE.ColladaLoader: Couldn't find image with ID:\", id);\n      return null;\n    } // effect\n\n\n    function parseEffect(xml) {\n      const data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'profile_COMMON':\n            data.profile = parseEffectProfileCOMMON(child);\n            break;\n        }\n      }\n\n      library.effects[xml.getAttribute('id')] = data;\n    }\n\n    function parseEffectProfileCOMMON(xml) {\n      const data = {\n        surfaces: {},\n        samplers: {}\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'newparam':\n            parseEffectNewparam(child, data);\n            break;\n\n          case 'technique':\n            data.technique = parseEffectTechnique(child);\n            break;\n\n          case 'extra':\n            data.extra = parseEffectExtra(child);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectNewparam(xml, data) {\n      const sid = xml.getAttribute('sid');\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'surface':\n            data.surfaces[sid] = parseEffectSurface(child);\n            break;\n\n          case 'sampler2D':\n            data.samplers[sid] = parseEffectSampler(child);\n            break;\n        }\n      }\n    }\n\n    function parseEffectSurface(xml) {\n      const data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'init_from':\n            data.init_from = child.textContent;\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectSampler(xml) {\n      const data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'source':\n            data.source = child.textContent;\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectTechnique(xml) {\n      const data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'constant':\n          case 'lambert':\n          case 'blinn':\n          case 'phong':\n            data.type = child.nodeName;\n            data.parameters = parseEffectParameters(child);\n            break;\n\n          case 'extra':\n            data.extra = parseEffectExtra(child);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectParameters(xml) {\n      const data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'emission':\n          case 'diffuse':\n          case 'specular':\n          case 'bump':\n          case 'ambient':\n          case 'shininess':\n          case 'transparency':\n            data[child.nodeName] = parseEffectParameter(child);\n            break;\n\n          case 'transparent':\n            data[child.nodeName] = {\n              opaque: child.hasAttribute('opaque') ? child.getAttribute('opaque') : 'A_ONE',\n              data: parseEffectParameter(child)\n            };\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectParameter(xml) {\n      const data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'color':\n            data[child.nodeName] = parseFloats(child.textContent);\n            break;\n\n          case 'float':\n            data[child.nodeName] = parseFloat(child.textContent);\n            break;\n\n          case 'texture':\n            data[child.nodeName] = {\n              id: child.getAttribute('texture'),\n              extra: parseEffectParameterTexture(child)\n            };\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectParameterTexture(xml) {\n      const data = {\n        technique: {}\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'extra':\n            parseEffectParameterTextureExtra(child, data);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectParameterTextureExtra(xml, data) {\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'technique':\n            parseEffectParameterTextureExtraTechnique(child, data);\n            break;\n        }\n      }\n    }\n\n    function parseEffectParameterTextureExtraTechnique(xml, data) {\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'repeatU':\n          case 'repeatV':\n          case 'offsetU':\n          case 'offsetV':\n            data.technique[child.nodeName] = parseFloat(child.textContent);\n            break;\n\n          case 'wrapU':\n          case 'wrapV':\n            // some files have values for wrapU/wrapV which become NaN via parseInt\n            if (child.textContent.toUpperCase() === 'TRUE') {\n              data.technique[child.nodeName] = 1;\n            } else if (child.textContent.toUpperCase() === 'FALSE') {\n              data.technique[child.nodeName] = 0;\n            } else {\n              data.technique[child.nodeName] = parseInt(child.textContent);\n            }\n\n            break;\n\n          case 'bump':\n            data[child.nodeName] = parseEffectExtraTechniqueBump(child);\n            break;\n        }\n      }\n    }\n\n    function parseEffectExtra(xml) {\n      const data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'technique':\n            data.technique = parseEffectExtraTechnique(child);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectExtraTechnique(xml) {\n      const data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'double_sided':\n            data[child.nodeName] = parseInt(child.textContent);\n            break;\n\n          case 'bump':\n            data[child.nodeName] = parseEffectExtraTechniqueBump(child);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectExtraTechniqueBump(xml) {\n      var data = {};\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'texture':\n            data[child.nodeName] = {\n              id: child.getAttribute('texture'),\n              texcoord: child.getAttribute('texcoord'),\n              extra: parseEffectParameterTexture(child)\n            };\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function buildEffect(data) {\n      return data;\n    }\n\n    function getEffect(id) {\n      return getBuild(library.effects[id], buildEffect);\n    } // material\n\n\n    function parseMaterial(xml) {\n      const data = {\n        name: xml.getAttribute('name')\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'instance_effect':\n            data.url = parseId(child.getAttribute('url'));\n            break;\n        }\n      }\n\n      library.materials[xml.getAttribute('id')] = data;\n    }\n\n    function getTextureLoader(image) {\n      let loader;\n      let extension = image.slice((image.lastIndexOf('.') - 1 >>> 0) + 2); // http://www.jstips.co/en/javascript/get-file-extension/\n\n      extension = extension.toLowerCase();\n\n      switch (extension) {\n        case 'tga':\n          loader = tgaLoader;\n          break;\n\n        default:\n          loader = textureLoader;\n      }\n\n      return loader;\n    }\n\n    function buildMaterial(data) {\n      const effect = getEffect(data.url);\n      const technique = effect.profile.technique;\n      let material;\n\n      switch (technique.type) {\n        case 'phong':\n        case 'blinn':\n          material = new MeshPhongMaterial();\n          break;\n\n        case 'lambert':\n          material = new MeshLambertMaterial();\n          break;\n\n        default:\n          material = new MeshBasicMaterial();\n          break;\n      }\n\n      material.name = data.name || '';\n\n      function getTexture(textureObject) {\n        const sampler = effect.profile.samplers[textureObject.id];\n        let image = null; // get image\n\n        if (sampler !== undefined) {\n          const surface = effect.profile.surfaces[sampler.source];\n          image = getImage(surface.init_from);\n        } else {\n          console.warn('THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530).');\n          image = getImage(textureObject.id);\n        } // create texture if image is avaiable\n\n\n        if (image !== null) {\n          const loader = getTextureLoader(image);\n\n          if (loader !== undefined) {\n            const texture = loader.load(image);\n            const extra = textureObject.extra;\n\n            if (extra !== undefined && extra.technique !== undefined && isEmpty(extra.technique) === false) {\n              const technique = extra.technique;\n              texture.wrapS = technique.wrapU ? RepeatWrapping : ClampToEdgeWrapping;\n              texture.wrapT = technique.wrapV ? RepeatWrapping : ClampToEdgeWrapping;\n              texture.offset.set(technique.offsetU || 0, technique.offsetV || 0);\n              texture.repeat.set(technique.repeatU || 1, technique.repeatV || 1);\n            } else {\n              texture.wrapS = RepeatWrapping;\n              texture.wrapT = RepeatWrapping;\n            }\n\n            return texture;\n          } else {\n            console.warn('THREE.ColladaLoader: Loader for texture %s not found.', image);\n            return null;\n          }\n        } else {\n          console.warn(\"THREE.ColladaLoader: Couldn't create texture with ID:\", textureObject.id);\n          return null;\n        }\n      }\n\n      const parameters = technique.parameters;\n\n      for (const key in parameters) {\n        const parameter = parameters[key];\n\n        switch (key) {\n          case 'diffuse':\n            if (parameter.color) material.color.fromArray(parameter.color);\n            if (parameter.texture) material.map = getTexture(parameter.texture);\n            break;\n\n          case 'specular':\n            if (parameter.color && material.specular) material.specular.fromArray(parameter.color);\n            if (parameter.texture) material.specularMap = getTexture(parameter.texture);\n            break;\n\n          case 'bump':\n            if (parameter.texture) material.normalMap = getTexture(parameter.texture);\n            break;\n\n          case 'ambient':\n            if (parameter.texture) material.lightMap = getTexture(parameter.texture);\n            break;\n\n          case 'shininess':\n            if (parameter.float && material.shininess) material.shininess = parameter.float;\n            break;\n\n          case 'emission':\n            if (parameter.color && material.emissive) material.emissive.fromArray(parameter.color);\n            if (parameter.texture) material.emissiveMap = getTexture(parameter.texture);\n            break;\n        }\n      } //\n\n\n      let transparent = parameters['transparent'];\n      let transparency = parameters['transparency']; // <transparency> does not exist but <transparent>\n\n      if (transparency === undefined && transparent) {\n        transparency = {\n          float: 1\n        };\n      } // <transparent> does not exist but <transparency>\n\n\n      if (transparent === undefined && transparency) {\n        transparent = {\n          opaque: 'A_ONE',\n          data: {\n            color: [1, 1, 1, 1]\n          }\n        };\n      }\n\n      if (transparent && transparency) {\n        // handle case if a texture exists but no color\n        if (transparent.data.texture) {\n          // we do not set an alpha map (see #13792)\n          material.transparent = true;\n        } else {\n          const color = transparent.data.color;\n\n          switch (transparent.opaque) {\n            case 'A_ONE':\n              material.opacity = color[3] * transparency.float;\n              break;\n\n            case 'RGB_ZERO':\n              material.opacity = 1 - color[0] * transparency.float;\n              break;\n\n            case 'A_ZERO':\n              material.opacity = 1 - color[3] * transparency.float;\n              break;\n\n            case 'RGB_ONE':\n              material.opacity = color[0] * transparency.float;\n              break;\n\n            default:\n              console.warn('THREE.ColladaLoader: Invalid opaque type \"%s\" of transparent tag.', transparent.opaque);\n          }\n\n          if (material.opacity < 1) material.transparent = true;\n        }\n      } //\n\n\n      if (technique.extra !== undefined && technique.extra.technique !== undefined) {\n        const techniques = technique.extra.technique;\n\n        for (const k in techniques) {\n          const v = techniques[k];\n\n          switch (k) {\n            case 'double_sided':\n              material.side = v === 1 ? DoubleSide : FrontSide;\n              break;\n\n            case 'bump':\n              material.normalMap = getTexture(v.texture);\n              material.normalScale = new Vector2(1, 1);\n              break;\n          }\n        }\n      }\n\n      return material;\n    }\n\n    function getMaterial(id) {\n      return getBuild(library.materials[id], buildMaterial);\n    } // camera\n\n\n    function parseCamera(xml) {\n      const data = {\n        name: xml.getAttribute('name')\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'optics':\n            data.optics = parseCameraOptics(child);\n            break;\n        }\n      }\n\n      library.cameras[xml.getAttribute('id')] = data;\n    }\n\n    function parseCameraOptics(xml) {\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n\n        switch (child.nodeName) {\n          case 'technique_common':\n            return parseCameraTechnique(child);\n        }\n      }\n\n      return {};\n    }\n\n    function parseCameraTechnique(xml) {\n      const data = {};\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n\n        switch (child.nodeName) {\n          case 'perspective':\n          case 'orthographic':\n            data.technique = child.nodeName;\n            data.parameters = parseCameraParameters(child);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseCameraParameters(xml) {\n      const data = {};\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n\n        switch (child.nodeName) {\n          case 'xfov':\n          case 'yfov':\n          case 'xmag':\n          case 'ymag':\n          case 'znear':\n          case 'zfar':\n          case 'aspect_ratio':\n            data[child.nodeName] = parseFloat(child.textContent);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function buildCamera(data) {\n      let camera;\n\n      switch (data.optics.technique) {\n        case 'perspective':\n          camera = new PerspectiveCamera(data.optics.parameters.yfov, data.optics.parameters.aspect_ratio, data.optics.parameters.znear, data.optics.parameters.zfar);\n          break;\n\n        case 'orthographic':\n          let ymag = data.optics.parameters.ymag;\n          let xmag = data.optics.parameters.xmag;\n          const aspectRatio = data.optics.parameters.aspect_ratio;\n          xmag = xmag === undefined ? ymag * aspectRatio : xmag;\n          ymag = ymag === undefined ? xmag / aspectRatio : ymag;\n          xmag *= 0.5;\n          ymag *= 0.5;\n          camera = new OrthographicCamera(-xmag, xmag, ymag, -ymag, // left, right, top, bottom\n          data.optics.parameters.znear, data.optics.parameters.zfar);\n          break;\n\n        default:\n          camera = new PerspectiveCamera();\n          break;\n      }\n\n      camera.name = data.name || '';\n      return camera;\n    }\n\n    function getCamera(id) {\n      const data = library.cameras[id];\n\n      if (data !== undefined) {\n        return getBuild(data, buildCamera);\n      }\n\n      console.warn(\"THREE.ColladaLoader: Couldn't find camera with ID:\", id);\n      return null;\n    } // light\n\n\n    function parseLight(xml) {\n      let data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'technique_common':\n            data = parseLightTechnique(child);\n            break;\n        }\n      }\n\n      library.lights[xml.getAttribute('id')] = data;\n    }\n\n    function parseLightTechnique(xml) {\n      const data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'directional':\n          case 'point':\n          case 'spot':\n          case 'ambient':\n            data.technique = child.nodeName;\n            data.parameters = parseLightParameters(child);\n        }\n      }\n\n      return data;\n    }\n\n    function parseLightParameters(xml) {\n      const data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'color':\n            const array = parseFloats(child.textContent);\n            data.color = new Color().fromArray(array);\n            break;\n\n          case 'falloff_angle':\n            data.falloffAngle = parseFloat(child.textContent);\n            break;\n\n          case 'quadratic_attenuation':\n            const f = parseFloat(child.textContent);\n            data.distance = f ? Math.sqrt(1 / f) : 0;\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function buildLight(data) {\n      let light;\n\n      switch (data.technique) {\n        case 'directional':\n          light = new DirectionalLight();\n          break;\n\n        case 'point':\n          light = new PointLight();\n          break;\n\n        case 'spot':\n          light = new SpotLight();\n          break;\n\n        case 'ambient':\n          light = new AmbientLight();\n          break;\n      }\n\n      if (data.parameters.color) light.color.copy(data.parameters.color);\n      if (data.parameters.distance) light.distance = data.parameters.distance;\n      return light;\n    }\n\n    function getLight(id) {\n      const data = library.lights[id];\n\n      if (data !== undefined) {\n        return getBuild(data, buildLight);\n      }\n\n      console.warn(\"THREE.ColladaLoader: Couldn't find light with ID:\", id);\n      return null;\n    } // geometry\n\n\n    function parseGeometry(xml) {\n      const data = {\n        name: xml.getAttribute('name'),\n        sources: {},\n        vertices: {},\n        primitives: []\n      };\n      const mesh = getElementsByTagName(xml, 'mesh')[0]; // the following tags inside geometry are not supported yet (see https://github.com/mrdoob/three.js/pull/12606): convex_mesh, spline, brep\n\n      if (mesh === undefined) return;\n\n      for (let i = 0; i < mesh.childNodes.length; i++) {\n        const child = mesh.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        const id = child.getAttribute('id');\n\n        switch (child.nodeName) {\n          case 'source':\n            data.sources[id] = parseSource(child);\n            break;\n\n          case 'vertices':\n            // data.sources[ id ] = data.sources[ parseId( getElementsByTagName( child, 'input' )[ 0 ].getAttribute( 'source' ) ) ];\n            data.vertices = parseGeometryVertices(child);\n            break;\n\n          case 'polygons':\n            console.warn('THREE.ColladaLoader: Unsupported primitive type: ', child.nodeName);\n            break;\n\n          case 'lines':\n          case 'linestrips':\n          case 'polylist':\n          case 'triangles':\n            data.primitives.push(parseGeometryPrimitive(child));\n            break;\n\n          default:\n            console.log(child);\n        }\n      }\n\n      library.geometries[xml.getAttribute('id')] = data;\n    }\n\n    function parseSource(xml) {\n      const data = {\n        array: [],\n        stride: 3\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'float_array':\n            data.array = parseFloats(child.textContent);\n            break;\n\n          case 'Name_array':\n            data.array = parseStrings(child.textContent);\n            break;\n\n          case 'technique_common':\n            const accessor = getElementsByTagName(child, 'accessor')[0];\n\n            if (accessor !== undefined) {\n              data.stride = parseInt(accessor.getAttribute('stride'));\n            }\n\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseGeometryVertices(xml) {\n      const data = {};\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        data[child.getAttribute('semantic')] = parseId(child.getAttribute('source'));\n      }\n\n      return data;\n    }\n\n    function parseGeometryPrimitive(xml) {\n      const primitive = {\n        type: xml.nodeName,\n        material: xml.getAttribute('material'),\n        count: parseInt(xml.getAttribute('count')),\n        inputs: {},\n        stride: 0,\n        hasUV: false\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'input':\n            const id = parseId(child.getAttribute('source'));\n            const semantic = child.getAttribute('semantic');\n            const offset = parseInt(child.getAttribute('offset'));\n            const set = parseInt(child.getAttribute('set'));\n            const inputname = set > 0 ? semantic + set : semantic;\n            primitive.inputs[inputname] = {\n              id: id,\n              offset: offset\n            };\n            primitive.stride = Math.max(primitive.stride, offset + 1);\n            if (semantic === 'TEXCOORD') primitive.hasUV = true;\n            break;\n\n          case 'vcount':\n            primitive.vcount = parseInts(child.textContent);\n            break;\n\n          case 'p':\n            primitive.p = parseInts(child.textContent);\n            break;\n        }\n      }\n\n      return primitive;\n    }\n\n    function groupPrimitives(primitives) {\n      const build = {};\n\n      for (let i = 0; i < primitives.length; i++) {\n        const primitive = primitives[i];\n        if (build[primitive.type] === undefined) build[primitive.type] = [];\n        build[primitive.type].push(primitive);\n      }\n\n      return build;\n    }\n\n    function checkUVCoordinates(primitives) {\n      let count = 0;\n\n      for (let i = 0, l = primitives.length; i < l; i++) {\n        const primitive = primitives[i];\n\n        if (primitive.hasUV === true) {\n          count++;\n        }\n      }\n\n      if (count > 0 && count < primitives.length) {\n        primitives.uvsNeedsFix = true;\n      }\n    }\n\n    function buildGeometry(data) {\n      const build = {};\n      const sources = data.sources;\n      const vertices = data.vertices;\n      const primitives = data.primitives;\n      if (primitives.length === 0) return {}; // our goal is to create one buffer geometry for a single type of primitives\n      // first, we group all primitives by their type\n\n      const groupedPrimitives = groupPrimitives(primitives);\n\n      for (const type in groupedPrimitives) {\n        const primitiveType = groupedPrimitives[type]; // second, ensure consistent uv coordinates for each type of primitives (polylist,triangles or lines)\n\n        checkUVCoordinates(primitiveType); // third, create a buffer geometry for each type of primitives\n\n        build[type] = buildGeometryType(primitiveType, sources, vertices);\n      }\n\n      return build;\n    }\n\n    function buildGeometryType(primitives, sources, vertices) {\n      const build = {};\n      const position = {\n        array: [],\n        stride: 0\n      };\n      const normal = {\n        array: [],\n        stride: 0\n      };\n      const uv = {\n        array: [],\n        stride: 0\n      };\n      const uv2 = {\n        array: [],\n        stride: 0\n      };\n      const color = {\n        array: [],\n        stride: 0\n      };\n      const skinIndex = {\n        array: [],\n        stride: 4\n      };\n      const skinWeight = {\n        array: [],\n        stride: 4\n      };\n      const geometry = new BufferGeometry();\n      const materialKeys = [];\n      let start = 0;\n\n      for (let p = 0; p < primitives.length; p++) {\n        const primitive = primitives[p];\n        const inputs = primitive.inputs; // groups\n\n        let count = 0;\n\n        switch (primitive.type) {\n          case 'lines':\n          case 'linestrips':\n            count = primitive.count * 2;\n            break;\n\n          case 'triangles':\n            count = primitive.count * 3;\n            break;\n\n          case 'polylist':\n            for (let g = 0; g < primitive.count; g++) {\n              const vc = primitive.vcount[g];\n\n              switch (vc) {\n                case 3:\n                  count += 3; // single triangle\n\n                  break;\n\n                case 4:\n                  count += 6; // quad, subdivided into two triangles\n\n                  break;\n\n                default:\n                  count += (vc - 2) * 3; // polylist with more than four vertices\n\n                  break;\n              }\n            }\n\n            break;\n\n          default:\n            console.warn('THREE.ColladaLoader: Unknow primitive type:', primitive.type);\n        }\n\n        geometry.addGroup(start, count, p);\n        start += count; // material\n\n        if (primitive.material) {\n          materialKeys.push(primitive.material);\n        } // geometry data\n\n\n        for (const name in inputs) {\n          const input = inputs[name];\n\n          switch (name) {\n            case 'VERTEX':\n              for (const key in vertices) {\n                const id = vertices[key];\n\n                switch (key) {\n                  case 'POSITION':\n                    const prevLength = position.array.length;\n                    buildGeometryData(primitive, sources[id], input.offset, position.array);\n                    position.stride = sources[id].stride;\n\n                    if (sources.skinWeights && sources.skinIndices) {\n                      buildGeometryData(primitive, sources.skinIndices, input.offset, skinIndex.array);\n                      buildGeometryData(primitive, sources.skinWeights, input.offset, skinWeight.array);\n                    } // see #3803\n\n\n                    if (primitive.hasUV === false && primitives.uvsNeedsFix === true) {\n                      const count = (position.array.length - prevLength) / position.stride;\n\n                      for (let i = 0; i < count; i++) {\n                        // fill missing uv coordinates\n                        uv.array.push(0, 0);\n                      }\n                    }\n\n                    break;\n\n                  case 'NORMAL':\n                    buildGeometryData(primitive, sources[id], input.offset, normal.array);\n                    normal.stride = sources[id].stride;\n                    break;\n\n                  case 'COLOR':\n                    buildGeometryData(primitive, sources[id], input.offset, color.array);\n                    color.stride = sources[id].stride;\n                    break;\n\n                  case 'TEXCOORD':\n                    buildGeometryData(primitive, sources[id], input.offset, uv.array);\n                    uv.stride = sources[id].stride;\n                    break;\n\n                  case 'TEXCOORD1':\n                    buildGeometryData(primitive, sources[id], input.offset, uv2.array);\n                    uv.stride = sources[id].stride;\n                    break;\n\n                  default:\n                    console.warn('THREE.ColladaLoader: Semantic \"%s\" not handled in geometry build process.', key);\n                }\n              }\n\n              break;\n\n            case 'NORMAL':\n              buildGeometryData(primitive, sources[input.id], input.offset, normal.array);\n              normal.stride = sources[input.id].stride;\n              break;\n\n            case 'COLOR':\n              buildGeometryData(primitive, sources[input.id], input.offset, color.array);\n              color.stride = sources[input.id].stride;\n              break;\n\n            case 'TEXCOORD':\n              buildGeometryData(primitive, sources[input.id], input.offset, uv.array);\n              uv.stride = sources[input.id].stride;\n              break;\n\n            case 'TEXCOORD1':\n              buildGeometryData(primitive, sources[input.id], input.offset, uv2.array);\n              uv2.stride = sources[input.id].stride;\n              break;\n          }\n        }\n      } // build geometry\n\n\n      if (position.array.length > 0) {\n        geometry.setAttribute('position', new Float32BufferAttribute(position.array, position.stride));\n      }\n\n      if (normal.array.length > 0) {\n        geometry.setAttribute('normal', new Float32BufferAttribute(normal.array, normal.stride));\n      }\n\n      if (color.array.length > 0) geometry.setAttribute('color', new Float32BufferAttribute(color.array, color.stride));\n      if (uv.array.length > 0) geometry.setAttribute('uv', new Float32BufferAttribute(uv.array, uv.stride));\n      if (uv2.array.length > 0) geometry.setAttribute('uv2', new Float32BufferAttribute(uv2.array, uv2.stride));\n\n      if (skinIndex.array.length > 0) {\n        geometry.setAttribute('skinIndex', new Float32BufferAttribute(skinIndex.array, skinIndex.stride));\n      }\n\n      if (skinWeight.array.length > 0) {\n        geometry.setAttribute('skinWeight', new Float32BufferAttribute(skinWeight.array, skinWeight.stride));\n      }\n\n      build.data = geometry;\n      build.type = primitives[0].type;\n      build.materialKeys = materialKeys;\n      return build;\n    }\n\n    function buildGeometryData(primitive, source, offset, array) {\n      const indices = primitive.p;\n      const stride = primitive.stride;\n      const vcount = primitive.vcount;\n\n      function pushVector(i) {\n        let index = indices[i + offset] * sourceStride;\n        const length = index + sourceStride;\n\n        for (; index < length; index++) {\n          array.push(sourceArray[index]);\n        }\n      }\n\n      const sourceArray = source.array;\n      const sourceStride = source.stride;\n\n      if (primitive.vcount !== undefined) {\n        let index = 0;\n\n        for (let i = 0, l = vcount.length; i < l; i++) {\n          const count = vcount[i];\n\n          if (count === 4) {\n            const a = index + stride * 0;\n            const b = index + stride * 1;\n            const c = index + stride * 2;\n            const d = index + stride * 3;\n            pushVector(a);\n            pushVector(b);\n            pushVector(d);\n            pushVector(b);\n            pushVector(c);\n            pushVector(d);\n          } else if (count === 3) {\n            const a = index + stride * 0;\n            const b = index + stride * 1;\n            const c = index + stride * 2;\n            pushVector(a);\n            pushVector(b);\n            pushVector(c);\n          } else if (count > 4) {\n            for (let k = 1, kl = count - 2; k <= kl; k++) {\n              const a = index + stride * 0;\n              const b = index + stride * k;\n              const c = index + stride * (k + 1);\n              pushVector(a);\n              pushVector(b);\n              pushVector(c);\n            }\n          }\n\n          index += stride * count;\n        }\n      } else {\n        for (let i = 0, l = indices.length; i < l; i += stride) {\n          pushVector(i);\n        }\n      }\n    }\n\n    function getGeometry(id) {\n      return getBuild(library.geometries[id], buildGeometry);\n    } // kinematics\n\n\n    function parseKinematicsModel(xml) {\n      const data = {\n        name: xml.getAttribute('name') || '',\n        joints: {},\n        links: []\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'technique_common':\n            parseKinematicsTechniqueCommon(child, data);\n            break;\n        }\n      }\n\n      library.kinematicsModels[xml.getAttribute('id')] = data;\n    }\n\n    function buildKinematicsModel(data) {\n      if (data.build !== undefined) return data.build;\n      return data;\n    }\n\n    function getKinematicsModel(id) {\n      return getBuild(library.kinematicsModels[id], buildKinematicsModel);\n    }\n\n    function parseKinematicsTechniqueCommon(xml, data) {\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'joint':\n            data.joints[child.getAttribute('sid')] = parseKinematicsJoint(child);\n            break;\n\n          case 'link':\n            data.links.push(parseKinematicsLink(child));\n            break;\n        }\n      }\n    }\n\n    function parseKinematicsJoint(xml) {\n      let data;\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'prismatic':\n          case 'revolute':\n            data = parseKinematicsJointParameter(child);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseKinematicsJointParameter(xml) {\n      const data = {\n        sid: xml.getAttribute('sid'),\n        name: xml.getAttribute('name') || '',\n        axis: new Vector3(),\n        limits: {\n          min: 0,\n          max: 0\n        },\n        type: xml.nodeName,\n        static: false,\n        zeroPosition: 0,\n        middlePosition: 0\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'axis':\n            const array = parseFloats(child.textContent);\n            data.axis.fromArray(array);\n            break;\n\n          case 'limits':\n            const max = child.getElementsByTagName('max')[0];\n            const min = child.getElementsByTagName('min')[0];\n            data.limits.max = parseFloat(max.textContent);\n            data.limits.min = parseFloat(min.textContent);\n            break;\n        }\n      } // if min is equal to or greater than max, consider the joint static\n\n\n      if (data.limits.min >= data.limits.max) {\n        data.static = true;\n      } // calculate middle position\n\n\n      data.middlePosition = (data.limits.min + data.limits.max) / 2.0;\n      return data;\n    }\n\n    function parseKinematicsLink(xml) {\n      const data = {\n        sid: xml.getAttribute('sid'),\n        name: xml.getAttribute('name') || '',\n        attachments: [],\n        transforms: []\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'attachment_full':\n            data.attachments.push(parseKinematicsAttachment(child));\n            break;\n\n          case 'matrix':\n          case 'translate':\n          case 'rotate':\n            data.transforms.push(parseKinematicsTransform(child));\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseKinematicsAttachment(xml) {\n      const data = {\n        joint: xml.getAttribute('joint').split('/').pop(),\n        transforms: [],\n        links: []\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'link':\n            data.links.push(parseKinematicsLink(child));\n            break;\n\n          case 'matrix':\n          case 'translate':\n          case 'rotate':\n            data.transforms.push(parseKinematicsTransform(child));\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseKinematicsTransform(xml) {\n      const data = {\n        type: xml.nodeName\n      };\n      const array = parseFloats(xml.textContent);\n\n      switch (data.type) {\n        case 'matrix':\n          data.obj = new Matrix4();\n          data.obj.fromArray(array).transpose();\n          break;\n\n        case 'translate':\n          data.obj = new Vector3();\n          data.obj.fromArray(array);\n          break;\n\n        case 'rotate':\n          data.obj = new Vector3();\n          data.obj.fromArray(array);\n          data.angle = MathUtils.degToRad(array[3]);\n          break;\n      }\n\n      return data;\n    } // physics\n\n\n    function parsePhysicsModel(xml) {\n      const data = {\n        name: xml.getAttribute('name') || '',\n        rigidBodies: {}\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'rigid_body':\n            data.rigidBodies[child.getAttribute('name')] = {};\n            parsePhysicsRigidBody(child, data.rigidBodies[child.getAttribute('name')]);\n            break;\n        }\n      }\n\n      library.physicsModels[xml.getAttribute('id')] = data;\n    }\n\n    function parsePhysicsRigidBody(xml, data) {\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'technique_common':\n            parsePhysicsTechniqueCommon(child, data);\n            break;\n        }\n      }\n    }\n\n    function parsePhysicsTechniqueCommon(xml, data) {\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'inertia':\n            data.inertia = parseFloats(child.textContent);\n            break;\n\n          case 'mass':\n            data.mass = parseFloats(child.textContent)[0];\n            break;\n        }\n      }\n    } // scene\n\n\n    function parseKinematicsScene(xml) {\n      const data = {\n        bindJointAxis: []\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'bind_joint_axis':\n            data.bindJointAxis.push(parseKinematicsBindJointAxis(child));\n            break;\n        }\n      }\n\n      library.kinematicsScenes[parseId(xml.getAttribute('url'))] = data;\n    }\n\n    function parseKinematicsBindJointAxis(xml) {\n      const data = {\n        target: xml.getAttribute('target').split('/').pop()\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'axis':\n            const param = child.getElementsByTagName('param')[0];\n            data.axis = param.textContent;\n            const tmpJointIndex = data.axis.split('inst_').pop().split('axis')[0];\n            data.jointIndex = tmpJointIndex.substr(0, tmpJointIndex.length - 1);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function buildKinematicsScene(data) {\n      if (data.build !== undefined) return data.build;\n      return data;\n    }\n\n    function getKinematicsScene(id) {\n      return getBuild(library.kinematicsScenes[id], buildKinematicsScene);\n    }\n\n    function setupKinematics() {\n      const kinematicsModelId = Object.keys(library.kinematicsModels)[0];\n      const kinematicsSceneId = Object.keys(library.kinematicsScenes)[0];\n      const visualSceneId = Object.keys(library.visualScenes)[0];\n      if (kinematicsModelId === undefined || kinematicsSceneId === undefined) return;\n      const kinematicsModel = getKinematicsModel(kinematicsModelId);\n      const kinematicsScene = getKinematicsScene(kinematicsSceneId);\n      const visualScene = getVisualScene(visualSceneId);\n      const bindJointAxis = kinematicsScene.bindJointAxis;\n      const jointMap = {};\n\n      for (let i = 0, l = bindJointAxis.length; i < l; i++) {\n        const axis = bindJointAxis[i]; // the result of the following query is an element of type 'translate', 'rotate','scale' or 'matrix'\n\n        const targetElement = collada.querySelector('[sid=\"' + axis.target + '\"]');\n\n        if (targetElement) {\n          // get the parent of the transform element\n          const parentVisualElement = targetElement.parentElement; // connect the joint of the kinematics model with the element in the visual scene\n\n          connect(axis.jointIndex, parentVisualElement);\n        }\n      }\n\n      function connect(jointIndex, visualElement) {\n        const visualElementName = visualElement.getAttribute('name');\n        const joint = kinematicsModel.joints[jointIndex];\n        visualScene.traverse(function (object) {\n          if (object.name === visualElementName) {\n            jointMap[jointIndex] = {\n              object: object,\n              transforms: buildTransformList(visualElement),\n              joint: joint,\n              position: joint.zeroPosition\n            };\n          }\n        });\n      }\n\n      const m0 = new Matrix4();\n      kinematics = {\n        joints: kinematicsModel && kinematicsModel.joints,\n        getJointValue: function (jointIndex) {\n          const jointData = jointMap[jointIndex];\n\n          if (jointData) {\n            return jointData.position;\n          } else {\n            console.warn('THREE.ColladaLoader: Joint ' + jointIndex + \" doesn't exist.\");\n          }\n        },\n        setJointValue: function (jointIndex, value) {\n          const jointData = jointMap[jointIndex];\n\n          if (jointData) {\n            const joint = jointData.joint;\n\n            if (value > joint.limits.max || value < joint.limits.min) {\n              console.warn('THREE.ColladaLoader: Joint ' + jointIndex + ' value ' + value + ' outside of limits (min: ' + joint.limits.min + ', max: ' + joint.limits.max + ').');\n            } else if (joint.static) {\n              console.warn('THREE.ColladaLoader: Joint ' + jointIndex + ' is static.');\n            } else {\n              const object = jointData.object;\n              const axis = joint.axis;\n              const transforms = jointData.transforms;\n              matrix.identity(); // each update, we have to apply all transforms in the correct order\n\n              for (let i = 0; i < transforms.length; i++) {\n                const transform = transforms[i]; // if there is a connection of the transform node with a joint, apply the joint value\n\n                if (transform.sid && transform.sid.indexOf(jointIndex) !== -1) {\n                  switch (joint.type) {\n                    case 'revolute':\n                      matrix.multiply(m0.makeRotationAxis(axis, MathUtils.degToRad(value)));\n                      break;\n\n                    case 'prismatic':\n                      matrix.multiply(m0.makeTranslation(axis.x * value, axis.y * value, axis.z * value));\n                      break;\n\n                    default:\n                      console.warn('THREE.ColladaLoader: Unknown joint type: ' + joint.type);\n                      break;\n                  }\n                } else {\n                  switch (transform.type) {\n                    case 'matrix':\n                      matrix.multiply(transform.obj);\n                      break;\n\n                    case 'translate':\n                      matrix.multiply(m0.makeTranslation(transform.obj.x, transform.obj.y, transform.obj.z));\n                      break;\n\n                    case 'scale':\n                      matrix.scale(transform.obj);\n                      break;\n\n                    case 'rotate':\n                      matrix.multiply(m0.makeRotationAxis(transform.obj, transform.angle));\n                      break;\n                  }\n                }\n              }\n\n              object.matrix.copy(matrix);\n              object.matrix.decompose(object.position, object.quaternion, object.scale);\n              jointMap[jointIndex].position = value;\n            }\n          } else {\n            console.log('THREE.ColladaLoader: ' + jointIndex + ' does not exist.');\n          }\n        }\n      };\n    }\n\n    function buildTransformList(node) {\n      const transforms = [];\n      const xml = collada.querySelector('[id=\"' + node.id + '\"]');\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        let array, vector;\n\n        switch (child.nodeName) {\n          case 'matrix':\n            array = parseFloats(child.textContent);\n            const matrix = new Matrix4().fromArray(array).transpose();\n            transforms.push({\n              sid: child.getAttribute('sid'),\n              type: child.nodeName,\n              obj: matrix\n            });\n            break;\n\n          case 'translate':\n          case 'scale':\n            array = parseFloats(child.textContent);\n            vector = new Vector3().fromArray(array);\n            transforms.push({\n              sid: child.getAttribute('sid'),\n              type: child.nodeName,\n              obj: vector\n            });\n            break;\n\n          case 'rotate':\n            array = parseFloats(child.textContent);\n            vector = new Vector3().fromArray(array);\n            const angle = MathUtils.degToRad(array[3]);\n            transforms.push({\n              sid: child.getAttribute('sid'),\n              type: child.nodeName,\n              obj: vector,\n              angle: angle\n            });\n            break;\n        }\n      }\n\n      return transforms;\n    } // nodes\n\n\n    function prepareNodes(xml) {\n      const elements = xml.getElementsByTagName('node'); // ensure all node elements have id attributes\n\n      for (let i = 0; i < elements.length; i++) {\n        const element = elements[i];\n\n        if (element.hasAttribute('id') === false) {\n          element.setAttribute('id', generateId());\n        }\n      }\n    }\n\n    const matrix = new Matrix4();\n    const vector = new Vector3();\n\n    function parseNode(xml) {\n      const data = {\n        name: xml.getAttribute('name') || '',\n        type: xml.getAttribute('type'),\n        id: xml.getAttribute('id'),\n        sid: xml.getAttribute('sid'),\n        matrix: new Matrix4(),\n        nodes: [],\n        instanceCameras: [],\n        instanceControllers: [],\n        instanceLights: [],\n        instanceGeometries: [],\n        instanceNodes: [],\n        transforms: {}\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        let array;\n\n        switch (child.nodeName) {\n          case 'node':\n            data.nodes.push(child.getAttribute('id'));\n            parseNode(child);\n            break;\n\n          case 'instance_camera':\n            data.instanceCameras.push(parseId(child.getAttribute('url')));\n            break;\n\n          case 'instance_controller':\n            data.instanceControllers.push(parseNodeInstance(child));\n            break;\n\n          case 'instance_light':\n            data.instanceLights.push(parseId(child.getAttribute('url')));\n            break;\n\n          case 'instance_geometry':\n            data.instanceGeometries.push(parseNodeInstance(child));\n            break;\n\n          case 'instance_node':\n            data.instanceNodes.push(parseId(child.getAttribute('url')));\n            break;\n\n          case 'matrix':\n            array = parseFloats(child.textContent);\n            data.matrix.multiply(matrix.fromArray(array).transpose());\n            data.transforms[child.getAttribute('sid')] = child.nodeName;\n            break;\n\n          case 'translate':\n            array = parseFloats(child.textContent);\n            vector.fromArray(array);\n            data.matrix.multiply(matrix.makeTranslation(vector.x, vector.y, vector.z));\n            data.transforms[child.getAttribute('sid')] = child.nodeName;\n            break;\n\n          case 'rotate':\n            array = parseFloats(child.textContent);\n            const angle = MathUtils.degToRad(array[3]);\n            data.matrix.multiply(matrix.makeRotationAxis(vector.fromArray(array), angle));\n            data.transforms[child.getAttribute('sid')] = child.nodeName;\n            break;\n\n          case 'scale':\n            array = parseFloats(child.textContent);\n            data.matrix.scale(vector.fromArray(array));\n            data.transforms[child.getAttribute('sid')] = child.nodeName;\n            break;\n\n          case 'extra':\n            break;\n\n          default:\n            console.log(child);\n        }\n      }\n\n      if (hasNode(data.id)) {\n        console.warn('THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.', data.id);\n      } else {\n        library.nodes[data.id] = data;\n      }\n\n      return data;\n    }\n\n    function parseNodeInstance(xml) {\n      const data = {\n        id: parseId(xml.getAttribute('url')),\n        materials: {},\n        skeletons: []\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n\n        switch (child.nodeName) {\n          case 'bind_material':\n            const instances = child.getElementsByTagName('instance_material');\n\n            for (let j = 0; j < instances.length; j++) {\n              const instance = instances[j];\n              const symbol = instance.getAttribute('symbol');\n              const target = instance.getAttribute('target');\n              data.materials[symbol] = parseId(target);\n            }\n\n            break;\n\n          case 'skeleton':\n            data.skeletons.push(parseId(child.textContent));\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function buildSkeleton(skeletons, joints) {\n      const boneData = [];\n      const sortedBoneData = [];\n      let i, j, data; // a skeleton can have multiple root bones. collada expresses this\n      // situtation with multiple \"skeleton\" tags per controller instance\n\n      for (i = 0; i < skeletons.length; i++) {\n        const skeleton = skeletons[i];\n        let root;\n\n        if (hasNode(skeleton)) {\n          root = getNode(skeleton);\n          buildBoneHierarchy(root, joints, boneData);\n        } else if (hasVisualScene(skeleton)) {\n          // handle case where the skeleton refers to the visual scene (#13335)\n          const visualScene = library.visualScenes[skeleton];\n          const children = visualScene.children;\n\n          for (let j = 0; j < children.length; j++) {\n            const child = children[j];\n\n            if (child.type === 'JOINT') {\n              const root = getNode(child.id);\n              buildBoneHierarchy(root, joints, boneData);\n            }\n          }\n        } else {\n          console.error('THREE.ColladaLoader: Unable to find root bone of skeleton with ID:', skeleton);\n        }\n      } // sort bone data (the order is defined in the corresponding controller)\n\n\n      for (i = 0; i < joints.length; i++) {\n        for (j = 0; j < boneData.length; j++) {\n          data = boneData[j];\n\n          if (data.bone.name === joints[i].name) {\n            sortedBoneData[i] = data;\n            data.processed = true;\n            break;\n          }\n        }\n      } // add unprocessed bone data at the end of the list\n\n\n      for (i = 0; i < boneData.length; i++) {\n        data = boneData[i];\n\n        if (data.processed === false) {\n          sortedBoneData.push(data);\n          data.processed = true;\n        }\n      } // setup arrays for skeleton creation\n\n\n      const bones = [];\n      const boneInverses = [];\n\n      for (i = 0; i < sortedBoneData.length; i++) {\n        data = sortedBoneData[i];\n        bones.push(data.bone);\n        boneInverses.push(data.boneInverse);\n      }\n\n      return new Skeleton(bones, boneInverses);\n    }\n\n    function buildBoneHierarchy(root, joints, boneData) {\n      // setup bone data from visual scene\n      root.traverse(function (object) {\n        if (object.isBone === true) {\n          let boneInverse; // retrieve the boneInverse from the controller data\n\n          for (let i = 0; i < joints.length; i++) {\n            const joint = joints[i];\n\n            if (joint.name === object.name) {\n              boneInverse = joint.boneInverse;\n              break;\n            }\n          }\n\n          if (boneInverse === undefined) {\n            // Unfortunately, there can be joints in the visual scene that are not part of the\n            // corresponding controller. In this case, we have to create a dummy boneInverse matrix\n            // for the respective bone. This bone won't affect any vertices, because there are no skin indices\n            // and weights defined for it. But we still have to add the bone to the sorted bone list in order to\n            // ensure a correct animation of the model.\n            boneInverse = new Matrix4();\n          }\n\n          boneData.push({\n            bone: object,\n            boneInverse: boneInverse,\n            processed: false\n          });\n        }\n      });\n    }\n\n    function buildNode(data) {\n      const objects = [];\n      const matrix = data.matrix;\n      const nodes = data.nodes;\n      const type = data.type;\n      const instanceCameras = data.instanceCameras;\n      const instanceControllers = data.instanceControllers;\n      const instanceLights = data.instanceLights;\n      const instanceGeometries = data.instanceGeometries;\n      const instanceNodes = data.instanceNodes; // nodes\n\n      for (let i = 0, l = nodes.length; i < l; i++) {\n        objects.push(getNode(nodes[i]));\n      } // instance cameras\n\n\n      for (let i = 0, l = instanceCameras.length; i < l; i++) {\n        const instanceCamera = getCamera(instanceCameras[i]);\n\n        if (instanceCamera !== null) {\n          objects.push(instanceCamera.clone());\n        }\n      } // instance controllers\n\n\n      for (let i = 0, l = instanceControllers.length; i < l; i++) {\n        const instance = instanceControllers[i];\n        const controller = getController(instance.id);\n        const geometries = getGeometry(controller.id);\n        const newObjects = buildObjects(geometries, instance.materials);\n        const skeletons = instance.skeletons;\n        const joints = controller.skin.joints;\n        const skeleton = buildSkeleton(skeletons, joints);\n\n        for (let j = 0, jl = newObjects.length; j < jl; j++) {\n          const object = newObjects[j];\n\n          if (object.isSkinnedMesh) {\n            object.bind(skeleton, controller.skin.bindMatrix);\n            object.normalizeSkinWeights();\n          }\n\n          objects.push(object);\n        }\n      } // instance lights\n\n\n      for (let i = 0, l = instanceLights.length; i < l; i++) {\n        const instanceLight = getLight(instanceLights[i]);\n\n        if (instanceLight !== null) {\n          objects.push(instanceLight.clone());\n        }\n      } // instance geometries\n\n\n      for (let i = 0, l = instanceGeometries.length; i < l; i++) {\n        const instance = instanceGeometries[i]; // a single geometry instance in collada can lead to multiple object3Ds.\n        // this is the case when primitives are combined like triangles and lines\n\n        const geometries = getGeometry(instance.id);\n        const newObjects = buildObjects(geometries, instance.materials);\n\n        for (let j = 0, jl = newObjects.length; j < jl; j++) {\n          objects.push(newObjects[j]);\n        }\n      } // instance nodes\n\n\n      for (let i = 0, l = instanceNodes.length; i < l; i++) {\n        objects.push(getNode(instanceNodes[i]).clone());\n      }\n\n      let object;\n\n      if (nodes.length === 0 && objects.length === 1) {\n        object = objects[0];\n      } else {\n        object = type === 'JOINT' ? new Bone() : new Group();\n\n        for (let i = 0; i < objects.length; i++) {\n          object.add(objects[i]);\n        }\n      }\n\n      object.name = type === 'JOINT' ? data.sid : data.name;\n      object.matrix.copy(matrix);\n      object.matrix.decompose(object.position, object.quaternion, object.scale);\n      return object;\n    }\n\n    const fallbackMaterial = new MeshBasicMaterial({\n      color: 0xff00ff\n    });\n\n    function resolveMaterialBinding(keys, instanceMaterials) {\n      const materials = [];\n\n      for (let i = 0, l = keys.length; i < l; i++) {\n        const id = instanceMaterials[keys[i]];\n\n        if (id === undefined) {\n          console.warn('THREE.ColladaLoader: Material with key %s not found. Apply fallback material.', keys[i]);\n          materials.push(fallbackMaterial);\n        } else {\n          materials.push(getMaterial(id));\n        }\n      }\n\n      return materials;\n    }\n\n    function buildObjects(geometries, instanceMaterials) {\n      const objects = [];\n\n      for (const type in geometries) {\n        const geometry = geometries[type];\n        const materials = resolveMaterialBinding(geometry.materialKeys, instanceMaterials); // handle case if no materials are defined\n\n        if (materials.length === 0) {\n          if (type === 'lines' || type === 'linestrips') {\n            materials.push(new LineBasicMaterial());\n          } else {\n            materials.push(new MeshPhongMaterial());\n          }\n        } // regard skinning\n\n\n        const skinning = geometry.data.attributes.skinIndex !== undefined; // choose between a single or multi materials (material array)\n\n        const material = materials.length === 1 ? materials[0] : materials; // now create a specific 3D object\n\n        let object;\n\n        switch (type) {\n          case 'lines':\n            object = new LineSegments(geometry.data, material);\n            break;\n\n          case 'linestrips':\n            object = new Line(geometry.data, material);\n            break;\n\n          case 'triangles':\n          case 'polylist':\n            if (skinning) {\n              object = new SkinnedMesh(geometry.data, material);\n            } else {\n              object = new Mesh(geometry.data, material);\n            }\n\n            break;\n        }\n\n        objects.push(object);\n      }\n\n      return objects;\n    }\n\n    function hasNode(id) {\n      return library.nodes[id] !== undefined;\n    }\n\n    function getNode(id) {\n      return getBuild(library.nodes[id], buildNode);\n    } // visual scenes\n\n\n    function parseVisualScene(xml) {\n      const data = {\n        name: xml.getAttribute('name'),\n        children: []\n      };\n      prepareNodes(xml);\n      const elements = getElementsByTagName(xml, 'node');\n\n      for (let i = 0; i < elements.length; i++) {\n        data.children.push(parseNode(elements[i]));\n      }\n\n      library.visualScenes[xml.getAttribute('id')] = data;\n    }\n\n    function buildVisualScene(data) {\n      const group = new Group();\n      group.name = data.name;\n      const children = data.children;\n\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i];\n        group.add(getNode(child.id));\n      }\n\n      return group;\n    }\n\n    function hasVisualScene(id) {\n      return library.visualScenes[id] !== undefined;\n    }\n\n    function getVisualScene(id) {\n      return getBuild(library.visualScenes[id], buildVisualScene);\n    } // scenes\n\n\n    function parseScene(xml) {\n      const instance = getElementsByTagName(xml, 'instance_visual_scene')[0];\n      return getVisualScene(parseId(instance.getAttribute('url')));\n    }\n\n    function setupAnimations() {\n      const clips = library.clips;\n\n      if (isEmpty(clips) === true) {\n        if (isEmpty(library.animations) === false) {\n          // if there are animations but no clips, we create a default clip for playback\n          const tracks = [];\n\n          for (const id in library.animations) {\n            const animationTracks = getAnimation(id);\n\n            for (let i = 0, l = animationTracks.length; i < l; i++) {\n              tracks.push(animationTracks[i]);\n            }\n          }\n\n          animations.push(new AnimationClip('default', -1, tracks));\n        }\n      } else {\n        for (const id in clips) {\n          animations.push(getAnimationClip(id));\n        }\n      }\n    } // convert the parser error element into text with each child elements text\n    // separated by new lines.\n\n\n    function parserErrorToText(parserError) {\n      let result = '';\n      const stack = [parserError];\n\n      while (stack.length) {\n        const node = stack.shift();\n\n        if (node.nodeType === Node.TEXT_NODE) {\n          result += node.textContent;\n        } else {\n          result += '\\n';\n          stack.push.apply(stack, node.childNodes);\n        }\n      }\n\n      return result.trim();\n    }\n\n    if (text.length === 0) {\n      return {\n        scene: new Scene()\n      };\n    }\n\n    const xml = new DOMParser().parseFromString(text, 'application/xml');\n    const collada = getElementsByTagName(xml, 'COLLADA')[0];\n    const parserError = xml.getElementsByTagName('parsererror')[0];\n\n    if (parserError !== undefined) {\n      // Chrome will return parser error with a div in it\n      const errorElement = getElementsByTagName(parserError, 'div')[0];\n      let errorText;\n\n      if (errorElement) {\n        errorText = errorElement.textContent;\n      } else {\n        errorText = parserErrorToText(parserError);\n      }\n\n      console.error('THREE.ColladaLoader: Failed to parse collada file.\\n', errorText);\n      return null;\n    } // metadata\n\n\n    const version = collada.getAttribute('version');\n    console.log('THREE.ColladaLoader: File version', version);\n    const asset = parseAsset(getElementsByTagName(collada, 'asset')[0]);\n    const textureLoader = new TextureLoader(this.manager);\n    textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n    let tgaLoader;\n\n    if (TGALoader) {\n      tgaLoader = new TGALoader(this.manager);\n      tgaLoader.setPath(this.resourcePath || path);\n    } //\n\n\n    const animations = [];\n    let kinematics = {};\n    let count = 0; //\n\n    const library = {\n      animations: {},\n      clips: {},\n      controllers: {},\n      images: {},\n      effects: {},\n      materials: {},\n      cameras: {},\n      lights: {},\n      geometries: {},\n      nodes: {},\n      visualScenes: {},\n      kinematicsModels: {},\n      physicsModels: {},\n      kinematicsScenes: {}\n    };\n    parseLibrary(collada, 'library_animations', 'animation', parseAnimation);\n    parseLibrary(collada, 'library_animation_clips', 'animation_clip', parseAnimationClip);\n    parseLibrary(collada, 'library_controllers', 'controller', parseController);\n    parseLibrary(collada, 'library_images', 'image', parseImage);\n    parseLibrary(collada, 'library_effects', 'effect', parseEffect);\n    parseLibrary(collada, 'library_materials', 'material', parseMaterial);\n    parseLibrary(collada, 'library_cameras', 'camera', parseCamera);\n    parseLibrary(collada, 'library_lights', 'light', parseLight);\n    parseLibrary(collada, 'library_geometries', 'geometry', parseGeometry);\n    parseLibrary(collada, 'library_nodes', 'node', parseNode);\n    parseLibrary(collada, 'library_visual_scenes', 'visual_scene', parseVisualScene);\n    parseLibrary(collada, 'library_kinematics_models', 'kinematics_model', parseKinematicsModel);\n    parseLibrary(collada, 'library_physics_models', 'physics_model', parsePhysicsModel);\n    parseLibrary(collada, 'scene', 'instance_kinematics_scene', parseKinematicsScene);\n    buildLibrary(library.animations, buildAnimation);\n    buildLibrary(library.clips, buildAnimationClip);\n    buildLibrary(library.controllers, buildController);\n    buildLibrary(library.images, buildImage);\n    buildLibrary(library.effects, buildEffect);\n    buildLibrary(library.materials, buildMaterial);\n    buildLibrary(library.cameras, buildCamera);\n    buildLibrary(library.lights, buildLight);\n    buildLibrary(library.geometries, buildGeometry);\n    buildLibrary(library.visualScenes, buildVisualScene);\n    setupAnimations();\n    setupKinematics();\n    const scene = parseScene(getElementsByTagName(collada, 'scene')[0]);\n    scene.animations = animations;\n\n    if (asset.upAxis === 'Z_UP') {\n      scene.quaternion.setFromEuler(new Euler(-Math.PI / 2, 0, 0));\n    }\n\n    scene.scale.multiplyScalar(asset.unit);\n    return {\n      get animations() {\n        console.warn('THREE.ColladaLoader: Please access animations over scene.animations now.');\n        return animations;\n      },\n\n      kinematics: kinematics,\n      library: library,\n      scene: scene\n    };\n  }\n\n}\n\nexport { ColladaLoader };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}