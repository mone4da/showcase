{"ast":null,"code":"import _createClass from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _assertThisInitialized from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Mesh, Vector3, Color, FrontSide, Plane, Matrix4, Vector4, PerspectiveCamera, WebGLRenderTarget, UniformsUtils, UniformsLib, ShaderMaterial } from 'three';\n\n/**\n * Work based on :\n * https://github.com/Slayvin: Flat mirror for three.js\n * https://home.adelphi.edu/~stemkoski/ : An implementation of water shader based on the flat mirror\n * http://29a.ch/ && http://29a.ch/slides/2012/webglwater/ : Water shader explanations in WebGL\n */\nvar Water = /*#__PURE__*/function (_Mesh) {\n  _inherits(Water, _Mesh);\n  var _super = _createSuper(Water);\n  function Water(geometry) {\n    var _this;\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, Water);\n    _this = _super.call(this, geometry);\n    var scope = _assertThisInitialized(_this);\n    var textureWidth = options.textureWidth !== undefined ? options.textureWidth : 512;\n    var textureHeight = options.textureHeight !== undefined ? options.textureHeight : 512;\n    var clipBias = options.clipBias !== undefined ? options.clipBias : 0.0;\n    var alpha = options.alpha !== undefined ? options.alpha : 1.0;\n    var time = options.time !== undefined ? options.time : 0.0;\n    var normalSampler = options.waterNormals !== undefined ? options.waterNormals : null;\n    var sunDirection = options.sunDirection !== undefined ? options.sunDirection : new Vector3(0.70707, 0.70707, 0.0);\n    var sunColor = new Color(options.sunColor !== undefined ? options.sunColor : 0xffffff);\n    var waterColor = new Color(options.waterColor !== undefined ? options.waterColor : 0x7f7f7f);\n    var eye = options.eye !== undefined ? options.eye : new Vector3(0, 0, 0);\n    var distortionScale = options.distortionScale !== undefined ? options.distortionScale : 20.0;\n    var side = options.side !== undefined ? options.side : FrontSide;\n    var fog = options.fog !== undefined ? options.fog : false; //\n\n    var mirrorPlane = new Plane();\n    var normal = new Vector3();\n    var mirrorWorldPosition = new Vector3();\n    var cameraWorldPosition = new Vector3();\n    var rotationMatrix = new Matrix4();\n    var lookAtPosition = new Vector3(0, 0, -1);\n    var clipPlane = new Vector4();\n    var view = new Vector3();\n    var target = new Vector3();\n    var q = new Vector4();\n    var textureMatrix = new Matrix4();\n    var mirrorCamera = new PerspectiveCamera();\n    var renderTarget = new WebGLRenderTarget(textureWidth, textureHeight);\n    var mirrorShader = {\n      uniforms: UniformsUtils.merge([UniformsLib['fog'], UniformsLib['lights'], {\n        normalSampler: {\n          value: null\n        },\n        mirrorSampler: {\n          value: null\n        },\n        alpha: {\n          value: 1.0\n        },\n        time: {\n          value: 0.0\n        },\n        size: {\n          value: 1.0\n        },\n        distortionScale: {\n          value: 20.0\n        },\n        textureMatrix: {\n          value: new Matrix4()\n        },\n        sunColor: {\n          value: new Color(0x7f7f7f)\n        },\n        sunDirection: {\n          value: new Vector3(0.70707, 0.70707, 0)\n        },\n        eye: {\n          value: new Vector3()\n        },\n        waterColor: {\n          value: new Color(0x555555)\n        }\n      }]),\n      vertexShader: /* glsl */\"\\n\\t\\t\\t\\tuniform mat4 textureMatrix;\\n\\t\\t\\t\\tuniform float time;\\n\\n\\t\\t\\t\\tvarying vec4 mirrorCoord;\\n\\t\\t\\t\\tvarying vec4 worldPosition;\\n\\n\\t\\t\\t\\t#include <common>\\n\\t\\t\\t\\t#include <fog_pars_vertex>\\n\\t\\t\\t\\t#include <shadowmap_pars_vertex>\\n\\t\\t\\t\\t#include <logdepthbuf_pars_vertex>\\n\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tmirrorCoord = modelMatrix * vec4( position, 1.0 );\\n\\t\\t\\t\\t\\tworldPosition = mirrorCoord.xyzw;\\n\\t\\t\\t\\t\\tmirrorCoord = textureMatrix * mirrorCoord;\\n\\t\\t\\t\\t\\tvec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );\\n\\t\\t\\t\\t\\tgl_Position = projectionMatrix * mvPosition;\\n\\n\\t\\t\\t\\t#include <beginnormal_vertex>\\n\\t\\t\\t\\t#include <defaultnormal_vertex>\\n\\t\\t\\t\\t#include <logdepthbuf_vertex>\\n\\t\\t\\t\\t#include <fog_vertex>\\n\\t\\t\\t\\t#include <shadowmap_vertex>\\n\\t\\t\\t}\",\n      fragmentShader: /* glsl */\"\\n\\t\\t\\t\\tuniform sampler2D mirrorSampler;\\n\\t\\t\\t\\tuniform float alpha;\\n\\t\\t\\t\\tuniform float time;\\n\\t\\t\\t\\tuniform float size;\\n\\t\\t\\t\\tuniform float distortionScale;\\n\\t\\t\\t\\tuniform sampler2D normalSampler;\\n\\t\\t\\t\\tuniform vec3 sunColor;\\n\\t\\t\\t\\tuniform vec3 sunDirection;\\n\\t\\t\\t\\tuniform vec3 eye;\\n\\t\\t\\t\\tuniform vec3 waterColor;\\n\\n\\t\\t\\t\\tvarying vec4 mirrorCoord;\\n\\t\\t\\t\\tvarying vec4 worldPosition;\\n\\n\\t\\t\\t\\tvec4 getNoise( vec2 uv ) {\\n\\t\\t\\t\\t\\tvec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);\\n\\t\\t\\t\\t\\tvec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );\\n\\t\\t\\t\\t\\tvec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );\\n\\t\\t\\t\\t\\tvec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );\\n\\t\\t\\t\\t\\tvec4 noise = texture2D( normalSampler, uv0 ) +\\n\\t\\t\\t\\t\\t\\ttexture2D( normalSampler, uv1 ) +\\n\\t\\t\\t\\t\\t\\ttexture2D( normalSampler, uv2 ) +\\n\\t\\t\\t\\t\\t\\ttexture2D( normalSampler, uv3 );\\n\\t\\t\\t\\t\\treturn noise * 0.5 - 1.0;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvoid sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {\\n\\t\\t\\t\\t\\tvec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );\\n\\t\\t\\t\\t\\tfloat direction = max( 0.0, dot( eyeDirection, reflection ) );\\n\\t\\t\\t\\t\\tspecularColor += pow( direction, shiny ) * sunColor * spec;\\n\\t\\t\\t\\t\\tdiffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t#include <common>\\n\\t\\t\\t\\t#include <packing>\\n\\t\\t\\t\\t#include <bsdfs>\\n\\t\\t\\t\\t#include <fog_pars_fragment>\\n\\t\\t\\t\\t#include <logdepthbuf_pars_fragment>\\n\\t\\t\\t\\t#include <lights_pars_begin>\\n\\t\\t\\t\\t#include <shadowmap_pars_fragment>\\n\\t\\t\\t\\t#include <shadowmask_pars_fragment>\\n\\n\\t\\t\\t\\tvoid main() {\\n\\n\\t\\t\\t\\t\\t#include <logdepthbuf_fragment>\\n\\t\\t\\t\\t\\tvec4 noise = getNoise( worldPosition.xz * size );\\n\\t\\t\\t\\t\\tvec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );\\n\\n\\t\\t\\t\\t\\tvec3 diffuseLight = vec3(0.0);\\n\\t\\t\\t\\t\\tvec3 specularLight = vec3(0.0);\\n\\n\\t\\t\\t\\t\\tvec3 worldToEye = eye-worldPosition.xyz;\\n\\t\\t\\t\\t\\tvec3 eyeDirection = normalize( worldToEye );\\n\\t\\t\\t\\t\\tsunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );\\n\\n\\t\\t\\t\\t\\tfloat distance = length(worldToEye);\\n\\n\\t\\t\\t\\t\\tvec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;\\n\\t\\t\\t\\t\\tvec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );\\n\\n\\t\\t\\t\\t\\tfloat theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );\\n\\t\\t\\t\\t\\tfloat rf0 = 0.3;\\n\\t\\t\\t\\t\\tfloat reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );\\n\\t\\t\\t\\t\\tvec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;\\n\\t\\t\\t\\t\\tvec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);\\n\\t\\t\\t\\t\\tvec3 outgoingLight = albedo;\\n\\t\\t\\t\\t\\tgl_FragColor = vec4( outgoingLight, alpha );\\n\\n\\t\\t\\t\\t\\t#include <tonemapping_fragment>\\n\\t\\t\\t\\t\\t#include <fog_fragment>\\n\\t\\t\\t\\t}\"\n    };\n    var material = new ShaderMaterial({\n      fragmentShader: mirrorShader.fragmentShader,\n      vertexShader: mirrorShader.vertexShader,\n      uniforms: UniformsUtils.clone(mirrorShader.uniforms),\n      lights: true,\n      side: side,\n      fog: fog\n    });\n    material.uniforms['mirrorSampler'].value = renderTarget.texture;\n    material.uniforms['textureMatrix'].value = textureMatrix;\n    material.uniforms['alpha'].value = alpha;\n    material.uniforms['time'].value = time;\n    material.uniforms['normalSampler'].value = normalSampler;\n    material.uniforms['sunColor'].value = sunColor;\n    material.uniforms['waterColor'].value = waterColor;\n    material.uniforms['sunDirection'].value = sunDirection;\n    material.uniforms['distortionScale'].value = distortionScale;\n    material.uniforms['eye'].value = eye;\n    scope.material = material;\n    scope.onBeforeRender = function (renderer, scene, camera) {\n      mirrorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n      rotationMatrix.extractRotation(scope.matrixWorld);\n      normal.set(0, 0, 1);\n      normal.applyMatrix4(rotationMatrix);\n      view.subVectors(mirrorWorldPosition, cameraWorldPosition); // Avoid rendering when mirror is facing away\n\n      if (view.dot(normal) > 0) return;\n      view.reflect(normal).negate();\n      view.add(mirrorWorldPosition);\n      rotationMatrix.extractRotation(camera.matrixWorld);\n      lookAtPosition.set(0, 0, -1);\n      lookAtPosition.applyMatrix4(rotationMatrix);\n      lookAtPosition.add(cameraWorldPosition);\n      target.subVectors(mirrorWorldPosition, lookAtPosition);\n      target.reflect(normal).negate();\n      target.add(mirrorWorldPosition);\n      mirrorCamera.position.copy(view);\n      mirrorCamera.up.set(0, 1, 0);\n      mirrorCamera.up.applyMatrix4(rotationMatrix);\n      mirrorCamera.up.reflect(normal);\n      mirrorCamera.lookAt(target);\n      mirrorCamera.far = camera.far; // Used in WebGLBackground\n\n      mirrorCamera.updateMatrixWorld();\n      mirrorCamera.projectionMatrix.copy(camera.projectionMatrix); // Update the texture matrix\n\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n      textureMatrix.multiply(mirrorCamera.projectionMatrix);\n      textureMatrix.multiply(mirrorCamera.matrixWorldInverse); // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n      // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\n      mirrorPlane.setFromNormalAndCoplanarPoint(normal, mirrorWorldPosition);\n      mirrorPlane.applyMatrix4(mirrorCamera.matrixWorldInverse);\n      clipPlane.set(mirrorPlane.normal.x, mirrorPlane.normal.y, mirrorPlane.normal.z, mirrorPlane.constant);\n      var projectionMatrix = mirrorCamera.projectionMatrix;\n      q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n      q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n      q.z = -1.0;\n      q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]; // Calculate the scaled plane vector\n\n      clipPlane.multiplyScalar(2.0 / clipPlane.dot(q)); // Replacing the third row of the projection matrix\n\n      projectionMatrix.elements[2] = clipPlane.x;\n      projectionMatrix.elements[6] = clipPlane.y;\n      projectionMatrix.elements[10] = clipPlane.z + 1.0 - clipBias;\n      projectionMatrix.elements[14] = clipPlane.w;\n      eye.setFromMatrixPosition(camera.matrixWorld); // Render\n\n      var currentRenderTarget = renderer.getRenderTarget();\n      var currentXrEnabled = renderer.xr.enabled;\n      var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      scope.visible = false;\n      renderer.xr.enabled = false; // Avoid camera modification and recursion\n\n      renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n      renderer.setRenderTarget(renderTarget);\n      renderer.state.buffers.depth.setMask(true); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n      if (renderer.autoClear === false) renderer.clear();\n      renderer.render(scene, mirrorCamera);\n      scope.visible = true;\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.setRenderTarget(currentRenderTarget); // Restore viewport\n\n      var viewport = camera.viewport;\n      if (viewport !== undefined) {\n        renderer.state.viewport(viewport);\n      }\n    };\n    return _this;\n  }\n  return _createClass(Water);\n}(Mesh);\nWater.prototype.isWater = true;\nexport { Water };","map":{"version":3,"names":["Mesh","Vector3","Color","FrontSide","Plane","Matrix4","Vector4","PerspectiveCamera","WebGLRenderTarget","UniformsUtils","UniformsLib","ShaderMaterial","Water","_Mesh","_inherits","_super","_createSuper","geometry","_this","options","arguments","length","undefined","_classCallCheck","call","scope","_assertThisInitialized","textureWidth","textureHeight","clipBias","alpha","time","normalSampler","waterNormals","sunDirection","sunColor","waterColor","eye","distortionScale","side","fog","mirrorPlane","normal","mirrorWorldPosition","cameraWorldPosition","rotationMatrix","lookAtPosition","clipPlane","view","target","q","textureMatrix","mirrorCamera","renderTarget","mirrorShader","uniforms","merge","value","mirrorSampler","size","vertexShader","fragmentShader","material","clone","lights","texture","onBeforeRender","renderer","scene","camera","setFromMatrixPosition","matrixWorld","extractRotation","set","applyMatrix4","subVectors","dot","reflect","negate","add","position","copy","up","lookAt","far","updateMatrixWorld","projectionMatrix","multiply","matrixWorldInverse","setFromNormalAndCoplanarPoint","x","y","z","constant","Math","sign","elements","w","multiplyScalar","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","visible","setRenderTarget","state","buffers","depth","setMask","autoClear","clear","render","viewport","_createClass","prototype","isWater"],"sources":["/home/samuel/experiment/3d/farm/frontend/node_modules/three-stdlib/objects/Water.js"],"sourcesContent":["import { Mesh, Vector3, Color, FrontSide, Plane, Matrix4, Vector4, PerspectiveCamera, WebGLRenderTarget, UniformsUtils, UniformsLib, ShaderMaterial } from 'three';\n\n/**\n * Work based on :\n * https://github.com/Slayvin: Flat mirror for three.js\n * https://home.adelphi.edu/~stemkoski/ : An implementation of water shader based on the flat mirror\n * http://29a.ch/ && http://29a.ch/slides/2012/webglwater/ : Water shader explanations in WebGL\n */\n\nclass Water extends Mesh {\n  constructor(geometry, options = {}) {\n    super(geometry);\n    const scope = this;\n    const textureWidth = options.textureWidth !== undefined ? options.textureWidth : 512;\n    const textureHeight = options.textureHeight !== undefined ? options.textureHeight : 512;\n    const clipBias = options.clipBias !== undefined ? options.clipBias : 0.0;\n    const alpha = options.alpha !== undefined ? options.alpha : 1.0;\n    const time = options.time !== undefined ? options.time : 0.0;\n    const normalSampler = options.waterNormals !== undefined ? options.waterNormals : null;\n    const sunDirection = options.sunDirection !== undefined ? options.sunDirection : new Vector3(0.70707, 0.70707, 0.0);\n    const sunColor = new Color(options.sunColor !== undefined ? options.sunColor : 0xffffff);\n    const waterColor = new Color(options.waterColor !== undefined ? options.waterColor : 0x7f7f7f);\n    const eye = options.eye !== undefined ? options.eye : new Vector3(0, 0, 0);\n    const distortionScale = options.distortionScale !== undefined ? options.distortionScale : 20.0;\n    const side = options.side !== undefined ? options.side : FrontSide;\n    const fog = options.fog !== undefined ? options.fog : false; //\n\n    const mirrorPlane = new Plane();\n    const normal = new Vector3();\n    const mirrorWorldPosition = new Vector3();\n    const cameraWorldPosition = new Vector3();\n    const rotationMatrix = new Matrix4();\n    const lookAtPosition = new Vector3(0, 0, -1);\n    const clipPlane = new Vector4();\n    const view = new Vector3();\n    const target = new Vector3();\n    const q = new Vector4();\n    const textureMatrix = new Matrix4();\n    const mirrorCamera = new PerspectiveCamera();\n    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight);\n    const mirrorShader = {\n      uniforms: UniformsUtils.merge([UniformsLib['fog'], UniformsLib['lights'], {\n        normalSampler: {\n          value: null\n        },\n        mirrorSampler: {\n          value: null\n        },\n        alpha: {\n          value: 1.0\n        },\n        time: {\n          value: 0.0\n        },\n        size: {\n          value: 1.0\n        },\n        distortionScale: {\n          value: 20.0\n        },\n        textureMatrix: {\n          value: new Matrix4()\n        },\n        sunColor: {\n          value: new Color(0x7f7f7f)\n        },\n        sunDirection: {\n          value: new Vector3(0.70707, 0.70707, 0)\n        },\n        eye: {\n          value: new Vector3()\n        },\n        waterColor: {\n          value: new Color(0x555555)\n        }\n      }]),\n      vertexShader:\n      /* glsl */\n      `\n\t\t\t\tuniform mat4 textureMatrix;\n\t\t\t\tuniform float time;\n\n\t\t\t\tvarying vec4 mirrorCoord;\n\t\t\t\tvarying vec4 worldPosition;\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <fog_pars_vertex>\n\t\t\t\t#include <shadowmap_pars_vertex>\n\t\t\t\t#include <logdepthbuf_pars_vertex>\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tmirrorCoord = modelMatrix * vec4( position, 1.0 );\n\t\t\t\t\tworldPosition = mirrorCoord.xyzw;\n\t\t\t\t\tmirrorCoord = textureMatrix * mirrorCoord;\n\t\t\t\t\tvec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t\t#include <beginnormal_vertex>\n\t\t\t\t#include <defaultnormal_vertex>\n\t\t\t\t#include <logdepthbuf_vertex>\n\t\t\t\t#include <fog_vertex>\n\t\t\t\t#include <shadowmap_vertex>\n\t\t\t}`,\n      fragmentShader:\n      /* glsl */\n      `\n\t\t\t\tuniform sampler2D mirrorSampler;\n\t\t\t\tuniform float alpha;\n\t\t\t\tuniform float time;\n\t\t\t\tuniform float size;\n\t\t\t\tuniform float distortionScale;\n\t\t\t\tuniform sampler2D normalSampler;\n\t\t\t\tuniform vec3 sunColor;\n\t\t\t\tuniform vec3 sunDirection;\n\t\t\t\tuniform vec3 eye;\n\t\t\t\tuniform vec3 waterColor;\n\n\t\t\t\tvarying vec4 mirrorCoord;\n\t\t\t\tvarying vec4 worldPosition;\n\n\t\t\t\tvec4 getNoise( vec2 uv ) {\n\t\t\t\t\tvec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);\n\t\t\t\t\tvec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );\n\t\t\t\t\tvec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );\n\t\t\t\t\tvec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );\n\t\t\t\t\tvec4 noise = texture2D( normalSampler, uv0 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv1 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv2 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv3 );\n\t\t\t\t\treturn noise * 0.5 - 1.0;\n\t\t\t\t}\n\n\t\t\t\tvoid sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {\n\t\t\t\t\tvec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );\n\t\t\t\t\tfloat direction = max( 0.0, dot( eyeDirection, reflection ) );\n\t\t\t\t\tspecularColor += pow( direction, shiny ) * sunColor * spec;\n\t\t\t\t\tdiffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;\n\t\t\t\t}\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <packing>\n\t\t\t\t#include <bsdfs>\n\t\t\t\t#include <fog_pars_fragment>\n\t\t\t\t#include <logdepthbuf_pars_fragment>\n\t\t\t\t#include <lights_pars_begin>\n\t\t\t\t#include <shadowmap_pars_fragment>\n\t\t\t\t#include <shadowmask_pars_fragment>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#include <logdepthbuf_fragment>\n\t\t\t\t\tvec4 noise = getNoise( worldPosition.xz * size );\n\t\t\t\t\tvec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );\n\n\t\t\t\t\tvec3 diffuseLight = vec3(0.0);\n\t\t\t\t\tvec3 specularLight = vec3(0.0);\n\n\t\t\t\t\tvec3 worldToEye = eye-worldPosition.xyz;\n\t\t\t\t\tvec3 eyeDirection = normalize( worldToEye );\n\t\t\t\t\tsunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );\n\n\t\t\t\t\tfloat distance = length(worldToEye);\n\n\t\t\t\t\tvec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;\n\t\t\t\t\tvec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );\n\n\t\t\t\t\tfloat theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );\n\t\t\t\t\tfloat rf0 = 0.3;\n\t\t\t\t\tfloat reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );\n\t\t\t\t\tvec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;\n\t\t\t\t\tvec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);\n\t\t\t\t\tvec3 outgoingLight = albedo;\n\t\t\t\t\tgl_FragColor = vec4( outgoingLight, alpha );\n\n\t\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t\t#include <fog_fragment>\n\t\t\t\t}`\n    };\n    const material = new ShaderMaterial({\n      fragmentShader: mirrorShader.fragmentShader,\n      vertexShader: mirrorShader.vertexShader,\n      uniforms: UniformsUtils.clone(mirrorShader.uniforms),\n      lights: true,\n      side: side,\n      fog: fog\n    });\n    material.uniforms['mirrorSampler'].value = renderTarget.texture;\n    material.uniforms['textureMatrix'].value = textureMatrix;\n    material.uniforms['alpha'].value = alpha;\n    material.uniforms['time'].value = time;\n    material.uniforms['normalSampler'].value = normalSampler;\n    material.uniforms['sunColor'].value = sunColor;\n    material.uniforms['waterColor'].value = waterColor;\n    material.uniforms['sunDirection'].value = sunDirection;\n    material.uniforms['distortionScale'].value = distortionScale;\n    material.uniforms['eye'].value = eye;\n    scope.material = material;\n\n    scope.onBeforeRender = function (renderer, scene, camera) {\n      mirrorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n      rotationMatrix.extractRotation(scope.matrixWorld);\n      normal.set(0, 0, 1);\n      normal.applyMatrix4(rotationMatrix);\n      view.subVectors(mirrorWorldPosition, cameraWorldPosition); // Avoid rendering when mirror is facing away\n\n      if (view.dot(normal) > 0) return;\n      view.reflect(normal).negate();\n      view.add(mirrorWorldPosition);\n      rotationMatrix.extractRotation(camera.matrixWorld);\n      lookAtPosition.set(0, 0, -1);\n      lookAtPosition.applyMatrix4(rotationMatrix);\n      lookAtPosition.add(cameraWorldPosition);\n      target.subVectors(mirrorWorldPosition, lookAtPosition);\n      target.reflect(normal).negate();\n      target.add(mirrorWorldPosition);\n      mirrorCamera.position.copy(view);\n      mirrorCamera.up.set(0, 1, 0);\n      mirrorCamera.up.applyMatrix4(rotationMatrix);\n      mirrorCamera.up.reflect(normal);\n      mirrorCamera.lookAt(target);\n      mirrorCamera.far = camera.far; // Used in WebGLBackground\n\n      mirrorCamera.updateMatrixWorld();\n      mirrorCamera.projectionMatrix.copy(camera.projectionMatrix); // Update the texture matrix\n\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n      textureMatrix.multiply(mirrorCamera.projectionMatrix);\n      textureMatrix.multiply(mirrorCamera.matrixWorldInverse); // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n      // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\n      mirrorPlane.setFromNormalAndCoplanarPoint(normal, mirrorWorldPosition);\n      mirrorPlane.applyMatrix4(mirrorCamera.matrixWorldInverse);\n      clipPlane.set(mirrorPlane.normal.x, mirrorPlane.normal.y, mirrorPlane.normal.z, mirrorPlane.constant);\n      const projectionMatrix = mirrorCamera.projectionMatrix;\n      q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n      q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n      q.z = -1.0;\n      q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]; // Calculate the scaled plane vector\n\n      clipPlane.multiplyScalar(2.0 / clipPlane.dot(q)); // Replacing the third row of the projection matrix\n\n      projectionMatrix.elements[2] = clipPlane.x;\n      projectionMatrix.elements[6] = clipPlane.y;\n      projectionMatrix.elements[10] = clipPlane.z + 1.0 - clipBias;\n      projectionMatrix.elements[14] = clipPlane.w;\n      eye.setFromMatrixPosition(camera.matrixWorld); // Render\n\n      const currentRenderTarget = renderer.getRenderTarget();\n      const currentXrEnabled = renderer.xr.enabled;\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      scope.visible = false;\n      renderer.xr.enabled = false; // Avoid camera modification and recursion\n\n      renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n      renderer.setRenderTarget(renderTarget);\n      renderer.state.buffers.depth.setMask(true); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n      if (renderer.autoClear === false) renderer.clear();\n      renderer.render(scene, mirrorCamera);\n      scope.visible = true;\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.setRenderTarget(currentRenderTarget); // Restore viewport\n\n      const viewport = camera.viewport;\n\n      if (viewport !== undefined) {\n        renderer.state.viewport(viewport);\n      }\n    };\n  }\n\n}\n\nWater.prototype.isWater = true;\n\nexport { Water };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}