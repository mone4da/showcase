{"ast":null,"code":"import _assertThisInitialized from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _classCallCheck from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/samuel/experiment/3d/farm/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { DataTexture, RGBAFormat, FloatType, RepeatWrapping, NearestFilter, Mesh, InstancedMesh, Matrix4, DynamicDrawUsage } from 'three';\n\n// Original src: https://github.com/zz85/threejs-path-flow\nvar CHANNELS = 4;\nvar TEXTURE_WIDTH = 1024;\nvar TEXTURE_HEIGHT = 4;\n\n/**\n * Make a new DataTexture to store the descriptions of the curves.\n *\n * @param { number } numberOfCurves the number of curves needed to be described by this texture.\n */\nvar initSplineTexture = function initSplineTexture() {\n  var numberOfCurves = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n  var dataArray = new Float32Array(TEXTURE_WIDTH * TEXTURE_HEIGHT * numberOfCurves * CHANNELS);\n  var dataTexture = new DataTexture(dataArray, TEXTURE_WIDTH, TEXTURE_HEIGHT * numberOfCurves, RGBAFormat, FloatType);\n  dataTexture.wrapS = RepeatWrapping;\n  dataTexture.wrapT = RepeatWrapping;\n  dataTexture.magFilter = NearestFilter;\n  dataTexture.needsUpdate = true;\n  return dataTexture;\n};\n/**\n * Write the curve description to the data texture\n *\n * @param { DataTexture } texture The DataTexture to write to\n * @param { Curve } splineCurve The curve to describe\n * @param { number } offset Which curve slot to write to\n */\n\nvar updateSplineTexture = function updateSplineTexture(texture, splineCurve) {\n  var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var numberOfPoints = Math.floor(TEXTURE_WIDTH * (TEXTURE_HEIGHT / 4));\n  splineCurve.arcLengthDivisions = numberOfPoints / 2;\n  splineCurve.updateArcLengths();\n  var points = splineCurve.getSpacedPoints(numberOfPoints);\n  var frenetFrames = splineCurve.computeFrenetFrames(numberOfPoints, true);\n  for (var i = 0; i < numberOfPoints; i++) {\n    var rowOffset = Math.floor(i / TEXTURE_WIDTH);\n    var rowIndex = i % TEXTURE_WIDTH;\n    var pt = points[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 0 + rowOffset + TEXTURE_HEIGHT * offset);\n    pt = frenetFrames.tangents[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 1 + rowOffset + TEXTURE_HEIGHT * offset);\n    pt = frenetFrames.normals[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 2 + rowOffset + TEXTURE_HEIGHT * offset);\n    pt = frenetFrames.binormals[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 3 + rowOffset + TEXTURE_HEIGHT * offset);\n  }\n  texture.needsUpdate = true;\n};\nvar setTextureValue = function setTextureValue(texture, index, x, y, z, o) {\n  var image = texture.image;\n  var data = image.data;\n  var i = CHANNELS * TEXTURE_WIDTH * o; // Row Offset\n\n  data[index * CHANNELS + i + 0] = x;\n  data[index * CHANNELS + i + 1] = y;\n  data[index * CHANNELS + i + 2] = z;\n  data[index * CHANNELS + i + 3] = 1;\n};\n\n/**\n * Create a new set of uniforms for describing the curve modifier\n *\n * @param { DataTexture } Texture which holds the curve description\n */\nvar getUniforms = function getUniforms(splineTexture) {\n  return {\n    spineTexture: {\n      value: splineTexture\n    },\n    pathOffset: {\n      type: 'f',\n      value: 0\n    },\n    // time of path curve\n    pathSegment: {\n      type: 'f',\n      value: 1\n    },\n    // fractional length of path\n    spineOffset: {\n      type: 'f',\n      value: 161\n    },\n    spineLength: {\n      type: 'f',\n      value: 400\n    },\n    flow: {\n      type: 'i',\n      value: 1\n    }\n  };\n};\nfunction modifyShader(material, uniforms) {\n  var numberOfCurves = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  if (material.__ok) return;\n  material.__ok = true;\n  material.onBeforeCompile = function (shader) {\n    if (shader.__modified) return;\n    shader.__modified = true;\n    Object.assign(shader.uniforms, uniforms);\n    var vertexShader = /* glsl */\n    \"\\n\\t\\tuniform sampler2D spineTexture;\\n\\t\\tuniform float pathOffset;\\n\\t\\tuniform float pathSegment;\\n\\t\\tuniform float spineOffset;\\n\\t\\tuniform float spineLength;\\n\\t\\tuniform int flow;\\n\\n\\t\\tfloat textureLayers = \".concat(TEXTURE_HEIGHT * numberOfCurves, \".;\\n\\t\\tfloat textureStacks = \").concat(TEXTURE_HEIGHT / 4, \".;\\n\\n\\t\\t\").concat(shader.vertexShader, \"\\n\\t\\t\") // chunk import moved in front of modified shader below\n    .replace('#include <beginnormal_vertex>', '') // vec3 transformedNormal declaration overriden below\n    .replace('#include <defaultnormal_vertex>', '') // vec3 transformed declaration overriden below\n    .replace('#include <begin_vertex>', '') // shader override\n    .replace(/void\\s*main\\s*\\(\\)\\s*\\{/, /* glsl */\"\\n        void main() {\\n        #include <beginnormal_vertex>\\n\\n        vec4 worldPos = modelMatrix * vec4(position, 1.);\\n\\n        bool bend = flow > 0;\\n        float xWeight = bend ? 0. : 1.;\\n\\n        #ifdef USE_INSTANCING\\n        float pathOffsetFromInstanceMatrix = instanceMatrix[3][2];\\n        float spineLengthFromInstanceMatrix = instanceMatrix[3][0];\\n        float spinePortion = bend ? (worldPos.x + spineOffset) / spineLengthFromInstanceMatrix : 0.;\\n        float mt = (spinePortion * pathSegment + pathOffset + pathOffsetFromInstanceMatrix)*textureStacks;\\n        #else\\n        float spinePortion = bend ? (worldPos.x + spineOffset) / spineLength : 0.;\\n        float mt = (spinePortion * pathSegment + pathOffset)*textureStacks;\\n        #endif\\n\\n        mt = mod(mt, textureStacks);\\n        float rowOffset = floor(mt);\\n\\n        #ifdef USE_INSTANCING\\n        rowOffset += instanceMatrix[3][1] * \".concat(TEXTURE_HEIGHT, \".;\\n        #endif\\n\\n        vec3 spinePos = texture2D(spineTexture, vec2(mt, (0. + rowOffset + 0.5) / textureLayers)).xyz;\\n        vec3 a =        texture2D(spineTexture, vec2(mt, (1. + rowOffset + 0.5) / textureLayers)).xyz;\\n        vec3 b =        texture2D(spineTexture, vec2(mt, (2. + rowOffset + 0.5) / textureLayers)).xyz;\\n        vec3 c =        texture2D(spineTexture, vec2(mt, (3. + rowOffset + 0.5) / textureLayers)).xyz;\\n        mat3 basis = mat3(a, b, c);\\n\\n        vec3 transformed = basis\\n          * vec3(worldPos.x * xWeight, worldPos.y * 1., worldPos.z * 1.)\\n          + spinePos;\\n\\n        vec3 transformedNormal = normalMatrix * (basis * objectNormal);\\n\\t\\t\\t\")).replace('#include <project_vertex>', /* glsl */\"vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\\n\\t\\t\\t\\tgl_Position = projectionMatrix * mvPosition;\");\n    shader.vertexShader = vertexShader;\n  };\n}\n/**\n * A helper class for making meshes bend aroudn curves\n */\nvar Flow = /*#__PURE__*/function () {\n  /**\n   * @param {Mesh} mesh The mesh to clone and modify to bend around the curve\n   * @param {number} numberOfCurves The amount of space that should preallocated for additional curves\n   */\n  function Flow(mesh) {\n    var numberOfCurves = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    _classCallCheck(this, Flow);\n    _defineProperty(this, \"curveArray\", void 0);\n    _defineProperty(this, \"curveLengthArray\", void 0);\n    _defineProperty(this, \"object3D\", void 0);\n    _defineProperty(this, \"splineTexure\", void 0);\n    _defineProperty(this, \"uniforms\", void 0);\n    var obj3D = mesh.clone();\n    var splineTexure = initSplineTexture(numberOfCurves);\n    var uniforms = getUniforms(splineTexure);\n    obj3D.traverse(function (child) {\n      if (child instanceof Mesh || child instanceof InstancedMesh) {\n        child.material = child.material.clone();\n        modifyShader(child.material, uniforms, numberOfCurves);\n      }\n    });\n    this.curveArray = new Array(numberOfCurves);\n    this.curveLengthArray = new Array(numberOfCurves);\n    this.object3D = obj3D;\n    this.splineTexure = splineTexure;\n    this.uniforms = uniforms;\n  }\n  _createClass(Flow, [{\n    key: \"updateCurve\",\n    value: function updateCurve(index, curve) {\n      if (index >= this.curveArray.length) throw Error('Index out of range for Flow');\n      var curveLength = curve.getLength();\n      this.uniforms.spineLength.value = curveLength;\n      this.curveLengthArray[index] = curveLength;\n      this.curveArray[index] = curve;\n      updateSplineTexture(this.splineTexure, curve, index);\n    }\n  }, {\n    key: \"moveAlongCurve\",\n    value: function moveAlongCurve(amount) {\n      this.uniforms.pathOffset.value += amount;\n    }\n  }]);\n  return Flow;\n}();\nvar matrix = new Matrix4();\n/**\n * A helper class for creating instanced versions of flow, where the instances are placed on the curve.\n */\nvar InstancedFlow = /*#__PURE__*/function (_Flow) {\n  _inherits(InstancedFlow, _Flow);\n  var _super = _createSuper(InstancedFlow);\n  /**\n   *\n   * @param {number} count The number of instanced elements\n   * @param {number} curveCount The number of curves to preallocate for\n   * @param {Geometry} geometry The geometry to use for the instanced mesh\n   * @param {Material} material The material to use for the instanced mesh\n   */\n  function InstancedFlow(count, curveCount, geometry, material) {\n    var _this;\n    _classCallCheck(this, InstancedFlow);\n    var mesh = new InstancedMesh(geometry, material, count);\n    mesh.instanceMatrix.setUsage(DynamicDrawUsage);\n    mesh.frustumCulled = false;\n    _this = _super.call(this, mesh, curveCount);\n    _defineProperty(_assertThisInitialized(_this), \"offsets\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"whichCurve\", void 0);\n    _this.offsets = new Array(count).fill(0);\n    _this.whichCurve = new Array(count).fill(0);\n    return _this;\n  }\n  /**\n   * The extra information about which curve and curve position is stored in the translation components of the matrix for the instanced objects\n   * This writes that information to the matrix and marks it as needing update.\n   *\n   * @param {number} index of the instanced element to update\n   */\n  _createClass(InstancedFlow, [{\n    key: \"writeChanges\",\n    value: function writeChanges(index) {\n      matrix.makeTranslation(this.curveLengthArray[this.whichCurve[index]], this.whichCurve[index], this.offsets[index]);\n      this.object3D.setMatrixAt(index, matrix);\n      this.object3D.instanceMatrix.needsUpdate = true;\n    }\n    /**\n     * Move an individual element along the curve by a specific amount\n     *\n     * @param {number} index Which element to update\n     * @param {number} offset Move by how much\n     */\n  }, {\n    key: \"moveIndividualAlongCurve\",\n    value: function moveIndividualAlongCurve(index, offset) {\n      this.offsets[index] += offset;\n      this.writeChanges(index);\n    }\n    /**\n     * Select which curve to use for an element\n     *\n     * @param {number} index the index of the instanced element to update\n     * @param {number} curveNo the index of the curve it should use\n     */\n  }, {\n    key: \"setCurve\",\n    value: function setCurve(index, curveNo) {\n      if (isNaN(curveNo)) throw Error('curve index being set is Not a Number (NaN)');\n      this.whichCurve[index] = curveNo;\n      this.writeChanges(index);\n    }\n  }]);\n  return InstancedFlow;\n}(Flow);\nexport { Flow, InstancedFlow, getUniforms, initSplineTexture, modifyShader, updateSplineTexture };","map":{"version":3,"names":["_defineProperty","DataTexture","RGBAFormat","FloatType","RepeatWrapping","NearestFilter","Mesh","InstancedMesh","Matrix4","DynamicDrawUsage","CHANNELS","TEXTURE_WIDTH","TEXTURE_HEIGHT","initSplineTexture","numberOfCurves","arguments","length","undefined","dataArray","Float32Array","dataTexture","wrapS","wrapT","magFilter","needsUpdate","updateSplineTexture","texture","splineCurve","offset","numberOfPoints","Math","floor","arcLengthDivisions","updateArcLengths","points","getSpacedPoints","frenetFrames","computeFrenetFrames","i","rowOffset","rowIndex","pt","setTextureValue","x","y","z","tangents","normals","binormals","index","o","image","data","getUniforms","splineTexture","spineTexture","value","pathOffset","type","pathSegment","spineOffset","spineLength","flow","modifyShader","material","uniforms","__ok","onBeforeCompile","shader","__modified","Object","assign","vertexShader","concat","replace","Flow","mesh","_classCallCheck","obj3D","clone","splineTexure","traverse","child","curveArray","Array","curveLengthArray","object3D","_createClass","key","updateCurve","curve","Error","curveLength","getLength","moveAlongCurve","amount","matrix","InstancedFlow","_Flow","_inherits","_super","_createSuper","count","curveCount","geometry","_this","instanceMatrix","setUsage","frustumCulled","call","_assertThisInitialized","offsets","fill","whichCurve","writeChanges","makeTranslation","setMatrixAt","moveIndividualAlongCurve","setCurve","curveNo","isNaN"],"sources":["/home/samuel/experiment/3d/farm/frontend/node_modules/three-stdlib/modifiers/CurveModifier.js"],"sourcesContent":["import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { DataTexture, RGBAFormat, FloatType, RepeatWrapping, NearestFilter, Mesh, InstancedMesh, Matrix4, DynamicDrawUsage } from 'three';\n\n// Original src: https://github.com/zz85/threejs-path-flow\nconst CHANNELS = 4;\nconst TEXTURE_WIDTH = 1024;\nconst TEXTURE_HEIGHT = 4;\n\n/**\n * Make a new DataTexture to store the descriptions of the curves.\n *\n * @param { number } numberOfCurves the number of curves needed to be described by this texture.\n */\nconst initSplineTexture = (numberOfCurves = 1) => {\n  const dataArray = new Float32Array(TEXTURE_WIDTH * TEXTURE_HEIGHT * numberOfCurves * CHANNELS);\n  const dataTexture = new DataTexture(dataArray, TEXTURE_WIDTH, TEXTURE_HEIGHT * numberOfCurves, RGBAFormat, FloatType);\n  dataTexture.wrapS = RepeatWrapping;\n  dataTexture.wrapT = RepeatWrapping;\n  dataTexture.magFilter = NearestFilter;\n  dataTexture.needsUpdate = true;\n  return dataTexture;\n};\n/**\n * Write the curve description to the data texture\n *\n * @param { DataTexture } texture The DataTexture to write to\n * @param { Curve } splineCurve The curve to describe\n * @param { number } offset Which curve slot to write to\n */\n\nconst updateSplineTexture = (texture, splineCurve, offset = 0) => {\n  const numberOfPoints = Math.floor(TEXTURE_WIDTH * (TEXTURE_HEIGHT / 4));\n  splineCurve.arcLengthDivisions = numberOfPoints / 2;\n  splineCurve.updateArcLengths();\n  const points = splineCurve.getSpacedPoints(numberOfPoints);\n  const frenetFrames = splineCurve.computeFrenetFrames(numberOfPoints, true);\n\n  for (let i = 0; i < numberOfPoints; i++) {\n    const rowOffset = Math.floor(i / TEXTURE_WIDTH);\n    const rowIndex = i % TEXTURE_WIDTH;\n    let pt = points[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 0 + rowOffset + TEXTURE_HEIGHT * offset);\n    pt = frenetFrames.tangents[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 1 + rowOffset + TEXTURE_HEIGHT * offset);\n    pt = frenetFrames.normals[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 2 + rowOffset + TEXTURE_HEIGHT * offset);\n    pt = frenetFrames.binormals[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 3 + rowOffset + TEXTURE_HEIGHT * offset);\n  }\n\n  texture.needsUpdate = true;\n};\n\nconst setTextureValue = (texture, index, x, y, z, o) => {\n  const image = texture.image;\n  const {\n    data\n  } = image;\n  const i = CHANNELS * TEXTURE_WIDTH * o; // Row Offset\n\n  data[index * CHANNELS + i + 0] = x;\n  data[index * CHANNELS + i + 1] = y;\n  data[index * CHANNELS + i + 2] = z;\n  data[index * CHANNELS + i + 3] = 1;\n};\n\n/**\n * Create a new set of uniforms for describing the curve modifier\n *\n * @param { DataTexture } Texture which holds the curve description\n */\nconst getUniforms = splineTexture => ({\n  spineTexture: {\n    value: splineTexture\n  },\n  pathOffset: {\n    type: 'f',\n    value: 0\n  },\n  // time of path curve\n  pathSegment: {\n    type: 'f',\n    value: 1\n  },\n  // fractional length of path\n  spineOffset: {\n    type: 'f',\n    value: 161\n  },\n  spineLength: {\n    type: 'f',\n    value: 400\n  },\n  flow: {\n    type: 'i',\n    value: 1\n  }\n});\nfunction modifyShader(material, uniforms, numberOfCurves = 1) {\n  if (material.__ok) return;\n  material.__ok = true;\n\n  material.onBeforeCompile = shader => {\n    if (shader.__modified) return;\n    shader.__modified = true;\n    Object.assign(shader.uniforms, uniforms);\n    const vertexShader =\n    /* glsl */\n    `\n\t\tuniform sampler2D spineTexture;\n\t\tuniform float pathOffset;\n\t\tuniform float pathSegment;\n\t\tuniform float spineOffset;\n\t\tuniform float spineLength;\n\t\tuniform int flow;\n\n\t\tfloat textureLayers = ${TEXTURE_HEIGHT * numberOfCurves}.;\n\t\tfloat textureStacks = ${TEXTURE_HEIGHT / 4}.;\n\n\t\t${shader.vertexShader}\n\t\t` // chunk import moved in front of modified shader below\n    .replace('#include <beginnormal_vertex>', '') // vec3 transformedNormal declaration overriden below\n    .replace('#include <defaultnormal_vertex>', '') // vec3 transformed declaration overriden below\n    .replace('#include <begin_vertex>', '') // shader override\n    .replace(/void\\s*main\\s*\\(\\)\\s*\\{/,\n    /* glsl */\n    `\n        void main() {\n        #include <beginnormal_vertex>\n\n        vec4 worldPos = modelMatrix * vec4(position, 1.);\n\n        bool bend = flow > 0;\n        float xWeight = bend ? 0. : 1.;\n\n        #ifdef USE_INSTANCING\n        float pathOffsetFromInstanceMatrix = instanceMatrix[3][2];\n        float spineLengthFromInstanceMatrix = instanceMatrix[3][0];\n        float spinePortion = bend ? (worldPos.x + spineOffset) / spineLengthFromInstanceMatrix : 0.;\n        float mt = (spinePortion * pathSegment + pathOffset + pathOffsetFromInstanceMatrix)*textureStacks;\n        #else\n        float spinePortion = bend ? (worldPos.x + spineOffset) / spineLength : 0.;\n        float mt = (spinePortion * pathSegment + pathOffset)*textureStacks;\n        #endif\n\n        mt = mod(mt, textureStacks);\n        float rowOffset = floor(mt);\n\n        #ifdef USE_INSTANCING\n        rowOffset += instanceMatrix[3][1] * ${TEXTURE_HEIGHT}.;\n        #endif\n\n        vec3 spinePos = texture2D(spineTexture, vec2(mt, (0. + rowOffset + 0.5) / textureLayers)).xyz;\n        vec3 a =        texture2D(spineTexture, vec2(mt, (1. + rowOffset + 0.5) / textureLayers)).xyz;\n        vec3 b =        texture2D(spineTexture, vec2(mt, (2. + rowOffset + 0.5) / textureLayers)).xyz;\n        vec3 c =        texture2D(spineTexture, vec2(mt, (3. + rowOffset + 0.5) / textureLayers)).xyz;\n        mat3 basis = mat3(a, b, c);\n\n        vec3 transformed = basis\n          * vec3(worldPos.x * xWeight, worldPos.y * 1., worldPos.z * 1.)\n          + spinePos;\n\n        vec3 transformedNormal = normalMatrix * (basis * objectNormal);\n\t\t\t`).replace('#include <project_vertex>',\n    /* glsl */\n    `vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n\t\t\t\tgl_Position = projectionMatrix * mvPosition;`);\n    shader.vertexShader = vertexShader;\n  };\n}\n/**\n * A helper class for making meshes bend aroudn curves\n */\n\nclass Flow {\n  /**\n   * @param {Mesh} mesh The mesh to clone and modify to bend around the curve\n   * @param {number} numberOfCurves The amount of space that should preallocated for additional curves\n   */\n  constructor(mesh, numberOfCurves = 1) {\n    _defineProperty(this, \"curveArray\", void 0);\n\n    _defineProperty(this, \"curveLengthArray\", void 0);\n\n    _defineProperty(this, \"object3D\", void 0);\n\n    _defineProperty(this, \"splineTexure\", void 0);\n\n    _defineProperty(this, \"uniforms\", void 0);\n\n    const obj3D = mesh.clone();\n    const splineTexure = initSplineTexture(numberOfCurves);\n    const uniforms = getUniforms(splineTexure);\n    obj3D.traverse(child => {\n      if (child instanceof Mesh || child instanceof InstancedMesh) {\n        child.material = child.material.clone();\n        modifyShader(child.material, uniforms, numberOfCurves);\n      }\n    });\n    this.curveArray = new Array(numberOfCurves);\n    this.curveLengthArray = new Array(numberOfCurves);\n    this.object3D = obj3D;\n    this.splineTexure = splineTexure;\n    this.uniforms = uniforms;\n  }\n\n  updateCurve(index, curve) {\n    if (index >= this.curveArray.length) throw Error('Index out of range for Flow');\n    const curveLength = curve.getLength();\n    this.uniforms.spineLength.value = curveLength;\n    this.curveLengthArray[index] = curveLength;\n    this.curveArray[index] = curve;\n    updateSplineTexture(this.splineTexure, curve, index);\n  }\n\n  moveAlongCurve(amount) {\n    this.uniforms.pathOffset.value += amount;\n  }\n\n}\nconst matrix = new Matrix4();\n/**\n * A helper class for creating instanced versions of flow, where the instances are placed on the curve.\n */\n\nclass InstancedFlow extends Flow {\n  /**\n   *\n   * @param {number} count The number of instanced elements\n   * @param {number} curveCount The number of curves to preallocate for\n   * @param {Geometry} geometry The geometry to use for the instanced mesh\n   * @param {Material} material The material to use for the instanced mesh\n   */\n  constructor(count, curveCount, geometry, material) {\n    const mesh = new InstancedMesh(geometry, material, count);\n    mesh.instanceMatrix.setUsage(DynamicDrawUsage);\n    mesh.frustumCulled = false;\n    super(mesh, curveCount);\n\n    _defineProperty(this, \"offsets\", void 0);\n\n    _defineProperty(this, \"whichCurve\", void 0);\n\n    this.offsets = new Array(count).fill(0);\n    this.whichCurve = new Array(count).fill(0);\n  }\n  /**\n   * The extra information about which curve and curve position is stored in the translation components of the matrix for the instanced objects\n   * This writes that information to the matrix and marks it as needing update.\n   *\n   * @param {number} index of the instanced element to update\n   */\n\n\n  writeChanges(index) {\n    matrix.makeTranslation(this.curveLengthArray[this.whichCurve[index]], this.whichCurve[index], this.offsets[index]);\n    this.object3D.setMatrixAt(index, matrix);\n    this.object3D.instanceMatrix.needsUpdate = true;\n  }\n  /**\n   * Move an individual element along the curve by a specific amount\n   *\n   * @param {number} index Which element to update\n   * @param {number} offset Move by how much\n   */\n\n\n  moveIndividualAlongCurve(index, offset) {\n    this.offsets[index] += offset;\n    this.writeChanges(index);\n  }\n  /**\n   * Select which curve to use for an element\n   *\n   * @param {number} index the index of the instanced element to update\n   * @param {number} curveNo the index of the curve it should use\n   */\n\n\n  setCurve(index, curveNo) {\n    if (isNaN(curveNo)) throw Error('curve index being set is Not a Number (NaN)');\n    this.whichCurve[index] = curveNo;\n    this.writeChanges(index);\n  }\n\n}\n\nexport { Flow, InstancedFlow, getUniforms, initSplineTexture, modifyShader, updateSplineTexture };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}